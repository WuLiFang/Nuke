// HatchKernel v0.1.4
// TODO: release v1 after 2023-09-12
kernel HatchKernal : ImageComputationKernel<eComponentWise>
{
  Image<eRead, eAccessRanged2D, eEdgeClamped> src;
  Image<eWrite, eAccessPoint> dst;

param:
  // 0: raw
  // 1: center
  // 2: rotate around center
  int input;
  float2 size;
  float2 origin;
  float rotate;
  float rotateAroundCenter;
  // 0: input
  // 1: line
  // 2: dot
  // -1: offset0
  // -2: offset1
  // -3: p0 (raw)
  // -4: p1 (after rotate)
  // -5: center0
  // -6: center1
  // -7: index
  // -8: index is even
  int output;

local:
  void init() {
    src.setRange(-size.x, -size.x, size.y, size.y);
  }
  
  float2 rotate2D(float2 v, float radians)
  {
    if (radians == 0 || (v.x == 0 && v.y == 0)){
      return v;
    }
    return float2(
      v.x * cos(radians) - v.y * sin(radians),
      v.x * sin(radians) + v.y * cos(radians)
    );
  }
  
  void process(int3 pos)
  {
    float2 p0 = float2(pos.x, pos.y);
    int comp = pos.z;
    float2 p1 = rotate2D(p0-origin, rotate);
    int2 index = int2(floor(p1.x / size.x), floor(p1.y / size.y));
    float2 center1 = float2(
      float(index.x) * size.x + size.x / 2,
      float(index.y) * size.y + size.y / 2
    );
    float2 center0 = rotate2D(center1, -rotate) + origin;
    center0.x = floor(center0.x);
    center0.y = floor(center0.y);
    float2 offset1 = p1 - center1;
    float2 offset0 = p0 - center0;
    float v;
    if (input == 0) {
      v = src(0, 0);
    } else if (input == 1) {
      v = src(-int(offset0.x), -int(offset0.y));
    } else if (input == 2) {
      float2 offset = rotate2D(offset0, rotateAroundCenter) - offset0;
      v = src(-int(offset.x), -int(offset.y));
    } else if (input == 3) {
      float2 offset = rotate2D(offset0, rotateAroundCenter);
      v = src(-int(offset.x), -int(offset.y));
    } else {
      v = 0;
    }
    
    if (output == 0) {
      dst() = v;
    } else if (output == 1) {
      float h = v * size.y;
      dst() = fabs(offset1.y) <= h / 2.0;
    } else if (output == 2) {
      dst() = length(offset1 / size) <= v / 2.0;
    } else if (output == -1) {
      if (comp == 0) {
        dst() = offset0.x;
      } else if (comp == 1) {
        dst() = offset0.y;
      } else {
        dst() = 0;
      }
    } else if (output == -2) {
      if (comp == 0) {
        dst() = offset1.x;
      } else if (comp == 1) {
        dst() = offset1.y;
      } else {
        dst() = 0;
      }
    } else if (output == -3) {
      if (comp == 0) {
        dst() = p0.x;
      } else if (comp == 1) {
        dst() = p0.y;
      } else {
        dst() = 0;
      }
    } else if (output == -4) {
      if (comp == 0) {
        dst() = p1.x;
      } else if (comp == 1) {
        dst() = p1.y;
      } else {
        dst() = 0;
      }
    } else if (output == -5) {
      if (comp == 0) {
        dst() = center0.x;
      } else if (comp == 1) {
        dst() = center0.y;
      } else {
        dst() = 0;
      }
    } else if (output == -6) {
      if (comp == 0) {
        dst() = center1.x;
      } else if (comp == 1) {
        dst() = center1.y;
      } else {
        dst() = 0;
      }
    } else if (output == -7) {
      if (comp == 0) {
        dst() = index.x;
      } else if (comp == 1) {
        dst() = index.y;
      } else {
        dst() = 0;
      }
    } else if (output == -8) {
      if (comp == 0) {
        dst() = abs(index.x % 2);
      } else if (comp == 1) {
        dst() = abs(index.y % 2);
      } else {
        dst() = 0;
      }
    } else {
      dst() = 0;
    }
  }
};
