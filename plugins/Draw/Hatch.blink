// HatchKernel v0.1.1
// TODO: release v1 after 2023-09-11
kernel HatchKernal : ImageComputationKernel<eComponentWise>
{
  Image<eRead, eAccessRanged2D, eEdgeClamped> src;
  Image<eWrite, eAccessPoint> dst;

param:
  int size;
  float2 origin;
  float rotate;
  // -5: index is even
  // -4: index
  // -3: raw pos
  // -2: pos
  // -1: offset
  // 0: line
  // 1: dot
  int output;

local:
  void init() {
    src.setRange(-size, -size, size, size);
  }
  
  float2 rotate2D(float2 v, float radians)
  {
    return float2(
      v.x * cos(radians) - v.y * sin(radians),
      v.x * sin(radians) + v.y * cos(radians)
    );
  }

  float2 centerOffset(float2 p0)
  {
    int2 index = int2(floor(p0.x / size), floor(p0.y / size));
    float2 center = float2(
      index.x * size + float(size) / 2,
      index.y * size + float(size) / 2
    );
    return center - p0;
  }

  void process(int3 rawPos)
  {
    float2 pos = rotate2D(float2(rawPos.x, rawPos.y)-origin, rotate);
    int comp = rawPos.z;
    float2 offset = centerOffset(pos);
    float v = src(int(offset.x), int(offset.y));

    if (output == -5) {
        int2 index = int2(floor(pos.x / size), floor(pos.y / size));
        if (comp == 0) {
          dst() = abs(index.x % 2);
        } else if (comp == 1) {
          dst() = abs(index.y % 2);
        } else {
          dst() = 0;
        }
    } else if (output == -4) {
        int2 index = int2(floor(pos.x / size), floor(pos.y / size));
        if (comp == 0) {
          dst() = index.x;
        } else if (comp == 1) {
          dst() = index.y;
        } else {
          dst() = 0;
        }
    } else if (output == -3) {
        if (comp == 0) {
          dst() = rawPos.x;
        } else if (comp == 1) {
          dst() = rawPos.y;
        } else {
          dst() = 0;
        }
    } else if (output == -2) {
        if (comp == 0) {
          dst() = pos.x;
        } else if (comp == 1) {
          dst() = pos.y;
        } else {
          dst() = 0;
        }
    } else if (output == -1) {
        if (comp == 0) {
          dst() = offset.x;
        } else if (comp == 1) {
          dst() = offset.y;
        } else {
          dst() = 0;
        }
    } else if (output == 0) {
        float h = v * float(size);
        float y = dot(offset, float2(0.0, 1.0));
        dst() = fabs(y) <= h / 2.0;
    } else if (output == 1) {
        float r = v * float(size) / 2.0;
        float d = length(offset);
        dst() = d <= r;        
    } else {
      dst() = 0;
    }
  }
};
