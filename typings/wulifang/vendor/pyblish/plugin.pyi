# -*- coding=UTF-8 -*-
# This typing file was generated by typing_from_help.py
# pyright: reportUndefinedVariable=information,reportUnusedImport=false
"""
wulifang.vendor.pyblish.plugin - Plug-in system

"""

import typing

from cast_unknown.text import text

"""
Works similar to how OSs look for executables; i.e. a number of
absolute paths are searched for a given match. The predicate for
executables is whether or not an extension matches a number of
options, such as ".exe" or ".bat".

In this system, the predicate is whether or not a fname starts
with "validate" and ends with ".py"

"""
class AbstractEntity(__builtin__.list):
    """
    Superclass for Context and Instance

    Attributes:
        id (str): Unique identifier of instance
        name (str): Name of instance
        data (dict): Data shared between plug-ins
        parent (AbstractEntity): Optional parent of instance
    """

    __dict__: ...
    """
    dictionary for instance variables (if defined)
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """

    data: ...
    """
    """

    id: ...
    """
    """

    name: ...
    """
    """

    parent: ...
    """
    """

    def __init__(self, name, parent=None):
        """
        """
        ...

    ...

class Action(__builtin__.object):
    """
    User-supplied interactive action

    Subclass this class and append to Plugin.actions in order
    to provide your users with optional, context sensitive
    functionality.

    Attributes:
        label: Optional label to display in place of class name.
        active: Whether or not to allow execution of action.
        on: When to enable this action; available options are:
            - "all": Always available (default).
            - "notProcessed": The plug-in has not yet been processed
            - "processed": The plug-in has been processed
            - "succeeded": The plug-in has been processed, and succeeded
            - "failed": The plug-in has been processed, and failed
            - "warning": The plug-in has been processed, and had a warning
            - "failedOrWarning": The plug-in has been processed, and failed or
              had a warning
        icon: Name, relative path or absolute path to image for
            use as an icon of this action. For relative paths,
            the current working directory of the host is used and
            names represent icons available via Awesome Icons.
            fortawesome.github.io/Font-Awesome/icons/
    """

    __error__: ... = None
    """
    """

    __type__: ...
    """
    """

    active: ...
    """
    """

    icon: ... = None
    """
    """

    label: ... = None
    """
    """

    log: ...
    """
    """

    def __repr__(self):
        """
        """
        ...

    def __str__(self):
        """
        """
        ...

    def id(self):
        """
        alias of '6deead78-5172-4fdb-8926-4f4310643438'
        """
        ...

    def process(self):
        """
        """
        ...

    ...

Asset = Instance

class Collector(Plugin):
    """
    Parse a given working scene for available Instances
    """

    __contextEnabled__: ...
    """
    """

    __instanceEnabled__: ...
    """
    """

    __pre11__: ...
    """
    """

    log: ...
    """
    """

    order: ... = 0
    """
    """

    def id(self):
        """
        alias of '62563ee3-d3dd-4f3c-b5ce-e4e9bfdd3a77'
        """
        ...

    ...

class Context(AbstractEntity):
    """
    Maintain a collection of Instances
    """

    def __contains__(self, key):
        """
        Support both Instance objects and `id` strings
        Example:
            >>> context = Context()
            >>> instance = context.create_instance("MyInstance")
            >>> instance.id in context
            True
            >>> instance in context
            True
            >>> "NotExists" in context
            False
        """
        ...

    def __getitem__(self, item):
        """
        Enable support for dict-like getting of children by id
        Example:
            >>> context = Context()
            >>> instance = context.create_instance("MyInstance")
            >>> assert context[instance.id].name == "MyInstance"
            >>> assert context[0].name == "MyInstance"
        """
        ...

    def __init__(self, name='Context', parent=None):
        """
        """
        ...

    def create_instance(self, name, **kwargs):
        """
        Convenience method of the following.
        >>> ctx = Context()
        >>> inst = Instance("name", parent=ctx)
        Example:
            >>> ctx = Context()
            >>> inst = ctx.create_instance(name="Name")
        """
        ...

    def get(self, key, default=None):
        """
        Enable support for dict-like getting of children by id
        Example
            >>> context = Context()
            >>> instance = context.create_instance("MyInstance")
            >>> assert context.get(instance.id).name == "MyInstance"
        """
        ...

    ...

class ContextPlugin(Plugin):
    __contextEnabled__: ...
    """
    """

    __instanceEnabled__: ...
    """
    """

    __pre11__: ...
    """
    """

    log: ...
    """
    """

    def id(self):
        """
        alias of '289528d5-a2f3-424a-a251-976e47893aa0'
        """
        ...

    def process(self, context):
        """
        Primary processing method
        Arguments:
            context (Context): Context with which to process
        """
        ...

    ...

class ExplicitMetaPlugin(MetaPlugin):
    """
    Validate explicit plug-ins
    """

    def __init__(self, cls, *args, **kwargs):
        """
        """
        ...

    ...

class Extractor(Plugin):
    """
    Physically separate Instance from Host into corresponding resources
    """

    __contextEnabled__: ...
    """
    """

    __instanceEnabled__: ...
    """
    """

    __pre11__: ...
    """
    """

    log: ...
    """
    """

    order: ... = 2
    """
    """

    def id(self):
        """
        alias of '99409075-007f-4c09-81d8-61023075ca3f'
        """
        ...

    ...

class Instance(AbstractEntity):
    """
    An in-memory representation of one or more files

    Examples include rigs, models.

    Arguments:
        name (str): Name of instance, typically used during
            extraction as name of resulting files.
        parent (AbstractEntity): Optional parent. This is
            supplied automatically when creating instances with
            :class:`Context.create_instance()`.
    """

    log: ...
    """
    """

    def __eq__(self, other):
        """
        """
        ...

    def __init__(self, name, parent=None):
        """
        """
        ...

    def __ne__(self, other):
        """
        """
        ...

    def __repr__(self):
        """
        """
        ...

    def __str__(self):
        """
        """
        ...

    ...


    @property
    def context(self) -> Context:
        """Return top-level parent; the context"""
        ...

class InstancePlugin(Plugin):
    __contextEnabled__: ...
    """
    """

    __instanceEnabled__: ...
    """
    """

    __pre11__: ...
    """
    """

    log: ...
    """
    """

    def id(self):
        """
        alias of '6d65a758-32e8-43d2-898c-175a4aa245d9'
        """
        ...

    def process(self, instance: Instance) -> None:
        """
        Primary processing method
        Arguments:
            instance (Instance): Instance with which to process
        """
        ...

    ...

class Integrator(Plugin):
    """
    Integrates publishes into a pipeline
    """

    __contextEnabled__: ...
    """
    """

    __instanceEnabled__: ...
    """
    """

    __pre11__: ...
    """
    """

    log: ...
    """
    """

    order: ... = 3
    """
    """

    def id(self):
        """
        alias of '105f3b0e-28ee-4a1c-8200-904441657cd3'
        """
        ...

    ...

class MetaAction(__builtin__.type):
    """
    Inject additional metadata into Action
    """

    def __init__(self, cls, *args, **kwargs):
        """
        """
        ...

    ...

class MetaPlugin(__builtin__.type):
    """
    Rewrite plug-ins written prior to 1.1

    ..warning:: In case of plug-ins written prior to 1.1,
        that also process both instance and context,
        only the instance process will remain available.
    """

    def __init__(self, cls, *args, **kwargs):
        """
        """
        ...

    ...

class Plugin(__builtin__.object):
    """
    Base-class for plugins

    Attributes:
        hosts: Optionally limit a plug-in to one or more hosts
        families: Optionally limit a plug-in to one or more families
        label: Printed name of plug-in
        active: Whether or not to use plug-in during processing
        version: Optional version for forwards-compatibility.
            Pyblish is (currently not) using the version to allow
            for plug-ins incompatible with a particular running
            instance of Pyblish to co-exist alongside compatible
            versions.
        order: Order in which this plug-in is processed. This is
            used internally to control which plug-ins are processed
            before another so as to allow plug-ins to communicate
            with each other. E.g. one plug-in may provide critical
            information to another and so must be allowed to be
            processed first.
        optional: Whether or not plug-in can be skipped by the user.
        requires: Which version of Pyblish is required by this plug-in.
            Plug-ins requiring a version newer than the current version
            will not be loaded. 1.0.8 was when :attr:`Plugin.requires`
            was first introduced.
        actions: Actions associated to this plug-in
        id: Unique ID as str
        match: Family matching algorithm - Intersection, Subset or Exact
            Intersection -> set(a).intersection(b)
            Subset       -> set(a).issubset(b)
            Exact        -> a == b
    """

    __contextEnabled__: ...
    """
    """

    __instanceEnabled__: ...
    """
    """

    __pre11__: ...
    """
    """

    actions: ...
    """
    """

    active: ...
    """
    """

    families: ...
    """
    """

    hosts: ...
    """
    """

    label: ... = None
    """
    """

    log: ...
    """
    """

    match: ... = 1
    """
    """

    optional: ...
    """
    """

    order: ... = -1
    """
    """

    requires: ...
    """
    """

    targets: ...
    """
    """

    def __repr__(self):
        """
        """
        ...

    def __str__(self):
        """
        """
        ...

    def id(self):
        """
        alias of '379d3d17-915a-48e4-b044-57cc3866231a'
        """
        ...

    def process(self):
        """
        Primary processing method
        This method is called whenever your plug-in is invoked
        and is injected with object relative to it's signature.
        E.g. process(self, context, instance) will have the current
        context and instance injected into it at run-time.
        Available objects:
            - context
            - instance
            - user
            - time
        Raises:
            Any error
        """
        ...

    def repair(self):
        """
        DEPRECATED
        """
        ...

    ...

class Provider(__builtin__.object):
    """
    Dependency provider

    This object is given a series of "services" that it then distributes
    to a passed function based on the function's argument signature.

    For example, the function func:`myfunc(a, b)` is given the services
    called "a" and "b", given they have previously been added to the provider.
    """

    __dict__: ...
    """
    dictionary for instance variables (if defined)
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """

    @classmethod
    def ['cls', 'func'](cls, func):
        """
        """
        ...

    def __init__(self):
        """
        """
        ...

    def get(self, service):
        """
        """
        ...

    def inject(self, name, obj):
        """
        """
        ...

    def invoke(self, func):
        """
        Supply function `func` with objects to its signature
        Raises:
            KeyError if an argument asked for is not available
        Returns:
            Result of `func`
        """
        ...

    ...

class Separator(Action):
    __error__: ... = None
    """
    """

    __type__: ...
    """
    """

    def id(self):
        """
        alias of '19c8a837-cb0d-4162-857b-752b1e63addd'
        """
        ...

    ...

class Validator(Plugin):
    """
    Validate/check/test individual instance for correctness.
    """

    __contextEnabled__: ...
    """
    """

    __instanceEnabled__: ...
    """
    """

    __pre11__: ...
    """
    """

    log: ...
    """
    """

    order: ... = 1
    """
    """

    def id(self):
        """
        alias of 'df0dec87-fc6d-4ad5-873d-30a20041c1d1'
        """
        ...

    ...

class _Dict(__builtin__.dict):
    """
    Temporary object during transition from set_data to data dictionary
    """

    __dict__: ...
    """
    dictionary for instance variables (if defined)
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """

    def __call__(self, key=None, default=None):
        """
        """
        ...

    def __init__(self, parent):
        """
        """
        ...

    def __setitem__(self, k, v):
        """
        """
        ...

    ...

__metaclass__ = type

def Category(label):
    """
    """
    ...


def __explicit_process(plugin, context, instance=None, action=None):
    """
    Produce result from explicit plug-in
    This is the primary internal mechanism for producing results
    from the processing of plug-in/instance pairs.
    This mechanism replaces :func:`__implicit_process`.
    """
    ...


def __implicit_process(plugin, context, instance=None, action=None):
    """
    Produce result from implicit plug-in
    This is a fallback mechanism for backwards compatibility.
    An implicit plug-in are those subclassed from Collector,
    Validator, Extractor or Integrator.
    The mechanism which replaces this is :func:`__explicit_process`.
    """
    ...


def append_logger(plugin):
    """
    Append logger to plugin
    The logger will include a plug-in's final name, as defined
    by the subclasser. For example, if a plug-in is defined, subclassing
    :class:`Plugin`, it's given name will be present in log records.
    """
    ...


def current_host():
    """
    Return host last registered thru `register_host()`
    When running Pyblish from within a host, this function determines
    which host is running and returns the equivalent keyword.
    Example:
        >> # Running within Autodesk Maya
        >> current_host()
        "maya"
        >> # Running within Sidefx Houdini
        >> current_host()
        "houdini"
        >> # Running from an unknown software
        >> current_host()
        "unknown"
    """
    ...


def current_target():
    """
    """
    ...


def deregister_all_callbacks():
    """
    Deregisters all callback
    """
    ...


def deregister_all_discovery_filters():
    """
    Deregisters all plugin filters
    """
    ...


def deregister_all_hosts():
    """
    """
    ...


def deregister_all_paths():
    """
    Mainly used in tests
    """
    ...


def deregister_all_plugins() -> None:
    """
    De-register all plug-ins
    """
    ...


def deregister_all_services(*args, **kwargs):
    """
    De-register all existing services
    """
    ...


def deregister_all_targets():
    """
    """
    ...


def deregister_callback(signal, callback):
    """
    Deregister a callback
    Arguments:
        signal (string): Name of signal to deregister the callback with.
        callback (func): Function to execute when a signal is emitted.
    Raises:
        KeyError on missing signal
        ValueError on missing callback
    """
    ...


def deregister_discovery_filter(callback):
    """
    Deregister a plugin filter
    Arguments:
        callback (func): filtering function.
    Raises:
        ValueError on missing callback
    """
    ...


def deregister_host(host, quiet=False):
    """
    Remove an already registered host
    Arguments:
        host (str): Name of host
        quiet (bool): Whether to raise an exception
            when attempting to remove a host that is
            not already registered.
    """
    ...


def deregister_plugin(plugin):
    """
    De-register an existing plug-in
    Arguments:
        plugin (Plugin): Existing plug-in to de-register
    """
    ...


def deregister_plugin_path(path: typing.Text) -> None:
    """
    Remove a pyblish._registered_paths path
    Raises:
        ValueError if `path` isn't registered
    """
    ...


def deregister_service(*args, **kwargs):
    """
    De-register an existing service by name
    Arguments:
        name (str): Name of service
    """
    ...


def deregister_target(target, quiet=False):
    """
    Remove an already registered target
    Arguments:
        target (str): Name of target
        quiet (bool): Whether to raise an exception
            when attempting to remove a target that is
            not already registered.
    """
    ...


def discover(
    *,
    paths: typing.Optional[typing.List[typing.Text]]=None,
) -> typing.List[Plugin]:
    """
    Find and return available plug-ins
    This function looks for files within paths registered via
    :func:`register_plugin_path` and those added to `PYBLISHPLUGINPATH`.
    It determines *type* - :class:`Selector`, :class:`Validator`,
    :class:`Extractor` or :class:`Conform` - based on whether it
    matches it's corresponding regular expression; e.g.
    "$validator_*^" for plug-ins of type Validator.
    Arguments:
        type (str, optional): !DEPRECATED! Only return plugins of
            specified type. E.g. validators, extractors. In None is specified,
            return all plugins. Available options are "selectors", validators",
            "extractors", "conformers", "collectors" and "integrators".
        regex (str, optional): Limit results to those matching `regex`.
            Matching is done on classes, as opposed to
            filenames, due to a file possibly hosting
            multiple plugins.
        paths (list, optional): Paths to discover plug-ins from.
            If no paths are provided, all paths are searched.
    """
    ...


def environment_paths():
    """
    Return paths added via environment variable
    """
    ...


def evaluate_enabledness(plugin):
    """
    Deterimine whether the plug-in supports Context/Instance
    """
    ...


def evaluate_pre11(plugin):
    """
    Determine whether the plug-in is pre-1.1
    """
    ...


def host_is_compatible(plugin):
    """
    Determine whether plug-in `plugin` is compatible with the current host
    Available hosts are determined by :func:`registered_hosts`.
    Arguments:
        plugin (Plugin): Plug-in to assess.
    """
    ...


def logger(*args, **kwds):
    """
    Listen in on the global logger
    Arguments:
        handler (Handler): Custom handler with which to use
            to listen for log messages
    """
    ...


def plugin_is_valid(plugin):
    """
    Determine whether or not plug-in `plugin` is valid
    Arguments:
        plugin (Plugin): Plug-in to assess
    """
    ...


def plugin_paths():
    """
    Collect paths from all sources.
    This function looks at the three potential sources of paths
    and returns a list with all of them together.
    The sources are:
    - Registered paths using :func:`register_plugin_path`,
    - Paths from the environment variable `PYBLISHPLUGINPATH`
    Returns:
        list of paths in which plugins may be locat
    """
    ...


def plugins_from_module(module):
    """
    Return plug-ins from module
    Arguments:
        module (types.ModuleType): Imported module from which to
            parse valid Pyblish plug-ins.
    Returns:
        List of plug-ins, or empty list if none is found.
    """
    ...


def process(plugin, context, instance=None, action=None):
    """
    Produce a single result from a Plug-in
    Arguments:
        plugin(Plugin): Uninstantiated plug-in class
        context(Context): The current Context
        instance(Instance, optional): Instance to process
        action(str): Id of action to process, in place of plug-in.
    Returns:
        Dictionary of result
    """
    ...


def register_callback(signal, callback):
    """
    Register a new callback
    Arguments:
        signal (string): Name of signal to register the callback with.
        callback (func): Function to execute when a signal is emitted.
    Raises:
        ValueError if `callback` is not callable.
    """
    ...


def register_discovery_filter(callback):
    """
    Register a new plugin filter
    Arguments:
        callback (func): Function to execute on filter during discovery,
            takes the original of plugins to be edited in-place
    Raises:
        ValueError if `callback` is not callable.
    """
    ...


def register_host(host):
    """
    Register a new host
    Registered hosts are used to filter discovered
    plug-ins by host.
    Example:
        >>> register_host("My Host")
        >>> "My Host" in registered_hosts()
        True
    """
    ...


def register_plugin(plugin: Plugin) -> None:
    """
    Register a new plug-in
    Arguments:
        plugin (Plugin): Plug-in to register
    Raises:
        TypeError if `plugin` is not callable
    """
    ...


def register_plugin_path(path: typing.Text) -> typing.Text:
    """
    Plug-ins are looked up at run-time from directories registered here
    To register a new directory, run this command along with the absolute
    path to where you"re plug-ins are located.
    Example:
        >>> import os
        >>> my_plugins = os.path.join("server", "plugins")
        >>> register_plugin_path(my_plugins) == os.path.normpath(my_plugins)
        True
    Returns:
        Actual path added, including any post-processing
    """
    ...


def register_service(*args, **kwargs):
    """
    Register a new service
    Arguments:
        name (str): Name of service
        obj (any): Any object
    """
    ...


def register_target(target):
    """
    Register a new target
    Registered targets can be used in plug-ins to determin outputs
    Example:
        >>> register_target("Studio")
        >>> "Studio" in registered_targets()
        True
        >>> current_target()
        'Studio'
    """
    ...


def registered_callbacks():
    """
    Returns registered callbacks
    """
    ...


def registered_discovery_filters():
    """
    Returns registered plugin filter callbacks
    """
    ...


def registered_hosts():
    """
    Return the currently registered hosts
    """
    ...


def registered_paths():
    """
    Return paths added via registration
    ..note:: This returns a copy of the registered paths
        and can therefore not be modified directly.
    """
    ...


def registered_plugins() -> typing.Sequence[Plugin]:
    """
    Return plug-ins added via :func:`register_plugin`
    .. note:: This returns a copy of the registered plug-ins
        and can therefore not be modified directly
    """
    ...


def registered_services(*args, **kwargs):
    """
    Return the currently registered services as a dictionary
    .. note:: This returns a copy of the registered paths
        and can therefore not be modified directly.
    """
    ...


def registered_targets():
    """
    Return the currently registered targets
    """
    ...


def repair(plugin, context, instance=None):
    """
    Produce single result from repairing
    """
    ...


def sort(plugins):
    """
    Sort `plugins` in-place
    Their order is determined by their `order` attribute,
    which defaults to their standard execution order:
        1. Selection
        2. Validation
        3. Extraction
        4. Conform
    *But may be overridden.
    Arguments:
        plugins (list): Plug-ins to sort
    """
    ...


def validate_argument_signature(plugin):
    """
    Ensure plug-in processes either 'instance' or 'context'
    """
    ...


def version_is_compatible(plugin):
    """
    Lookup compatibility between plug-in and current version of Pyblish
    Arguments:
        plugin (Plugin): Plug-in to test against
    """
    ...


ALLOW_DUPLICATES: bool
"""
False
"""

ALLOW_DUPLICATE_PLUGINS: bool
"""
False
"""

CollectorOrder: int = 0

EARLY_ADOPTER: bool
"""
False
"""

Exact: int = 4

ExtractorOrder: int = 2

IntegratorOrder: int = 3

Intersection: int = 1

STRICT_DATATYPES: bool
"""
False
"""

Subset: int = 2

ValidatorOrder: int = 1

__all__: ...
"""
['ALLOW_DUPLICATES', 'ALLOW_DUPLICATE_PLUGINS', 'AbstractEnt...
"""

__version__: typing.Text
"""
'1.8.8'
"""

_registered_callbacks: dict
"""
{}
"""

_registered_hosts: list
"""
[]
"""

_registered_paths: list
"""
[]
"""

_registered_plugin_filters: list
"""
[]
"""

_registered_plugins: dict
"""
{}
"""

_registered_services: dict
"""
{}
"""

_registered_targets: list
"""
[]
"""

log: ...
"""
<logging.Logger object>
"""

version_info: (1, 8, 8) = (1, 8, 8)

# version: None
