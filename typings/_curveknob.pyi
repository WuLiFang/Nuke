# -*- coding=UTF-8 -*-
# This typing file was generated by typing_from_help.py
"""
_curveknob - The Python API for the CurveKnob
"""

import six
import _curvelib
import _curveknob
from typing import Iterator, TypeVar
import nuke
from wulifang._compat.str import Str

T = TypeVar("T")

class CurveKnob(nuke.Knob):
    """
    The knob which holds the tree of paint elements (Layers, Shapes and Strokes).

    Most operations are performed on the tree itself, or its elements, rather than through the knob. You can get the root of the tree through the knob's rootLayer property, or you can get straight to a specific element using the toElement() method.

    A common usage scenario is as follows:

    >>> knob = nuke.toNode('RotoPaint1')['curves']
    >>> root = knob.rootLayer
    >>> # perform operations on the root layer.

    Creating any new shapes, strokes or layers will require you to pass in a reference to the knob, so it's worth storing the reference in a variable.
    """

    curveWidget: _curveknob.CurveWidget
    """
    Curve Widget
    """

    rootLayer: _curveknob.Layer
    """
    The root layer.
    """
    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...
    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...
    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...
    def changed(self) -> None:
        """
        Call this after performing updates on the tree, to tell it that it's been updated. For many operations this is called automatically, but you can call it manually for those cases where it isn't.
        """
        ...
    def getSelected(self) -> ...:
        """
        Returns list of all selected items in a curve knob
        As an example, say you have a Bezier curve selected,the following will return 'Bezier1'
        >>> curveKnob = nuke.toNode('RotoPaint1)['curves']
        >>> selected = curveKnob.getSelected()
        >>> selected[0].name
        """
        ...
    def toElement(self, path) -> Element:
        """
        Takes a path which identifies a particular element in the curve tree and returns the corresponding Layer, Stroke or Shape object.
        The path is a slash separated string and is always resolved relative to the root layer. So if, for example, you have a RotoPaint node with a layer called 'Layer1' which contains a shape called 'Shape1', the path to the shape would be 'Layer1/Shape1'.
        >>> knob = nuke.toNode('RotoPaint1)['curves']
        >>> shape = knob.toElement('Layer1/Shape1')
        >>> shape.name
        'Shape1'
        """
        ...
    ...

class CurveWidget(Element):
    """
    The Curve Widget displayed in the Roto panel.
    This should only be used for test harness functionality.

    IMPORTANT:
       1) may be `None` as it is not guaranteed that the widget is accessible
       2) the lifetime of the underlying object is undefined, DO NOT STORE!
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...
    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...
    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...
    def add(self) -> None:
        """
        Add a new group layer under the selected item's parent
        """
        ...
    def getSelectedItems(self) -> ...:
        """
        List of strings of selected item namesGets a list of the selected items in the CurveTreeWidget
        """
        ...
    def remove(self) -> None:
        """
        Remove the selected items in the CurveTreeList
        """
        ...
    ...

class Element:
    """
    The base class for the different types of elements you can create in the RotoPaint node.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...
    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...
    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...
    def clone(self: T) -> T:
        """
        elementCreate clone of element
        """
        ...
    def getVisible(self, time) -> bool:
        """
        Get the value of the visible attribute at a particular time.
        """
        ...
    def serialise(self) -> six.binary_type:
        """
        Returns a string representation of the given element.
        """
        ...
    def setVisible(self, time, value) -> None:
        """
        Set the value of the visible attribute at a particular time. value must be a bool.
        """
        ...
    ...

class Layer(Element):
    """
    A layer, used to group other elements in the paint tree.

    Layers can contain shapes, strokes and other layers. They can be transformed, which has the effect of transforming all contained objects by the same amount (in addition to any individual transforms on the contained objects).

    Layers are represented as a sequence of Element objects. You can find out how many items the layer contains using the len() function, as for any python sequence. Likewise you can access the contained elements using python's array-style syntax (e.g. layer[0] will return the first element inside the layer, layer[-1] will return the last element, etc.).
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...
    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...
    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...
    def __iter__(self) -> Iterator[Element]: ...
    def append(self, element) -> None:
        """
        Add a new element inside this layer. The element must be an instance of either the Shape, Stroke or Layer classes. Note that an element cannot be in more than one place in the tree, so if you try to add an element that is already in the tree somewhere else, it'll be removed from its old location first.
        """
        ...
    def getAttributes(self) -> _curvelib.AnimAttributes:
        """
        Gets the collection of attributes for this stroke.
        """
        ...
    def getFlag(self, flag) -> bool:
        """
        Check whether a particular flag is set or not. The flag parameter should be one of the constants from the FlagType class. The return value will be True if the flag is set, False if it isn't.
        """
        ...
    def getTransform(self) -> _curvelib.AnimCTransform:
        """
        Gets the transform for this shape.
        """
        ...
    def insert(self, index, element) -> None:
        """
        Insert a new element inside this layer at the given index. The element must be an instance of either the Shape, Stroke or Layer classes. Note that an element cannot be in more than one place in the tree, so if you try to add an element that is already in the tree somewhere else, it'll be removed from its old location first.
        """
        ...
    def remove(self, index: int) -> None:
        """
        Remove the element at the given index from this layer. If the index is out of bounds, an IndexError will be raised.
        """
        ...
    def removeAll(self) -> None:
        """
        Remove all elements from this layer.
        """
        ...
    def setFlag(self, flag, value) -> None:
        """
        Set a particular flag. The flag parameter specifies which flag to set and should be one of the constants from the FlagType class. The value parameter is a boolean value; True will set the flag, False will clear it.
        """
        ...
    def setTransform(self, transform) -> None:
        """
        Replace the existing transform for this shape with a new one. The transform parameter must be an instance of the AnimTransform class.
        """
        ...
    ...

class Shape(Element):
    """
    A Roto or SplineWarp shape, which may be animated.

    Shapes are represented as a sequence of ShapeControlPoint objects, which group together a 'center' control point along with tangent locations and feather offsets. Python's built-in len() function can be used to get the number of shape control points; and array-style access can be used to get individual shape control points (e.g. shape[0] returns the first shape control point, shape[-1] returns the last shape control point, etc.).
    You can create a new shape as follows:

    >>>import _curveknob
    >>>rotoNode = nuke.toNode('RotoPaint1')
    >>>curveKnob = rotoNode['curves']
    >>>emptyShape = _curveknob.Shape( curveKnob )
    >>>twoPointShape = _curveknob.Shape( curveKnob, *((0,0), (10,10)) )
    >>> # perform operations on the shape(s).

    NOTE: this object was designed to work for Roto shapes, which have feather
          curves. Please report any problems with this type to
          support@thefoundry.co.uk
    """

    locked: bool
    "Whether this element is locked."

    name: Str
    "The name for this element"
    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...
    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...
    def __iter__(self) -> Iterator[ShapeControlPoint]: ...
    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...
    def append(self, shapeControlPoint) -> None:
        """
        Add a new control point to the shape. The shapeControlPoint parameter must be either an instance of the ShapeControlPoint class, or something we can convert to a ShapeControlPoint. This includes a sequence of 2, 3 or 4 floats; a CVec2, CVec3 or CVec4 object; or an AnimControlPoint object.
        """
        ...
    def evaluate(self, curveNum, time, viewName="default") -> _curvelib.CubicCurve:
        """
        Bake out a curve for the outline of this shape at the specified time.

        Note that the feather curve is represented as an offset from the main curve. If you want to get the screen position of a point along the feather curve, you'll need to add it to the corresponding position on the main curve. For example:
          >>> frameNum = 10.0
          >>> t = 0.5
          >>> rotoknob = nuke.toNode('RotoPaint1')['curves']
          >>> shape = rotoknob.toElement('Bezier1')
          >>> mainCurve = shape.evaluate(0, frameNum)
          >>> featherCurve = shape.evaluate(1, frameNum)
          >>> pointOnMainCurve = mainCurve.getPoint(t)
          >>> featherOffset = featherCurve.getPoint(t)
          >>> pointOnFeatherCurve = pointOnMainCurve + featherOffset

        @param curveNum: 0 for the main curve, 1 for the feather curve.
        @param time: The (floating point) frame number to bake the curve from.
        @param viewName: Optional parameter specifying which view to bake the curve from. If omitted, the default view will be used.
        """
        ...
    def getAttributes(self) -> _curvelib.AnimAttributes:
        """
        Gets the collection of attributes for this shape.
        """
        ...
    def getFlag(self, flag) -> bool:
        """
        Check whether a particular flag is set or not. The flag parameter should be one of the constants from the FlagType class. The return value will be True if the flag is set, False if it isn't.
        """
        ...
    def getTransform(self) -> _curvelib.AnimCTransform:
        """
        Gets the transform for this shape.
        """
        ...
    def insert(self, index, shapeControlPoint) -> None:
        """
        Insert a new control point in the shape before the given index. The shapeControlPoint parameter must be either an instance of the ShapeControlPoint class, or something we can convert to a ShapeControlPoint. This includes a sequence of 2, 3 or 4 floats; a CVec2, CVec3 or CVec4 object; or an AnimControlPoint object.
        """
        ...
    def remove(self, index) -> None:
        """
        Remove the control point at the given index. This removes any associated tangent and feather point data as well. If the index is out of bounds, an IndexError will be raised.
        """
        ...
    def setFlag(self, flag, value) -> None:
        """
        Set a particular flag. The flag parameter specifies which flag to set and should be one of the constants from the FlagType class. The value parameter is a boolean value; True will set the flag, False will clear it.
        """
        ...
    ...

class ShapeControlPoint:
    """
    A control point in a roto shape.

    The control point groups together a 'center' location, along with tangents and feather offsets.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...
    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...
    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...
    center: _curvelib.AnimControlPoint
    "The center of the control point"
    featherCenter: _curvelib.AnimControlPoint
    "The feather point offsets, relative to the center point"
    featherLeftTangent: _curvelib.AnimControlPoint
    "The left feather tangent offsets, relative to the feather center point."
    featherRightTangent: _curvelib.AnimControlPoint
    "The right feather tangent offsets, relative to the feather center point."
    leftTangent: _curvelib.AnimControlPoint
    "The left tangent offsets, relative to the center point."
    rightTangent: _curvelib.AnimControlPoint
    "The right tangent offsets, relative to the center point."

class Stroke(Element):
    """
    A paint stroke, which may be animated.

    A paint stroke is represented as a sequence of AnimControlPoint objects. You can find out how many control points there are in the stroke using python's built-in len() function; and you can access individual control points using the array-style syntax (e.g. stroke[0] returns the first control point, stroke[-1] returns the last control point, etc.).
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...
    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...
    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...
    def __iter__(self) -> Iterator[_curvelib.AnimControlPoint]: ...
    def append(self, controlPoint) -> None:
        """
        Add a new control point to the stroke. The controlPoint parameter must be either an instance of the AnimControlPoint class, or something we can convert to an AnimControlPoint. This includes a sequence of 2, 3 or 4 floats; or a CVec2, CVec3 or CVec4 object.
        """
        ...
    def evaluate(self, time, viewName="default") -> _curvelib.CubicCurve:
        """
        Bake out a curve for the path of this stroke at the specified time.
        @param time: The (floating point) frame number to bake the curve from.
        @param viewName: Optional parameter specifying which view to bake the curve from. If omitted, the default view will be used.
        """
        ...
    def getAttributes(self) -> _curvelib.AnimAttributes:
        """
        Gets the collection of attributes for this stroke.
        """
        ...
    def getFlag(self, flag) -> bool:
        """
        Check whether a particular flag is set or not. The flag parameter should be one of the constants from the FlagType class. The return value will be True if the flag is set, False if it isn't.
        """
        ...
    def getTransform(self) -> _curvelib.AnimCTransform:
        """
        Gets the transform for this shape.
        """
        ...
    def insert(self, index, controlPoint) -> None:
        """
        Insert a new control point in the stroke before the given index. The controlPoint parameter must be either an instance of the AnimControlPoint class, or something we can convert to an AnimControlPoint. This includes a sequence of 2, 3 or 4 floats; or a CVec2, CVec3 or CVec4 object.
        """
        ...
    def remove(self, index) -> None:
        """
        Remove the control point at the given index. If the index is out of bounds, an IndexError will be raised.
        """
        ...
    def setFlag(self, flag, value) -> None:
        """
        Set a particular flag. The flag parameter specifies which flag to set and should be one of the constants from the FlagType class. The value parameter is a boolean value; True will set the flag, False will clear it.
        """
        ...
    ...
