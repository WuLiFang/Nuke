# -*- coding=UTF-8 -*-
# This typing file was generated by typing_from_help.py
# pyright: reportUndefinedVariable=information,reportUnusedImport=false
"""
hiero.core - # Copyright (c) 2011 The Foundry Visionmongers Ltd.  All Rights Reserved.

"""

import typing

class Annotation(SubTrackItem):
    """
    Class for objects that can hold multiple stroke and/or text elements to provide annotation functionality.
    Annotation is derived from SubTrackItem and thus Annotation objects can be placed and trimmed on VideoTrack
    subtracks. Strokes and/or text can be added to an annotation by creating AnnotationStroke and/or AnnotationText
    objects and using addElement().
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def addElement(self):
        """
        Adds the specified AnnotationElement, which should be an instance of an AnnotationElement sub-class, i.e. either
        an AnnotationStroke or an AnnotationText object.

        Returns:
            If there was no error, returns the added element.
        """
        ...
    def addToNukeScript(self, script, offset=0, inputs=0, cliptype=None):
        """
        alias of _Annotation_addToNukeScript
        """
        ...
    def elements(self):
        """

        Returns:
            a tuple with all of the elements contained in this annotation.
            tuple of hiero.core.Element sub-class objects
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    ...

class AnnotationElement(Shiboken.Object):
    """
    Base class for types of elements that may be added to an Annotation.
    This class shold not be used directly and AnnotationElement objects should not be created.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def color(self) -> typing.Tuple[typing.Tuple[red, green, blue, alpha]]:
        """
        with the components represented as floating point values in the range [0, 1].

        Returns:
            a tuple containing the color for this annotation element in the form (red, green, blue, alpha),
        """
        ...
    def isNull(self, *args, **kwargs):
        """ """
        ...
    def setColor(self, red, green, blue, alpha) -> None:
        """
        Sets the color and alpha of the element.
        Each component must be a floating point value in the range [0, 1].

        Args:
            red: The new red component.
            green: The new green component.
            blue: The new blue component.
            alpha: The new alpha component.
        """
        ...
    def toString(self) -> typing.Text:
        """
        Returns a description of the object. Equivalent to str(object).

        Returns:
            A string describing the object.
        """
        ...
    ...

class AnnotationStroke(AnnotationElement):
    """
    A class, derived from AnnotationElement, storing a set of 2d points to represent a single stroke
    within an annotation.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def isNull(self, *args, **kwargs):
        """ """
        ...
    def lineWidth(self, *args, **kwargs):
        """ """
        ...
    def points(self, *args, **kwargs):
        """
        self.points -> Returns a variable tuple containing the 2d points forming the stroke. Each point is
        represented as a 2 component tuple, with the x and y components of the point as floating point values.

        Returns:
            tuple of 2 component tuples, each of the form (x, y)
        """
        ...
    def setLineWidth(self, *args, **kwargs):
        """ """
        ...
    def setPoints(self, *args, **kwargs):
        """
        self.setPoints -> Sets the points that make up this stroke, replacing any points the stroke already had.
        The points must be specified as a list (not tuple) of 2d points, each point being a 2 component tuple of
        floats or integers, e.g. [(100, 200), (123.456, 300)].
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    ...

class AnnotationText(AnnotationElement):
    """
    A class, derived from AnnotationElement, storing a single item of text within an annotation.
    """

    HorizontalJustification: ...
    """
    """

    VerticalJustification: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    eHCenter: ...
    """
    """

    eHJustify: ...
    """
    """

    eHLeft: ...
    """
    """

    eHRight: ...
    """
    """

    eVBaseline: ...
    """
    """

    eVBottom: ...
    """
    """

    eVCenter: ...
    """
    """

    eVTop: ... = core.Hiero.Python.AnnotationText.VerticalJustification.eVTop
    """
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def box(self, *args, **kwargs):
        """
        self.box -> Returns a tuple containing the position and size of the text box, as floating point values.
        The position is that of the box's lower left corner.

        Returns:
            The text box position and size in the form (x, y, width, height)
        """
        ...
    def fontPath(self) -> typing.Text:
        """
        Returns the current font path for this annotation text object.

        Returns:
            A string containing the current font path.
        """
        ...
    def fontSize(self, *args, **kwargs):
        """ """
        ...
    def horizontalJustification(self, *args, **kwargs):
        """
        self.horizontalJustification
        Returns the horizontal justification of the text.

        Returns:
            One of eHLeft, eHCenter, eHRight, eHJustify.
        """
        ...
    def isNull(self, *args, **kwargs):
        """ """
        ...
    def rotation(self, *args, **kwargs):
        """
        self.rotation -> float
        Returns the rotation angle of the text, as a floating point value in degrees.

        Returns:
            The text's rotation angle.
        """
        ...
    def setBox(self, x, y, width, height) -> None:
        """
        Sets the text box for this annotation text object.
        The text box determines the position and layout of the text (the layout also being affected
        by the alignment). The size of the text box does not affect the size of the glyphs that make up
        the text, that's determined by the font size - see setFontSize() and fontSize().

        Args:
            x: The new x-component of the bottom left corner of the text box, before any rotation.
            y: The new y-component of the bottom left corner of the text box, before any rotation.
            width: The new width of the text box.
            height: The new height of the text box.
        """
        ...
    def setFontPath(self) -> None:
        """
        Sets the path to the file from which to load the font for use with this annotation text object.
        """
        ...
    def setFontSize(self, *args, **kwargs):
        """ """
        ...
    def setHorizontalJustification(self, *args, **kwargs):
        """
        self.setHorizontalJustification -> None
        Set the horizontal justification of the text.

        Args:
            justify: One of eHLeft, eHCenter, eHRight, eHJustify.
        """
        ...
    def setRotation(self, *args, **kwargs):
        """
        self.setRotation -> None
        Sets the rotation angle of the text, with a floating point value, replacing the previous angle.

        Args:
            rotation: The new rotation angle, in degrees.
        """
        ...
    def setText(self, text) -> None:
        """
        Sets the text for this annotation text object.

        Args:
            text: The new text string.
        """
        ...
    def setVerticalJustification(self, *args, **kwargs):
        """
        self.setVerticalJustification -> None
        Set the vertical justificaiton of the text.

        Args:
            justify: One of eVBaseline, eVTop, eVCenter, eVBottom.
        """
        ...
    def text(self) -> typing.Text:
        """

        Returns:
            A string containing the current text for this annotation text object.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def verticalJustification(self, *args, **kwargs):
        """
        self.verticalJustification
        Returns the vertical justification of the text.

        Returns:
            One of eVBaseline, eVTop, eVCenter, eVBottom.
        """
        ...
    ...

class ApplicationSettings(Shiboken.Object):
    """
    Helper object to set and get application settings.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def boolValue(self, key, defaultValue) -> typing.Text:
        """
        Note: use self.value(key, defaultValue) if you just want to retrieve a string setting

        Args:
            key: string name of the value to retrieve
            defaultValue: the value to return if this setting hasn't been saved before. Does not save the value to the default.

        Returns:
            the previously stored value as True or False, named by the key parameter, or the defaultValue parameter

        Overloads:
            self.boolValue(key) ->  returns the previously stored value as True or False, named by the key parameter, or the default value as configured (if configured) by the Hiero code. Use this method if you're looking up a value used by Hiero internally.
        """
        ...
    def setBoolValue(self, key, value):
        """
        saves the value as True or False with the application's settings using the key

        Args:
            key: string name of the value to retrieve
            value: the bool (True or False) value to save.
        """
        ...
    def setValue(self, key, value):
        """
        alias of setValueOverride
        saves the value with the application's settings using the key

        Args:
            key: string name of the value to save
            value: the value to store
        """
        ...
    def value(self, key, defaultValue=None):
        """
        alias of getValueOverride

        Args:
            key: string name of the value to retrieve
            defaultValue: the value to return if this setting hasn't been saved before. Does not save the value to the default

        Returns:
            the previously stored string value named by the key parameter, or the defaultValue parameter
            string, unless the defaultValue is set, in which case, the return value will be the same type as the defaultValue (string, int or bool)
        """
        ...
    ...

class AudioTrack(TrackBase):
    """
    Object for manipulating audio tracks.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def addTag(self, tag) -> Tag:
        """
        adds a tag to the audio track item.

        Args:
            tag: the hiero.core.Tag to add to the audio track
        """
        ...
    @typing.overload
    def addTrackItem(self, clip: TrackItem) -> TrackItem:
        ...
    @typing.overload
    def addTrackItem(self, clip: Clip, audioChannel: int, position: int) -> TrackItem:
        """
        if the first parameter is a Clip object, the second and third parameters must be specified and this method creates a new track item with the specified audio channel and adds it to this audio track at the given position.
        If the first parameter is a TrackItem, then this method just adds the track item specified.
        This method will cut or delete track items that overlap with the one being added.
        This method can only be called if the track has already been added to a Sequence.

        Args:
            clip: a hiero.core.Clip object or a hiero.core.TrackItem object, to add to this audio track.
            audioChannel: int; audio channel that will be associated with the track item. Do not specify if clip is a TrackItem.
            position: int; insert position. Do not specify if clip is a TrackItem.
        """
        ...
    def clone(self) -> AudioTrack:
        """
        WARNING - DEPRECATED ( clone ): This method is deprecated and will not be present in future versions of the Python API.
        This method has been replaced by copy().

        Returns:
            a deep copy of this object.
        """
        ...
    def copy(self) -> AudioTrack:
        """

        Returns:
            a deep copy of this object.
        """
        ...
    def createTrackItem(self, name) -> TrackItem:
        """
        creates a new track item.

        Args:
            name: the name of the new track item
        """
        ...
    def items(self) -> typing.Tuple[TrackItem, ...]:
        """

        Returns:
            a tuple with all of the track items contained by this track.
        """
        ...
    def parent(self) -> Sequence:
        """

        Returns:
            the sequence that contains this track.
        """
        ...
    def removeTag(self, tag):
        """
        removes the tag from the audio track.

        Args:
            tag: Tag
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def trackIndex(self, *args, **kwargs):
        """ """
        ...
    ...

class BackgroundRenderObserver(Shiboken.Object):
    """
    Observer of background renders.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def isNull(self, *args, **kwargs):
        """ """
        ...
    def onFrameRenderCancelled(self, *args, **kwargs):
        """ """
        ...
    def onFrameRenderError(self, *args, **kwargs):
        """ """
        ...
    def onFrameRenderInProgress(self, *args, **kwargs):
        """ """
        ...
    def onFrameRenderQueued(self, *args, **kwargs):
        """ """
        ...
    def onFrameRendered(self, *args, **kwargs):
        """ """
        ...
    ...

class Bin(Shiboken.Object):
    """
    Container object for hiero.core.BinItem objects (wrapping hiero.core.Clip and hiero.core.Sequence objects) and other hiero.core.Bin objects.
    """

    ItemType: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kBin: ... = core.Hiero.Python.Bin.ItemType.kBin
    """
    """

    kClip: ... = core.Hiero.Python.Bin.ItemType.kClip
    """
    """

    kEffect: ... = core.Hiero.Python.Bin.ItemType.kEffect
    """
    """

    kNone: ... = core.Hiero.Python.Bin.ItemType.kNone
    """
    """

    kSequence: ... = core.Hiero.Python.Bin.ItemType.kSequence
    """
    """

    kTag: ... = core.Hiero.Python.Bin.ItemType.kTag
    """
    """
    def __contains__(self, *args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def addItem(self, object) -> Added:
        """
        adds the item to the bin object.

        Args:
            object: Bin, hiero.core.BinItem, or hiero.core.Tag object, to be added as a sub item of the bin
        """
        ...
    def bins(self) -> typing.Tuple[Bin, ...]:
        """

        Returns:
            a tuple with all of the sub bins contained by this object.
        """
        ...
    def clips(self) -> typing.Tuple[BinItem, ...]:
        """

        Returns:
            a tuple with all of the BinItem's containing clips contained by this bin.
        """
        ...
    def importFolder(self, path):
        """
        imports the media in the path into this bin (needs a project).

        Args:
            path: path to the media to import

        Returns:
            Bin: returns the bin created for imported media
        """
        ...
    def importSequence(self, filename, timeBase=None, frameRate=None, dropFrame=False):
        """
        imports the sequence stored in filename into this bin (needs a project).  If the timebase/frame rate for the sequence isnot specified, the project defaults will be used.

        Args:
            filename: path to the file to import the sequence from
            timeBase: optional argument of type hiero.core.TimeBase specifying the timebase for the created sequence
            frameRate: optional float argument specifying the frame rate for the created sequence

        Returns:
            hiero.core.Sequence the created sequence
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            True if the object is invalid.
        """
        ...
    def items(self, typeFilter) -> typing.Tuple[BinItem, ...]:
        """

        Args:
            typeFilter: combination of hiero.core.Bin.ItemType flags

        Returns:
            a tuple with all of the objects contained by this bin, filtered by the typeFilter argument, if supplied.
        """
        ...
    def name(self) -> bool:
        """

        Returns:
            the name of the bin.
        """
        ...
    def numChildren(self) -> int:
        """

        Returns:
            the number of child objects contained by this bin.
        """
        ...
    def parentBin(self) -> Bin:
        """

        Returns:
            the bin that contains this object.
        """
        ...
    def project(self) -> Project:
        """

        Returns:
            the Project object that this is attached to, or None if the object is not attached to a project.
        """
        ...
    def reconnectMedia(self, path):
        """
        For any Clips or Sequences in the bin, reconnects media found in the specified path.

        Args:
            path: path containing media to reconnect to
        """
        ...
    def removeItem(self, object):
        """
        removes the item from the bin object. If the object is not a child item of the bin object, throws an exception.

        Args:
            object: Bin, hiero.core.BinItem, or hiero.core.Tag object to be removed as a sub item of the bin
        """
        ...
    def sequences(self) -> typing.Tuple[BinItem, ...]:
        """

        Returns:
            a tuple with all of the BinItem's containing sequences contained by this bin.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    ...

class BinItem(Shiboken.Object):
    """
    Generic object wrapper with shared functionality for sequences and clips.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def activeItem(self) -> Clip or hiero.core.Sequence:
        """

        Returns:
            the item contained by this bin item.
        """
        ...
    def activeVersion(self) -> Version:
        """
        gets the currently active Version object of the bin item.
        """
        ...
    def addSnapshot(self, comment) -> Snapshot:
        """
        adds a new snapshot for the object, with a comment.

        Args:
            comment: a comment string to set on the snapshot
            sequence: a hiero.core.Sequence object to create the Snapshot from

        Overloads:
            self.addSnapshot(sequence, comment) -> adds a new snapshot for the object, using the sequence as the new snapshot, setting the comment.
        """
        ...
    def addVersion(self, version) -> Version:
        """
        adds the version parameter to the bin item.

        Args:
            version: Version object for the new version
            position: position at which the new Version must be inserted, if -1 then insert at end
        """
        ...
    def clone(self) -> BinItem:
        """
        WARNING - DEPRECATED ( clone ): This method is deprecated and will not be present in future versions of the Python API.
        This method has been replaced by copy().

        Returns:
            a deep copy of this object.
        """
        ...
    def copy(self) -> BinItem:
        """

        Returns:
            a deep copy of this object.
        """
        ...
    def hasVersion(self, index) -> bool:
        """
        checks if a given version exists and is valid.
        WARNING - DEPRECATED ( hasVersion ): This method is deprecated and will not be present in future versions of the Python API.
        Version indices are no longer unique identifiers and should not be used as such. Please use BinItem.hasVersionClip() instead, or check membership to BinItem.items().

        Args:
            index: index of the version to check for
        """
        ...
    def isClipVersion(self, index) -> bool:
        """
        checks if a given clip belongs to this BinItem as a version.

        Args:
            clip: Clip to look for
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            True if the object contains a invalid hiero.core.Sequence or hiero.core.Clip object.
        """
        ...
    def items(self) -> typing.Tuple[Version, ...]:
        """

        Returns:
            a tuple containing all of the different versions of this object.
        """
        ...
    def maxVersion(self) -> Version:
        """
        finds the maximum (last) version and sets it as the active version on this bin item. Offline versions and hidden versions will be ignored during the search.
        """
        ...
    def minVersion(self) -> Version:
        """
        finds the minimum (first) version and sets it as the active version on this bin item. Offline versions and hidden versions will be ignored during the search.
        """
        ...
    def name(self) -> typing.Text:
        """

        Returns:
            the name of the item.
        """
        ...
    def nextVersion(self) -> Version:
        """
        finds the next version and sets it as the active version on this bin item. Offline versions and hidden versions will be ignored during the search.
        """
        ...
    def numSnapshots(self) -> int:
        """

        Returns:
            the number of snapshots that this bin item has.
        """
        ...
    def numVersions(self) -> int:
        """

        Returns:
            the number of versions for this bin item.
        """
        ...
    def parentBin(self) -> Bin:
        """

        Returns:
            the bin object that contains this bin item.
        """
        ...
    def prevVersion(self) -> Version:
        """
        finds the previous version and sets it as the active version on this bin item. Offline versions and hidden versions will be ignored during the search.
        """
        ...
    def project(self) -> heiro.core.Project:
        """

        Returns:
            the Project object that this object is attached to, or None if the object is not attached to a project.
        """
        ...
    def restoreToSnapshot(self, index):
        """
        adds a new snapshot for the object, with a comment.

        Args:
            index: index of the Snapshot to restore from. Generates an exception if the index is out of range
        """
        ...
    def setActiveVersion(self, version) -> Version:
        """
        sets the active version to the version parameter.
        """
        ...
    def setActiveVersionIndex(self, version) -> Version:
        """
        sets the currently active version by index.
        WARNING - DEPRECATED ( setActiveVersionIndex ): This method is deprecated and will not be present in future versions of the Python API.
        Version indices are no longer unique identifiers and should not be used as such. Please use BinItem.setActiveVersion() instead.

        Args:
            index: index of the version to make active
        """
        ...
    def snapshots(self) -> typing.Tuple[Snapshot, ...]:
        """

        Returns:
            a tuple of all of the snapshots contained by this object.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def version(self, index) -> Version:
        """
        gets a Version object for the version of the bin item specified by the index.
        WARNING - DEPRECATED ( version ): This method is deprecated and will not be present in future versions of the Python API.
        Version indices are no longer unique identifiers and should not be used as such. Please use BinItem.items() instead.

        Args:
            index: index of the version to get
        """
        ...
    def versionDown(self) -> Version:
        """
        decrements the current/active version and returns the newly active Version object of the bin item.
        WARNING - DEPRECATED ( versionDown ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from BinItem. To find new versions, please use hiero.core.VersionScanner. To obtain the next version, please use BinItem.prevVersion().
        """
        ...
    def versionMaxAvailable(self) -> Version:
        """
        finds the highest version that is currently loaded and does not have missing or offline media and sets it as the active version on this bin item.
        WARNING - DEPRECATED ( versionMaxAvailable ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from BinItem. This method has been replaced by BinItem.maxVersion().
        """
        ...
    def versionMinAvailable(self) -> Version:
        """
        finds the lowest version that is currently loaded and does not have missing or offline media and sets it as the active version on this bin item.
        WARNING - DEPRECATED ( versionMinAvailable ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from BinItem. This method has been replaced by BinItem.minVersion().
        """
        ...
    def versionNextAvailable(self) -> Version:
        """
        finds the next (higher) version that is currently loaded and does not have missing or offline media and sets it as the active version on this bin item.
        WARNING - DEPRECATED ( versionNextAvailable ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from BinItem. This method has been replaced by BinItem.nextVersion().
        """
        ...
    def versionPrevAvailable(self) -> Version:
        """
        finds the prev (lower) version that is currently loaded and does not have missing or offline media and sets it as the active version on this bin item.
        WARNING - DEPRECATED ( versionPrevAvailable ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from BinItem. This method has been replaced by BinItem.prevVersion().
        """
        ...
    def versionUp(self) -> Version:
        """
        increments the current/active version and returns the newly active Version object of the bin item.
        WARNING - DEPRECATED ( versionUp ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from BinItem. To find new versions, please use hiero.core.VersionScanner. To obtain the next version, please use BinItem.nextVersion().
        """
        ...
    ...

class Clip(SequenceBase):
    """
    Object representing a clip.

    Initialisation:
      Clip(mediaSource)
      Clip(mediaSource, first, last)
    mediaSource may be a MediaSource object or a string containing the media path.  If first and last are given, the Clip only plays frames within this range.
    """

    LocalisationPolicy: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kAlwaysLocalise: ...
    """
    """

    kAutoLocalise: ...
    """
    """

    kNeverLocalise: ...
    """
    """

    kOffLocalise: ... = core.Hiero.Python.Clip.LocalisationPolicy.kOffLocalise
    """
    """

    kOnLocalise: ... = core.Hiero.Python.Clip.LocalisationPolicy.kOnLocalise
    """
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def addAnnotationsToNukeScript(
        self, script, firstFrame, trimmed, trimStart=None, trimEnd=None
    ):
        """
        alias of _Clip_addAnnotationsToNukeScript
        Add the annotations inside a clip to a Nuke script.  This is separated from Clip.addToNukeScript()
        so it's easier to control where in the script the annotations are placed.  The parameters are used to determine
        the frame range for the annotations.
        """
        ...
    def addTag(self, tag) -> Tag:
        """
        adds the tag to the set of tags attached to the Clip.

        Args:
            tag: the tag object to add
        """
        ...
    def addTagToRange(self, tag, inTime, outTime) -> Tag:
        """
        adds the tag to the specified range of the Clip.

        Args:
            tag: the tag object to add
            inTime: from - time to add tag
            outTime: to - time to add tag
        """
        ...
    def addToNukeScript(self, script, trimmed=True, trimStart=None, trimEnd=None):
        """
        alias of _Clip_addToNukeScript
        Add a Read node to the Nuke script for each media sequence/file used in this clip. If there is no media, nothing is added.

        Args:
            script: Nuke script object to add nodes
            additionalNodes: typing.List[nodes to be added post read]
            additionalNodesCallback: callback to allow custom additional node per item function([Clip|TrackItem|Track|Sequence])
            firstFrame: Custom offset to move start frame of clip
            trimmed: If True, a TimeClip node will be added to trim the range output by the Read node. The range defaults to the clip's soft trim range. If soft trims are not enabled on the clip, the range defaults to the clip range. The range can be overridden by passing trimStart and/or trimEnd values.
            trimStart: Override the trim range start with this value.
            trimEnd: Override the trim range end with this value.
            colourTransform: if specified, is set as the color transform for the clip
            metadataNode: node containing metadata to be inserted into the script
            includeMetadataNode: specifies whether a metadata node should be added to the script
            nodeLabel: optional label for the Read node
            enabled: enabled status of the read node. True by default
            includeEffects: if True, soft effects in the clip are included
            beforeBehaviour: What to do for frames before the first ([hold|loop|bounce|black])
            afterBehaviour: What to do for frames after the last ([hold|loop|bounce|black])
        """
        ...
    def clone(self) -> Clip:
        """
        WARNING - DEPRECATED ( clone ): This method is deprecated and will not be present in future versions of the Python API.
        This method has been replaced by copy().

        Returns:
            a deep copy of this object.
        """
        ...
    def copy(self) -> Clip:
        """

        Returns:
            a deep copy of this object.
        """
        ...
    def entityReference(self) -> typing.Text:
        """

        Returns:
            this clip's asset management system entity reference.
        """
        ...
    def getAvailableOcioColourTransforms(self) -> typing.Text:
        """

        Returns:
            colour transform for the source media.
        """
        ...
    def getReadInfo(self, firstFrame=None):
        """
        alias of _Clip_getReadInfo
        Get information (filename and start at value) for any Read Node in this clip.

        Args:
            firstFrame: Custom offset to move start frame of clip
        """
        ...
    def guid(self, *args, **kwargs):
        """ """
        ...
    def hasMultipleViews(self) -> bool:
        """

        Returns:
            true if the Clip has multiple views available for display given the current settings of the project it belongs to.
        """
        ...
    def isLocalised(self) -> bool:
        """

        Returns:
            whether the clip is completely localised.
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            False if this is a valid Clip object, True otherwise.
        """
        ...
    def localisationPolicy(self) -> LocalisationPolicy:
        """

        Returns:
            the localisation policy of the clip.
        """
        ...
    def localisationProgress(self) -> double:
        """

        Returns:
            the localisation progress of the clip, where 0 is totally non-localised and 1 is completely localised.
        """
        ...
    def mediaSource(self) -> MediaSource:
        """

        Returns:
            the clip's media source.
        """
        ...
    def metadata(self, *args, **kwargs) -> Metadata:
        """
        self.isNull() -> returns a *copy* of the clip's metadata.
        """
        ...
    def numAudioTracks(self) -> int:
        """

        Returns:
            number of audio tracks contained by this clip.
        """
        ...
    def numVideoTracks(self) -> int:
        """

        Returns:
            number of video tracks contained by this clip.
        """
        ...
    def reconnectMedia(self, path):
        """
        Reconnect the Clip with media found in the specified path.

        Args:
            path: path containing media to reconnect to
        """
        ...
    def refresh(self):
        """
        updates the clip if the source media has changed.
        """
        ...
    def removeTag(self, tag):
        """
        removes the tag from the clip.

        Args:
            tag: Tag
        """
        ...
    def rescan(self):
        """
        updates the clip and rescan the frame range if the source media has changed.
        """
        ...
    def setCameraColourTransform(self, colourTransform):
        """
        sets the camera colour transform for the source media.

        Args:
            colourTransform: Colour transform name
        """
        ...
    def setEntityReference(self, location):
        """
        set this clip's (asset management system) entity reference.

        Args:
            location: Asset management system's string identifier for the entity.
        """
        ...
    def setFrameRange(self):
        """
        Sets the clip frame range to the specified values.
        """
        ...
    def setLocalisationPolicy(self, localisationPolicy):
        """
        sets the localisation policy to the clip.

        Args:
            localisationPolicy: localisation policy to apply to the clip
        """
        ...
    def setSourceMediaColourTransform(self, colourTransform):
        """
        sets the input colour transform for the source media.

        Args:
            colourTransform: Colour transform name
        """
        ...
    def sourceIn(self) -> frame:
        """

        Returns:
            the source in value for the clip.
        """
        ...
    def sourceMediaColourTransform(self) -> typing.Text:
        """

        Returns:
            colour transform for the source media.
        """
        ...
    def sourceOut(self) -> frame:
        """

        Returns:
            the source out value for the clip.
        """
        ...
    def subTrackItems(self, *args, **kwargs):
        """ """
        ...
    ...

class ConformRule(Shiboken.Object):
    """
    Represents a conform rule used by Hiero to make decisions when conforming. Can be derived from in order to make new conform rules.
    """

    Type: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kConform: ... = core.Hiero.Python.ConformRule.Type.kConform
    """
    """

    kConformAndReconnect: ...
    """
    """

    kReconnect: ... = core.Hiero.Python.ConformRule.Type.kReconnect
    """
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def activate(self):
        """
        adds this conform rule to the list of conform rules. Conform operations done after this call will use the rule.
        """
        ...
    def appliesToTrackItems(self):
        """
        should return True if this conform rule applies to track items.

        Returns:
            True or False; default implementation returns True
        """
        ...
    def compare(self, media, candidateMedia):
        """
        should compare media against candidateMedia, and return True if they match, according to this conform rule.
        The metadata contains the following keys which can be used for creating matching rules:  Conformer.kUmid == 'umid'  Conformer.kName == 'name'  Conformer.kTapeName == 'tapeName'  Conformer.kUrl == 'url'  Conformer.kAudioChannels == 'audioChannels'  Conformer.kDuration == 'duration'  Conformer.kFramerate == 'framerate'  Conformer.kFramerateIsNtsc == 'framerateIsNtsc'  Conformer.kSamplerate == 'samplerate'  Conformer.kMediaType == 'mediaType'  Conformer.kMasterMediaType == 'masterMediaType'  Conformer.kStartTime == 'startTime'  Conformer.kTimecode == 'timecode'  Conformer.kWidth == 'width'  Conformer.kHeight == 'height'

        Returns:
            True for a match, False otherwise; default implementation returns False
        """
        ...
    def conformType(self):
        """
        Get the conform types for which this rule can be used.  The default is kConform.

        Returns:
            one of the constants kConform, kReconnect, kConformAndReconnect
        """
        ...
    def deactivate(self):
        """
        removes this conform rule from the list of conform rules. Conform operations done after this call will not use the rule.
        """
        ...
    def isNull(self, *args, **kwargs):
        """
        self.name() -> should return True if the conform rule is invalid.

        Returns:
            True for invalid, False otherwise
        """
        ...
    def name(self) -> typing.Text:
        """

        Returns:
            the name of the conform rule (which was passed to the object in it's initializer).
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    ...

class Conformer(Shiboken.Object):
    """
    Provides and interface for querying and setting the conform options, such as file pattern filters and active rules.
    These options mirror those found in the conforming dialog box in the UI.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def excludeNonOverlappingTimecode(self):
        """

        Returns:
            the state of the exclude non-overlapping timecode flag.
            True when media which does not have timecode overlapping track items is excluded from matching.
        """
        ...
    def excludePatterns(self):
        """
        By default this is empty.

        Returns:
            the list of file patterns that are excluded from source media searches.
            A list containing the file patterns excluded from source media searches.
        """
        ...
    def includeAlreadyMatched(self):
        """

        Returns:
            the state of re-conform media flag.
            True when the tracks that already have media attached will be re-conformed.
        """
        ...
    def includePatterns(self):
        """
        By default this is '*', which includes all file types.

        Returns:
            the list of file patterns that are included in source media searches.
            A list containing the file patterns included in source media searches.
        """
        ...
    def nativeRuleFiltering(self):
        """
        By changing the state of the flags for the rules and submitting the dictionary back to the Conformer the rules can be filterd out.

        Returns:
            a dictionary with the names of the native conforming rules and whether they are enabled for conforming.
            A dictionary containing the enabled flag for each native rule, keyed by the rule name.
        """
        ...
    def nativeRuleNames(self):
        """
        This can be used to set rule filtering.

        Returns:
            the list of names for the native rules.
            A list containing the names for all of the conform rules built-in to Hiero.
        """
        ...
    def pythonRuleFiltering(self):
        """
        By changing the state of the flags for the rules and submitting the dictionary back to the Conformer the rules can be filterd out.

        Returns:
            a dictionary with the names of the Python conforming rules and whether they are enabled for conforming.
            A dictionary containing the enabled flag for each Python rule, keyed by the rule name.
        """
        ...
    def pythonRuleNames(self):
        """
        This can be used to set rule filtering.

        Returns:
            the list of names for the registered Python rules.
            A list containing the names for all of the conform rules that have been added through the Python API.
        """
        ...
    def setExcludeNonOverlappingTimecode(self, flag):
        """
        controls whether matching is done on media which does not have timecode which overlaps the track item.
        """
        ...
    def setExcludePatterns(self, filepatterns):
        """
        sets the list of file patterns to exclude from source media searches.
        """
        ...
    def setIncludeAlreadyMatched(self, flag):
        """
        controls whether to re-connect tracks that already have media matched to them.
        """
        ...
    def setIncludePatterns(self, filepatterns):
        """
        sets the list of file patterns to include in source media searches.
        """
        ...
    def setNativeRuleFiltering(self, ruleFiltering):
        """
        uses a dictionary keyed on the names of the native conforming rules to set whether each rule is enabled for conforming.
        """
        ...
    def setPythonRuleFiltering(self, ruleFiltering):
        """
        uses a dictionary keyed on the names of the Python conforming rules to set whether each rule is enabled for conforming.
        """
        ...
    def setUseBestTimecodeMatch(self, flag):
        """
        controls whether to accept the best timecode match if no rules match.
        """
        ...
    def useBestTimecodeMatch(self):
        """

        Returns:
            the state of the use best timecode match flag.
            True when the best timecode match will be accepted if no rules match.
        """
        ...
    ...

class DataCollection(Shiboken.Object):
    """
    Storage objects for key/value pairs. Generally used to store metadata.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __contains__(self, *args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def dict(self) -> dict:
        """

        Returns:
            a dictionary of key/value pairs. Can be used to iterate over the items in this collection.
        """
        ...
    def hasKey(self, key) -> bool:
        """

        Args:
            key: the key to look up

        Returns:
            True if the collection has a value for the key.
        """
        ...
    def keys(self):
        """

        Returns:
            keys in the collection.
            list of strings which are keys in the collection
        """
        ...
    def readOnly(self, key) -> bool:
        """

        Returns:
            True if the collection can be modified.
        """
        ...
    def setValue(self, key):
        """
        sets the value of the key stored in this collection.

        Args:
            key: the key to look up
            value: value to assign to key
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a formatted list of the key/value pairs currently set on this object. Equivalent to str(object).
        """
        ...
    def value(self, key) -> typing.Text:
        """

        Args:
            key: the key to look up

        Returns:
            the value of the key stored in this collection. Throws an exception if the key does not exist.
        """
        ...
    ...

class EffectTrackItem(SubTrackItem):
    """
    Class representing an effect on a sequence.  EffectTrackItem is derived from SubTrackItem and thus EffectTrackItem objects can be placed and trimmed on VideoTrack subtracks.
    The effect's node can be accessed with effect.node(), which can then be manipulated through the nuke Node API.To create effects, it is recommended you use the hiero.core.VideoTrack.createEffect() method.

    Usage:
    EffectTrackItem(effectType)
    EffectTrackItem(effectType, timelineIn, timelineOut)
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def addToNukeScript(
        self,
        script,
        offset=0,
        inputs=1,
        cliptype=None,
        startHandle=0,
        endHandle=0,
        addLifetime=True,
    ):
        """
        alias of _EffectTrackItem_addToNukeScript
        """
        ...
    def clone(self):
        """

        Returns:
            a deep copy of this object but, unlike copy(), this clones the underlying Nuke node so that the knobs are shared.
        """
        ...
    def copy(self, *args, **kwargs):
        """ """
        ...
    def declone(self):
        """
        Declones the effect item. Has no effect if the item is not a clone.
        """
        ...
    def isRetimeEffect(self):
        """
        alias of _EffectTrackItem_isRetimeEffect
        Check if an EffectTrackItem applies a retime.  Currently this only applies to TimeWarp effects.
        """
        ...
    def isValid(self):
        """
        Returns true if the effect item is in a valid state and position and false otherwise.
        """
        ...
    def name(self) -> typing.Text:
        """
        alias of __EffectTrackItem_name
        Get the name of the effect's node.
        """
        ...
    def node(self) -> Node:
        """
        Get the node used to apply the effect.

        Returns:
            The effect node.
        """
        ...
    def setName(self):
        """
        alias of __EffectTrackItem_setName
        Set the name of the effect's node.
        """
        ...
    def toString(self, *args, **kwargs):
        """ """
        ...
    ...

class ExportStructure2(core.Hiero.Python.IExportStructure):
    """
    ExportStructure2 is the implementation of the datastructure used to represent
    the export tree, each node within the tree is represented by an ExportStructureElement.
    Although this matches how the export presets are viewed in the UI, when it comes
    running an export, or persisting the structure, it is flattened into a list
    of paths and task presets.
    """

    def __init__(self):
        """ """
        ...
    def __repr__(self):
        """ """
        ...
    def exportRootPath(self):
        """
        Returns the exportRootPath, the root of the export into which the export structure is built
        """
        ...
    def findElementsByPath(self, path):
        """
        Find the elements matching path. Returns a list.
        """
        ...
    def flatten(self):
        """
        Return the hierarchy as a list of (path, preset) tuples
        """
        ...
    def restore(self, sequence):
        """
        Restore the hierarchy from a list of (path, preset) tuples
        """
        ...
    def rootElement(self):
        """
        Return the root element in this hierarchy.
        The root element is not included in the path generation
        """
        ...
    def setExportRootPath(self, rootPath):
        """
        Set the exportRootPath, the root of the export into which the export structure is built
        """
        ...
    ...

class ExportStructureElement(core.Hiero.Python.IExportStructureElement):
    """
    ExportStructureElement represents a node within the export structure
    """

    def __contains__(self, name):
        """ """
        ...
    def __getitem__(self, index):
        """ """
        ...
    def __init__(self, name, isFolder):
        """ """
        ...
    def __len__(self):
        """ """
        ...
    def __nonzero__(self):
        """
        Implemented because otherwise the __len__ method is used for evaluation
        in boolean contexts. 'if element' should always succeed.
        """
        ...
    def __repr__(self):
        """ """
        ...
    def addChild(self, child):
        """
        Add a child to this Element
        """
        ...
    def addPathChangedCallback(self, callback):
        """
        Add a callback to be notified when the path of this element has changed,
        callbacks should take the arguments (oldPath, newPath).
        """
        ...
    def child(self, index):
        """
        Return a child by index
        """
        ...
    def childCount(self):
        """
        Return the number of children
        """
        ...
    def childIndex(self, element):
        """
        Given a child element, identify and return the index of the child within
        the children array. Returns -1 if child not found.
        """
        ...
    def children(self):
        """
        Return a list of children
        """
        ...
    def clearChildren(self):
        """
        Clear all the children
        """
        ...
    def createChildFolder(self, path):
        """ """
        ...
    def createChildFromPreset(self, path, preset):
        """
        Create a child element from a path and existing preset
        """
        ...
    def createChildTask(self, path):
        """ """
        ...
    def findElementsByPath(self, path):
        """
        Search recursively through the element tree finding elements which
        match path. Returns a list.
        """
        ...
    def fromXml(self, xml):
        """
        Build Child Elements from XML data
        """
        ...
    def isLeaf(self):
        """
        Returns True if node is flagged as leaf and may not accept children
        """
        ...
    def name(self):
        """
        Return the name of this Element
        """
        ...
    def parent(self):
        """
        Return the parent element of this Element
        """
        ...
    def path(self):
        """
        Return the path of this Element
        """
        ...
    def pathChanged(self, oldPath):
        """
        Notify children and any observers that the element's path has changed.
        """
        ...
    def preset(self):
        """
        Return the preset assigned to this Element. May be None
        """
        ...
    def removeChild(self, child):
        """
        Remove a child from this Element
        """
        ...
    def setName(self, name):
        """
        Set the name of this element.
        """
        ...
    def setPreset(self, preset):
        """
        Set the preset assigned to this Element. May be None
        """
        ...
    def setPresetType(self, identifier):
        """

        Args:
            identifier: Unique identifier from the Task which is used to associate the preset type
        """
        ...
    def toXml(self):
        """
        Serialize Element and children to XML
        """
        ...
    ...

class FlipbookManager(Shiboken.Object):
    """
    Object for Flipbook manager
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def createClip(self, filepath) -> Clip:
        """
        creates and return a flipbook clip for the defined filepath.
        """
        ...
    def createEffectItem(self, effectType) -> EffectTrackItem:
        """
        creates and return a flipbook Soft Effect with defiend effectType.
        """
        ...
    def createSequence(self, framerate, outputformat) -> Sequence:
        """
        creates and returns a flipbook sequence with the defined framerate and ouput formar.
        """
        ...
    def setWorkingSpace(self, workingSpace) -> None:
        """
        sets the colorspace to use as the working space.
        """
        ...
    def updateOCIOConfig(self, ocioConfigPath) -> None:
        """
        updates the flipbook OCIO setting with the defined ocio config filename.
        """
        ...
    ...

class FolderTask(TaskBase):
    """
    Task which just creates an empty folder.
    """

    def __init__(self, initDict):
        """ """
        ...
    ...

class FolderTaskPreset(TaskPresetBase):
    """
    Preset which can be used for creating an empty folder.
    """

    def __init__(self, name, properties):
        """ """
        ...
    ...

class Format(Shiboken.Object):
    """
    Object containing width, height, pixel aspect, and name of a Clip/Sequence format.

    Initialisation:
    Format(width, height, pixel_aspect, name)

    Format(formatStr)

    @param: width - the format's width in pixels (integer)
    @param: height - the format's height in pixels (integer)
    @param: pixel_aspect - the format's pixel aspect ratio (float)
    @param: name - the display name of the format (string)

    @param: formatStr - the string representation of the format in the form returned by str(format)

    Examples: F = hiero.core.Format(2048, 400, 2.37, 'MyFormat'), F = hiero.core.Format('2048 400 0 0 2048 400 2.37 MyFormat')
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def addToNukeScript(self, script, to_type) -> nuke.ReformatNode:
        """
        alias of _Format_addToNukeScript
        adds a Reformat node matching this Format to the specified script and returns the nuke node object.

        Args:
            script: Nuke script object to add nodes to, or None to just generate and return the node.
            resize: Type of resize (use constants from nuke.ReformatNode, default is kResizeWidth).   @parm black_outside: Value for the black_outside knob.
        """
        ...
    def aspect(self) -> float:
        """

        Returns:
            the aspect ratio of this format.
        """
        ...
    def cleanAperture(self) -> tuple:
        """

        Returns:
            a 4 element tuple with the rectangle (x1, y1, x2, y2) of the clean aperture.
        """
        ...
    def height(self) -> int:
        """

        Returns:
            the height of this format.
        """
        ...
    def isValid(self) -> bool:
        """

        Returns:
            whether or not this format object has valid data.
        """
        ...
    def name(self) -> typing.Text:
        """

        Returns:
            the name of this format.
        """
        ...
    def pixelAspect(self) -> float:
        """

        Returns:
            the pixel aspect ratio of this format.
        """
        ...
    def productionAperture(self) -> tuple:
        """

        Returns:
            a 4 element tuple with the rectangle (x1, y1, x2, y2) of the production aperture.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def width(self) -> int:
        """

        Returns:
            the width of this format
        """
        ...
    ...

class IExportStructure(Shiboken.Object):
    """
    Base class to be derived from in order to populate an ExportStructureViewer widget, such as the one used in the Export dialog box. IExportStructure objects provides access to a root node, which has to be an object derived from IExportStructureElement, which the ExportStructureViewer widget then uses to determine the tree structure to display to the user. For an example of how to derive from this class, see Plugins/site-packages/hiero/core/FnExportStructure.py. For an example use of a derived IExportStructure object, see Plugins/site-packages/hiero/exporters/FnShotProcessor.py. It will often be more than sufficient to just use an ExportStructure2 object, instead of subclassing IExportStructure directly.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def childElement(self, path):
        """
        should return an object derived from IExportStructureElement, representing a child with the path specified.

        Args:
            path: the path to the new (or existing) child element

        Returns:
            IExportStructureElement derived object
        """
        ...
    def exportRootPath(self) -> typing.Text:
        """
        retrieves the root path for the export structure.
        """
        ...
    def rootElement(self):
        """
        should return a IExportStructureElement super class object, representing the root of the export file structure.

        Returns:
            IExportStructureElement derived object
        """
        ...
    def setExportRootPath(self, path):
        """
        called when the user has modified the export root path, to inform the object of the new path.

        Args:
            path: the new user supplied path to export to.
        """
        ...
    ...

class IExportStructureElement(Shiboken.Object):
    """
    Base class to be derived from and used in conjunction with a custom implementation of IExportStructure. For an example of how to derive from this class, see Plugins/site-packages/hiero/core/FnExportStructure.py.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def addChild(self, newChild):
        """
        should append the new child item to this node's children, and set the parent on the child to this node.

        Args:
            newChild: IExportStructureElement
        """
        ...
    def child(self, index) -> IExportStructureElement:
        """
        should return the child of this node, based on the index.

        Args:
            index: int index of the child to return
        """
        ...
    def childCount(self) -> int:
        """
        should return the number of child nodes on this item.
        """
        ...
    def childIndex(self, exportElementChild) -> int:
        """
        if the parameter is a child of this node, then this method should return the index of that child amongst the node's other children.

        Args:
            exportElementChild: IExportStructureElement
        """
        ...
    def clearChildren(self):
        """
        clears all of the children nodes from this node.
        """
        ...
    def createChildFolder(self, path) -> IExportStructureElement:
        """
        create a child folder, including any needed intermediate folders, for the given path. If the named folder already exists, returns it.

        Args:
            path: the path to the new folder
        """
        ...
    def createChildTask(self, path) -> IExportStructureElement:
        """
        create a child task, including any needed intermediate folders, for the given path.

        Args:
            path: the path to the new element
        """
        ...
    def fromXml(self, xmlText):
        """
        should reinitialize the node from the xml text, and recreate the preset and all child nodes as well. If initialized using taskRegistry._savePresetElement, taskRegistry._loadPresetElement can be used to get data back out.

        Args:
            xmlText: xml formatted text, as a result of a call in the past to the toXml method
        """
        ...
    def isLeaf(self) -> bool:
        """
        should return True if this is a node with no children, otherwise it should return False.
        """
        ...
    def name(self) -> typing.Text:
        """
        should return the name of this element.
        """
        ...
    def parent(self) -> IExportStructureElement:
        """
        should return the parent node of this object.
        """
        ...
    def path(self) -> typing.Text:
        """
        should return the full path to this node, including the path of any parents of this node.
        """
        ...
    def preset(self):
        """
        should return an object derived from TaskPreset, representing the task associated with this element of the export structure.

        Returns:
            hiero.core.TaskPreset derived object
        """
        ...
    def removeChild(self, child):
        """
        should remove the child from the node's list of children

        Args:
            child: IExportStructureElement child object to remove
        """
        ...
    def setName(self, name):
        """
        called to tell the node it's name.

        Args:
            name: typing.Text
        """
        ...
    def setPreset(self, preset):
        """
        tells the object that the user has selected a new preset for this particular export element.

        Args:
            preset: a hiero.core.TaskPreset derived object, which can be used to create a task to process later on during an export.
        """
        ...
    def setPresetType(self, presetType):
        """
        called to tell the object to set the task preset type by name. The taskRegistry can be used with this 'type' to create the preset to store.

        Args:
            presetType: the name of the task preset to create/use.
        """
        ...
    def toXml(self) -> typing.Text:
        """
        should return a string of formatted xml which can be sent to the fromXml method later to read it back. The xml should include the preset data for this node, as well as the children, and should be in proper xml format. This can be done easily with xml.etree.cElementTree, especially because the taskRegistry has methods to write out xml for presets and other objects (taskRegistry._savePresetElement)
        """
        ...
    ...

class IExporterRegistry(Shiboken.Object):
    """
    IExporterRegistry provides a simple interface for our C++ Application to access python instance of hiero.core.TaskRegistry.

    This class should not be used directly; use hiero.core.TaskRegistry instead.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def assignPresetToProject(self, TaskPreset, Project):
        """
        Called by the C++ application to assign a TaskPreset to .
        a null hiero.core.Project will remove the project assignment and revernt the preset to local ownership.

        Args:
            param1: TaskPreset
            param2: Project
        """
        ...
    def copyAndAddProcessorPreset(self, param1):
        """
        Called by the C++ application to duplicate a preset.

        Args:
            param1: TaskPreset instance for duplication

        Returns:
            new hiero.core.TaskPreset instance
        """
        ...
    def copyAndAddProjectPreset(self, param1, param2):
        """
        Called by the C++ application to duplicate a preset and assign it to a new project.

        Args:
            param1: TaskPreset instance for duplication
            param2: Project to which cloned preset should be assigned

        Returns:
            new hiero.core.TaskPreset instance
        """
        ...
    def createAndAddProcessorPreset(self, arg1: typing.Text, TaskPreset):
        """
        Called by the C++ application to create a new preset, using typetemplate as a template.

        Args:
            string: string - Preset name

        Returns:
            hiero.core.TaskPreset instance as type template
        """
        ...
    def createAndExecuteProcessor(
        self,
        TaskPreset,
        arg2: typing.Optional[hiero.core.ItemWrapper],
        arg3: typing.Text,
    ):
        """
        Called by the C++ application to instantiate the Processor associated with specified preset and execute on the selected items.

        Args:
            param1: TaskPreset
            list: typing.List[items for export]
            name: name of submission object used for dispatching job to renderfarm
        """
        ...
    def discardPresetChanges(self, *args, **kwargs):
        """
        self.startPresetChanges(hiero.core.Project) -> Discard any changes to the presets since startPresetChanges() was called.

        Args:
            param1: Project)
        """
        ...
    def isOutputResolutionValid(
        self, TaskPreset, arg2: typing.Optional[hiero.core.ItemWrapper]
    ):
        """
        Called by the C++ application to determinate if preset and selected items have valid resolution according the application mode.
        A warning message will be shown in case of any invalid output resolution.

        Args:
            param1: TaskPreset
            list: typing.List[items for export]

        Returns:
            An error string if disallowed, otherwise an empty string.
        """
        ...
    def loadPresets(self, arg1: typing.Text):
        """
        Called by the C++ application to load presets from a specified path.

        Args:
            path: path as string
        """
        ...
    def localPresets(self, *args, **kwargs) -> typing.List[TaskPreset]:
        """
        self.projectPresets() -> Returns a list of local presets assigned to the specified Project.
        """
        ...
    def localPresetsChanged(self):
        """
        Called by the C++ application to check whether local presets have changed since last save.

        Returns:
            bool changed state
        """
        ...
    def nukeShotExportPresets(self, Project) -> typing.List[TaskPreset]:
        """
        Get a list of presets which are contain Nuke shot exports.
        """
        ...
    def presetFromXml(self, arg1: typing.Text):
        """
        Called by the C++ application to ask the TaskRegistry to deserialize a Task preset from xml.

        Args:
            string: string - Preset XML

        Returns:
            hiero.core.TaskPreset instance
        """
        ...
    def presetToPrettyXml(self, TaskPreset):
        """
        Called by the C++ application to ask the TaskRegistry to serialize a Task preset to human friendly formatted xml.

        Args:
            param1: TaskPreset instance

        Returns:
            string - Preset XML
        """
        ...
    def presetToXml(self, TaskPreset):
        """
        Called by the C++ application to ask the TaskRegistry to serialize a Task preset to xml.

        Args:
            param1: TaskPreset instance

        Returns:
            string - Preset XML
        """
        ...
    def presetsSubDirectory(self):
        """
        Get the sub-directory in the plugin paths to search for presets.
        """
        ...
    def projectDuplicated(self, param1: Project, param2: Project):
        """
        Called by the C++ application to notify the TaskRegistry that a project has been duplicated and its associated Presets should be duplicated and assigned to the new project.

        Args:
            param1: Project - original project
            param2: Project - new project
        """
        ...
    def projectExportHistoryXml(self, Project) -> typing.List[typing.Text]:
        """
        Returns a list of XML fragments containing the project export history.

        Args:
            param1: project
        """
        ...
    def projectPresets(self, Project) -> typing.List[TaskPreset]:
        """
        Returns a list of project presets assigned to the specified Project.

        Args:
            param1: Project
        """
        ...
    def projectPresetsChanged(self, Project):
        """
        Called by the C++ application to check whether project presets have changed since project last save.

        Args:
            param1: Project
        """
        ...
    def projectUnloaded(self, Project):
        """
        Called by the C++ application to notify the TaskRegistry that a project has been unloaded and its associated Presets should be released.

        Args:
            param1: Project
        """
        ...
    def registerme(self):
        """
        Called from python implimentation of TaskRegistry to register instance as the Application Task Registry.
        """
        ...
    def removeProcessorPreset(self, TaskPreset):
        """
        Called by the C++ application to remove a preset from the registry.

        Args:
            param1: TaskPreset
        """
        ...
    def renameProcessorPreset(self, TaskPreset, arg2: typing.Text):
        """
        Called by the C++ application to rename a preset in the registry.

        Args:
            param1: TaskPreset
        """
        ...
    def restoreProjectExportHistoryXml(self, Project, list):
        """
        Restore the export history for a project.

        Args:
            param1: project
            list: typing.List[strings containing export history]
        """
        ...
    def revertDefaultPresets(self, arg1: typing.Text):
        """
        Called by the C++ application reconstruct the default presets.

        Args:
            path: path as string
        """
        ...
    def savePresets(self, arg1: typing.Text):
        """
        Called by the C++ application to save presets to a specified path.

        Args:
            path: path as string
        """
        ...
    def startPresetChanges(self, Project):
        """
        Called when the user might start editing the presets, so the changes can be reverted if necessary.

        Args:
            param1: Project)
        """
        ...
    def submissionChanged(self, arg1: typing.Text, Project):
        """
        Called by the C++ application when the submission choice changes in the Export Dialog.

        Args:
            submission: submission name as a string
        """
        ...
    def submissionNames(self):
        """
        Called by the C++ application to get a list of the available Submission objects. Submission objects are used to manage render farm renders.

        Returns:
            list of name strings
        """
        ...
    ...

class ITask(Shiboken.Object):
    """
    ITask provides a simple interface for our C++ Application to access Python instances of TaskBase.

    This class should not be used directly; use hiero.core.TaskBase instead.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def addToQueue(self):
        """
        adds this task into the task queue.
        """
        ...
    def children(self):
        """
        get a list of child tasks.  Note that this list should not change after addToQueue() has been called.
        """
        ...
    def clearError(self):
        """
        clears the error or warning string for this task.
        """
        ...
    def destinationDescription(self):
        """
        Get the destination description.
        """
        ...
    def error(self):
        """
        Get the error string if one has been set.
        """
        ...
    def finishTask(self):
        """
        called by Hiero to tell the Task to that it's finished. Subclasses should finish processing in their override of this method (close files, clean up).
        """
        ...
    def forcedAbort(self):
        """
        called by Hiero when the user presses the Abort button. Subclasses should do any clean up in their override of this method.
        """
        ...
    def formatDescription(self):
        """
        Get a description of the format that this task writes to.
        """
        ...
    def getExportDuration(self):
        """
        Return the time this task took to export in milliseconds. Will return 0 until the task has finished exporting.
        """
        ...
    def ident(self):
        """
        called by Hiero to get a unique identifier for this task.
        """
        ...
    def progress(self):
        """
        called by Hiero to find out from the task what it's progress is, between 0.0 and 1.0.
        """
        ...
    def setDestinationDescription(self, desc):
        """


        Args:
            desc: typing.Text
        """
        ...
    def setDuplicate(self):
        """
        Sets the flag cancelling this task and marking as duplicate.
        """
        ...
    def setError(self, desc):
        """
        sets the error string displayed to the user in the task dialog. Error strings display in red.

        Args:
            desc: the text to display
        """
        ...
    def setExportDuration(self, *args, **kwargs):
        """
        For internal use only. Do not use.
        """
        ...
    def setFormatDescription(self, desc):
        """
        tells Hiero a description of the format that this task writes to.

        Args:
            desc: description of the format that this task outputs
        """
        ...
    def setSynchronous(self):
        """
        Flags this task as synchronous. When added to the queue, this task will be executed imediately on the current thread. The Flag must be set prior to adding to queue
        """
        ...
    def setTaskDescription(self, description):
        """
        tells Hiero a descriptive string for the task that it can use to show the user through the user interface and/or store it for reference. Helpful when debugging.

        Args:
            desc: description of the task
        """
        ...
    def setWarning(self, desc):
        """
        sets the warning string displayed to the user in the task dialog. Warning strings display in orange.

        Args:
            desc: the text to display
        """
        ...
    def startTask(self):
        """
        called by Hiero to tell the Task to start. Subclasses should start processing in their override of this method.
        """
        ...
    def synchronous(self):
        """
        Returns the state of the Synchronous flag. If True, wheb added to the queue, this task will be executed imediately on the current thread.
        """
        ...
    def taskDescription(self):
        """
        Get a description of the task.
        """
        ...
    def taskStep(self):
        """
        called by Hiero repeatedly until the progress method returns 1.0 or greater. Step based processing should occur in this method by subclasses of Task.
        """
        ...
    ...

class ITaskPreset(Shiboken.Object):
    """
    ITaskPreset provides a simple interface for our C++ Application to access Python instances of TaskPreset.

    This class should not be used directly; use hiero.core.TaskPresetBase instead.
    """

    ItemTypes: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kAllItems: ... = core.Hiero.Python.ITaskPreset.ItemTypes.kAllItems
    """
    """

    kAudioTrackItem: ...
    """
    """

    kClip: ... = core.Hiero.Python.ITaskPreset.ItemTypes.kClip
    """
    """

    kSequence: ... = core.Hiero.Python.ITaskPreset.ItemTypes.kSequence
    """
    """

    kTrackItem: ... = core.Hiero.Python.ITaskPreset.ItemTypes.kTrackItem
    """
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def getResolveEntryCount(self):
        """
        called by Hiero to get the number of resolve tokens available on this TaskPreset.
        """
        ...
    def ident(self):
        """
        called by Hiero to get a unique identifier for the Task related to this TaskPreset.
        """
        ...
    def markedForDeletion(self):
        """
        called by Hiero to check if the preset is marked for deletion.
        """
        ...
    def name(self):
        """
        called by Hiero to get the preset name.
        """
        ...
    def project(self):
        """
        called by Hiero to discover which Project (if any), this preset is assigned to
        """
        ...
    def readOnly(self):
        """
        called by Hiero to discover if this preset is marked ReadOnly.
        """
        ...
    def resolveEntryDescription(self):
        """
        called by Hiero to get a resolve token description by index.
        """
        ...
    def resolveEntryName(self):
        """
        called by Hiero to get a resolve token ({shot}) by index.
        """
        ...
    def setMarkedForDeletion(self):
        """
        called by Hiero to mark this preset for deletion. The delete is not performed until presets are saved.
        """
        ...
    def setProject(self):
        """
        called by Hiero to assign a preset to a Project.
        """
        ...
    def setReadOnly(self):
        """
        called by Hiero to mark this preset as ReadOnly.
        """
        ...
    def summary(self):
        """
        called by Hiero to get the preset description.
        """
        ...
    def supportedItems(self):
        """
        called by Hiero to establish what types of object this export task operates on (Clips, Sequences, TrackItems).
        """
        ...
    def supportsAudio(self) -> bool:
        """

        Returns:
            whether or not this task preset supports audio.
        """
        ...
    ...

class ItemWrapper(Shiboken.Object):
    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def bin(self) -> Bin:
        """
        converts this ItemWrapper to a hiero.core.Bin object. If the item wrapper isn't wrapping a Bin object, it will return a non-functioning (isNull returns True) TrackItem object (meaning that it has all of the methods of a Bin object, but the methods don't do anything)
        """
        ...
    def binItem(self) -> BinItem:
        """
        converts this ItemWrapper to a hiero.core.BinItem object. If the item wrapper isn't wrapping a BinItem object, it will return a non-functioning (isNull returns True) TrackItem object (meaning that it has all of the methods of a BinItem object, but the methods don't do anything)
        """
        ...
    def clip(self) -> Clip:
        """
        converts this ItemWrapper to a hiero.core.Clip object. If the item wrapper isn't wrapping a Clip object, it will return a non-functioning (isNull returns True) Clip object (meaning that it has all of the methods of a Clip object, but the methods don't do anything)
        """
        ...
    def ignore(self, *args, **kwargs):
        """ """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            True if this is a invalid or uninitialized item, or False otherwise
        """
        ...
    def item(
        self,
    ) -> Sequence | hiero.core.Clip | hiero.core.TrackItemBase | hiero.core.BinItem:
        """
        Return the item contained within this wrapper.
        """
        ...
    def name(self) -> typing.Text:
        """
        Returns item name.
        """
        ...
    def root(self) -> Bin:
        """
        the root is the highest level in the bin selected for export, Root may be null.
        """
        ...
    def sequence(self) -> Sequence:
        """
        converts this ItemWrapper to a hiero.core.Sequence object. If the item wrapper isn't wrapping a Sequence object, it will return a non-functioning (isNull returns True) Sequence object (meaning that it has all of the methods of a Sequence object, but the methods don't do anything)
        """
        ...
    def trackItem(self) -> TrackItem:
        """
        converts this ItemWrapper to a hiero.core.TrackItemBase object. If the item wrapper isn't wrapping a TrackItem object, it will return a non-functioning (isNull returns True) TrackItem object (meaning that it has all of the methods of a TrackItem object, but the methods don't do anything)
        """
        ...
    ...

class Keys(Shiboken.Object):
    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kAssetEntityReference: ...
    """
    """

    kClipComment: ...
    """
    """

    kDDImageRootNodeName: ...
    """
    """

    kEdlComments: ...
    """
    """

    kEdlEditNumber: ...
    """
    """

    kEdlEditString: ...
    """
    """

    kEdlEffect: ...
    """
    """

    kEdlMode: ...
    """
    """

    kEdlName: ...
    """
    """

    kEdlRetime: ...
    """
    """

    kEdlSourceReel: ...
    """
    """

    kEdlSrcIn: ...
    """
    """

    kEdlSrcOut: ...
    """
    """

    kEdlSrcTimecode: ...
    """
    """

    kEdlTimelineIn: ...
    """
    """

    kEdlTimelineOut: ...
    """
    """

    kMXFPreferredTransfer: ...
    """
    """

    kMediaAudioChannels: ...
    """
    """

    kMediaDuration: ...
    """
    """

    kMediaForceTimecode: ...
    """
    """

    kMediaFramerate: ...
    """
    """

    kMediaFramerateIsNtsc: ...
    """
    """

    kMediaHeight: ...
    """
    """

    kMediaIsStillFrame: ...
    """
    """

    kMediaMasterMediaType: ...
    """
    """

    kMediaMediaType: ...
    """
    """

    kMediaName: ...
    """
    """

    kMediaSamplerate: ...
    """
    """

    kMediaStartTime: ...
    """
    """

    kMediaTapeName: ...
    """
    """

    kMediaTimecode: ...
    """
    """

    kMediaUmid: ...
    """
    """

    kMediaUrl: ...
    """
    """

    kMediaWidth: ...
    """
    """

    kNukePixelEncodingMatrix: ...
    """
    """

    kPlayerTrack: ...
    """
    """

    kQuickTimeGamma: ...
    """
    """

    kQuickTimePixelEncoding: ...
    """
    """

    kQuickTimePreferredMatrix: ...
    """
    """

    kQuickTimePreferredTransfer: ...
    """
    """

    kSourceAudioBitDepth: ...
    """
    """

    kSourceBitmapSize: ...
    """
    """

    kSourceDuration: ...
    """
    """

    kSourceFormat: ...
    """
    """

    kSourceFramerate: ...
    """
    """

    kSourceGamma: ...
    """
    """

    kSourceHasDefaultView: ...
    """
    """

    kSourceHeight: ...
    """
    """

    kSourceInputColourTransform: ...
    """
    """

    kSourceLayers: ...
    """
    """

    kSourceNumAudioChannels: ...
    """
    """

    kSourceNumSamples: ...
    """
    """

    kSourceOriginalSamplerate: ...
    """
    """

    kSourcePixelAspectRatio: ...
    """
    """

    kSourceReelId: ...
    """
    """

    kSourceSamplerate: ...
    """
    """

    kSourceShootTime: ...
    """
    """

    kSourceShortFileName: ...
    """
    """

    kSourceSize: ...
    """
    """

    kSourceStartTime: ...
    """
    """

    kSourceTimecode: ...
    """
    """

    kSourceTimecodeDropFrame: ...
    """
    """

    kSourceUmid: ...
    """
    """

    kSourceViewUnspecifiedPostfix: ...
    """
    """

    kSourceViewUnspecifiedPrefix: ...
    """
    """

    kSourceViews: ...
    """
    """

    kSourceViewsDelimiter: ...
    """
    """

    kSourceWidth: ...
    """
    """

    kTimelineAudioSynced: ...
    """
    """

    kTimelineDuration: ...
    """
    """

    kTimelineFramerate: ...
    """
    """

    kTimelineIn: ...
    """
    """

    kTimelineName: ...
    """
    """

    kTimelineOut: ...
    """
    """

    kTimelineOutputFormat: ...
    """
    """

    kTimelineOverrideOutputFormat: ...
    """
    """

    kTimelinePoster: ...
    """
    """

    kTimelinePosterLayer: ...
    """
    """

    kTimelineSamplerate: ...
    """
    """

    kTrackBlendEnabled: ...
    """
    """

    kTrackBlendMode: ...
    """
    """

    kTrackDuration: ...
    """
    """

    kTrackEnabled: ...
    """
    """

    kTrackLocked: ...
    """
    """

    kTrackMaskBlendEnabled: ...
    """
    """

    kTrackVolume: ...
    """
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class MediaFileInfo(Shiboken.Object):
    """
    Object representing a single set of media files on disk.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def endFrame(self):
        """

        Returns:
            the last frame of the media source contained by this object. Note that for video formats (mov, r3d), this will always be the media's (duration - 1).
            integer frame
        """
        ...
    def filename(self) -> typing.Text:
        """
        * /somepath/file.mov
        * /somepath/imagesequence.######.dpx (1-40)
        In the case of the image sequence above, the numbers between the brackets represent the first and last frame of the sequence.

        Returns:
            a path to a media source on disk. May represent multiple files, as with image sequences. The form will be one of the following, depending on the file extension of the media
        """
        ...
    def startFrame(self):
        """

        Returns:
            the first frame of the media source contained by this object. Note that for video formats (mov, r3d), this will always be 0.
            integer frame
        """
        ...
    ...

class MediaSource(Shiboken.Object):
    """
    Represents a media source.
    """

    MediaType: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kAudio: ... = core.Hiero.Python.MediaSource.MediaType.kAudio
    """
    """

    kVideo: ... = core.Hiero.Python.MediaSource.MediaType.kVideo
    """
    """
    @staticmethod
    def createOfflineVideoMediaSource(*args, **kwargs):
        """
        MediaSource.createOfflineVideoMediaSource() -> returns a media source that might be an offline video file. Use this to explicitly set what you expect the start, duration and framerate of the video source to be, once it becomes available.
        Raises a RuntimeError if the source path exists but could not be read by Hiero.

        Args:
            path: path to where the media will eventually be
            start: start of the media, in frames
            duration: duration of the media, in frames
            frameRate: TimeBase representing the frame rate of the media source
            startTimecode: start timecode of the media

        Returns:
            Created MediaSource
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def duration(self) -> frames:
        """

        Returns:
            the duration, in frames.
        """
        ...
    def fileinfos(self) -> typing.Tuple[MediaFileInfo, ...]:
        """

        Returns:
            a tuple of hiero.core.MediaFileInfo objects, which can be used to retrieve all of the file fragments that are used by this MediaSource.
        """
        ...
    def filename(self) -> typing.Text:
        """
        Deprecated; Please use the fileinfos() method instead.

        Returns:
            the file name (and just the file name) of the first file used for the MediaSource.
        """
        ...
    def filenameHead(self) -> typing.Text:
        """

        Returns:
            the portion of filename before the frame index for an image sequence.
        """
        ...
    def filenamePadding(self, *args, **kwargs) -> int:
        """
        self.filenameHead() -> returns the number characters used for frame index. -1 if not an image sequence.
        """
        ...
    def firstpath(self) -> typing.Text:
        """
        Deprecated; Please use the fileinfos() method instead.

        Returns:
            the full path of the first file used for the MediaSource.
        """
        ...
    def fragmentFilename(self, fragmentIndex) -> typing.Text:
        """
        Deprecated; Please use the fileinfos() method instead

        Args:
            fragmentIndex: index of the fragment to retrieve

        Returns:
            the file name (and just the file name) for the fragment of the MediaSource, specified by the fragmentIndex.
        """
        ...
    def fragmentPath(self, fragmentIndex) -> typing.Text:
        """
        Deprecated; Please use the fileinfos() method instead.

        Args:
            fragmentIndex: index of the fragment to retrieve

        Returns:
            the full path for the fragment of the MediaSource, specified by the fragmentIndex.
        """
        ...
    def hasAudio(self) -> bool:
        """
        True if the source has audio.
        """
        ...
    def hasVideo(self) -> bool:
        """
        True if the source has video.
        """
        ...
    def height(self) -> int:
        """

        Returns:
            the height of the media.
        """
        ...
    def isMediaPresent(self) -> bool:
        """

        Returns:
            True if the media is present.
        """
        ...
    def isNull(self) -> bool:
        """
        True if the object points to an invalid source, False otherwise.
        """
        ...
    def isOffline(self) -> bool:
        """

        Returns:
            True if the media is missing or unavailable for any reason.
        """
        ...
    def metadata(self) -> Metadata:
        """

        Returns:
            a hiero.core.Metadata object with metadata for the MediaSource.
        """
        ...
    def numChannels(self, *args, **kwargs):
        """ """
        ...
    def numFragments(self) -> int:
        """
        Deprecated; Please use the fileinfos() method instead.

        Returns:
            the number of files used by this MediaSource, or -1 for invalid media. For instance, for mov files, this will return 1; for exr sequences this method will return the number of exr files in the sequence.
        """
        ...
    def pixelAspect(self) -> float:
        """

        Returns:
            the pixel aspect ratio of the media.
        """
        ...
    def refresh(self):
        """
        updates source info for latest changes in underlying files but doesn't update the frame range
        """
        ...
    def singleFile(self) -> bool:
        """

        Returns:
            True if this MediaSource is comprised of only a single file regardless of how many frames it contains (like a .mov or .r3d).
        """
        ...
    def startTime(self) -> int:
        """

        Returns:
            the start time of the media.
        """
        ...
    def timecodeStart(self, *args, **kwargs):
        """ """
        ...
    def toString(self, includeMetadata=False) -> typing.Text:
        """

        Args:
            includeMetadata: True adds metadata to the string, False does not

        Returns:
            a string with info for the MediaSource. str(object) is equivalent to object.toString().
        """
        ...
    def width(self) -> int:
        """

        Returns:
            the width of the media.
        """
        ...
    ...

class NamingScheme(Shiboken.Object):
    """
    Utility object for extracting names for clips, versions and objects out of clip objects
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @staticmethod
    def clipName(clip) -> typing.Text:
        """
        extracts name from clip that will be used for displaying the clip object, based on the underlying file(s).
        Redefine this method if desired for customised naming schema. Use default_clipName for default functionality if needed.

        Args:
            clip: a clip to extract the name from
        """
        ...
    @staticmethod
    def default_clipName(clip) -> typing.Text:
        """
        extracts name from clip that will be used for displaying the clip object, based on the underlying file(s).
        Do not redefine this method. It preserves accessibility to default functionality when redefining clipName.

        Args:
            clip: a clip to extract the name from
        """
        ...
    @staticmethod
    def default_rootName(clip) -> typing.Text:
        """
        extracts name from clip that will be used for displaying the bin item object, based on the underlying file(s).
        Do not redefine this method. It preserves accessibility to default functionality when redefining rootName.

        Args:
            clip: a clip to extract the name from
        """
        ...
    @staticmethod
    def default_versionName(clip) -> typing.Text:
        """
        extracts name from clip that will be used for displaying the version object, based on the underlying file(s).
        Do not redefine this method. It preserves accessibility to default functionality when redefining versionName.

        Args:
            clip: a clip to extract the name from
        """
        ...
    @staticmethod
    def rootName(clip) -> typing.Text:
        """
        extracts name from clip that will be used for displaying the bin item object, based on the underlying file(s).
        Redefine this method if desired for customised naming schema. Use default_rootName for default functionality if needed.

        Args:
            clip: a clip to extract the name from
        """
        ...
    @staticmethod
    def versionName(clip) -> typing.Text:
        """
        extracts name from clip that will be used for displaying the version object, based on the underlying file(s).
        Redefine this method if desired for customised naming schema. Use default_versionName for default functionality if needed.

        Args:
            clip: a clip to extract the name from
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class ProcessorBase(__builtin__.object):
    """
    ProcessorBase is the base class from which all Processors should derive.
    The Processor object is responible for taking the object selection and spawning
    Tasks with the appropriate parameters.
    """

    __dict__: ...
    """
    dictionary for instance variables (if defined)
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """
    def __init__(self, preset, submission, synchronous=False):
        """ """
        ...
    def errors(self):
        """
        Get an error string from the processor.  Iterates over child tasks and
        adds their error messages to the string.  Returns None if there were no errors.
        """
        ...
    def processTaskPreQueue(self):
        """
        processTaskPreQueue() Walk Tasks in submission and mark any duplicates.
        """
        ...
    def skipOffline(self):
        """ """
        ...
    def startProcessing(self, exportItems, preview=False):
        """
        Generate export tasks and add them to the export queue. If preview is
        True, the tasks are created and returned, but not scheduled for execution.
        """
        ...
    def validItem(self, supportedTypes, item):
        """
        Get if the task is able to run on the item it was initialised with.
        """
        ...
    ...

class ProcessorPreset(FnExporterBase.TaskPresetBase):
    """
    ProcessorPreset is the base class from which all Processor Presets must derrive
    The purpose of a Processor Preset is to store and data which must be serialized to file
    and shared between the Processor and ProcessorUI user interface component
    """

    def __eq__(self, other):
        """
        Override to compare projects.  The TaskRegistry relies on presets which are otherwise identical but with different projects not comparing equal.
        """
        ...
    def __init__(self, parentType, presetName):
        """
        Initialise Exporter Preset Base Class

        Args:
            parentType: Processor type to which this preset object corresponds
            presetName: Name of preset
        """
        ...
    ...

class Project(Shiboken.Object):
    """
    Object for manipulating projects. Can be created using hiero.core.newProject() or by the following code:
    hiero.core.openProject(projectPath)
    project = hiero.core.projects()[-1]
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kAllProjects: ... = 0
    """
    """

    kStartupProjects: ... = 2
    """
    """

    kUserProjects: ... = 1
    """
    """
    @staticmethod
    def useOCIOEnvironmentOverride() -> bool:
        """

        Returns:
            whether the OCIO config has been overriden in the environment.
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def addView(self, name, color) -> bool:
        """
        Appends a view to this project's list of views. Returns False if name is empty or a view already exists with the same name.

        Args:
            name: typing.Text
            color: optional; string in the format #RGB, #RRGGBB, #RRRGGGBBB, #RRRRGGGGBBBB or a name from the list of colors defined in the list of SVG color keyword names
        """
        ...
    def audioTrackItems(self, partialName):
        """
        Example: finds all audio track items in a project with 30Sec in the name:
        trackItems = myProject.audioTrackItems('30Sec')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all audio track items in a project.
            an array of hiero.core.TrackItem objects.
        """
        ...
    def audioTracks(self, partialName):
        """
        Example: finds all audio tracks in a project with 30Sec in the name:
        tracks = myProject.audioTracks('30Sec')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all audio tracks in a project.
            an array of hiero.core.AudioTrack objects.
        """
        ...
    def beginUndo(self, name: typing.Text) -> UndoGroup:
        """
        starts a new undo action, which will group all other undo actions until self.endUndo() is called. Be aware that this method only works on the main thread, and will throw an exception otherwise.
        Note that for operations inside the undo to work Project.endUndo() must be called.  It is recommended that you use this in a with block to ensure that this happens.  For example:
          with project.beginUndo('My Undo'):
            // Undoable edits
        """
        ...
    def bins(self, partialName):
        """
        Example: finds all bins in a project with MyBin in the name:
        bins = myProject.bins('MyBin')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all bins in a project. Searches recursively, so will return bins within other bins in the list.
            an array of hiero.core.Bin objects.
        """
        ...
    def buildTrackName(self):
        """
        get default track name used when building vfx trackthis can be configured in the project settings dialog
        """
        ...
    def cancelUndo(self):
        """
        cancels an undo action started previously by a call to self.beginUndo().
        """
        ...
    def clearUnusedLocalFiles(self):
        """
        clear all localised files that are not in any currently open project. This requires localisation to be enabled
        """
        ...
    def clips(self, partialName):
        """
        Example: finds all clips in a project with 30Sec in the name:
        clips = myProject.clips('30Sec')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all clips in a project.
            an array of hiero.core.Clip objects.
        """
        ...
    def clipsBin(self) -> Bin:
        """

        Returns:
            the bin object containing the top level clips, sequences and bins for this project.
        """
        ...
    def close(self):
        """
        closes the project. Be aware that this method will not save the project, even if changes have been made since the last save of the project.
        """
        ...
    def deletable(self) -> bool:
        """

        Returns:
            True if the project can be deleted.
        """
        ...
    def deleteView(self, name) -> bool:
        """
        Removes the view with the matching name from this project's list of views. Returns False if no matching view is found or if the view to be deleted is the only view in the project.

        Args:
            name: typing.Text
        """
        ...
    def editable(self) -> bool:
        """

        Returns:
            True if the project can be edited.
        """
        ...
    def endUndo(self):
        """
        ends an undo action started previously by a call to self.beginUndo(). This will put a new item into the Edit > Undo/Redo menu items.
        """
        ...
    def extractSettings(self):
        """
        alias of _Project_extractSettings

        Returns:
            a dict of the project's settings.     @return: dict
        """
        ...
    def framerate(self) -> TimeBase:
        """
        project's default framerate for new sequences
        """
        ...
    def guid(self, *args, **kwargs):
        """ """
        ...
    def isLocalisationEnabled(self):
        """
        return whether localisation is enabled

        Returns:
            whether localisation is enabled
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            False if this is a valid Project object, True otherwise.
        """
        ...
    def isRestricted(self) -> bool:
        """

        Returns:
            whether or not access to the project is restricted.
        """
        ...
    def lutSetting16Bit(self) -> typing.Text:
        """

        Returns:
            the project's 16 bit lut setting name.
        """
        ...
    def lutSetting8Bit(self) -> typing.Text:
        """

        Returns:
            the project's 8 bit lut setting name.
        """
        ...
    def lutSettingFloat(self) -> typing.Text:
        """

        Returns:
            the project's float lut setting name.
        """
        ...
    def lutSettingLog(self) -> typing.Text:
        """

        Returns:
            the project's log lut setting name.
        """
        ...
    def lutSettingViewer(self, *args, **kwargs) -> typing.Text:
        """
        self.lutSettingsViewer() -> returns the project's viewer lut setting name.
        """
        ...
    def lutSettingWorkingSpace(self) -> typing.Text:
        """

        Returns:
            the project's Working Space lut setting name.
        """
        ...
    def lutUseOCIOForExport(self) -> bool:
        """

        Returns:
            the project setting for using OCIO in nuke script export.
        """
        ...
    def name(self) -> typing.Text:
        """

        Returns:
            the name of the project.
        """
        ...
    def ocioConfigName(self) -> typing.Text:
        """

        Returns:
            the ocio config name loaded by NukeStudio. When using a custom ocio config an empty string is returned.
        """
        ...
    def ocioConfigPath(self) -> typing.Text:
        """

        Returns:
            the project settings for the ocio config path.
        """
        ...
    def outputFormat(self) -> Format:
        """
        gets project's default outputFormat for new sequences.
        """
        ...
    def path(self) -> typing.Text:
        """

        Returns:
            the path to the project.
        """
        ...
    def projectRoot(self) -> typing.Text:
        """
        Get root path of the project used by default when sending to nuke or using {projectroot} token in export.
        """
        ...
    def redo(self):
        """
        triggers a redo of the next item in the redo stack. Only works on the main thread. If called from any other thread, throws an exception.
        """
        ...
    def redoItemText(self) -> typing.Text:
        """

        Returns:
            the text of the next item on the redo stack. Only works on the main thread. Can be useful for testing that undo/redo works.
        """
        ...
    def save(self):
        """
        saves a previously saved project to disk.
        """
        ...
    def saveAs(self, filename):
        """
        saves the project to the path specified by the filename parameter. Throws an exception if the project couldn't be saved for any reason.

        Args:
            filename: path to save the project to
        """
        ...
    def sequences(self, partialName):
        """
        Example: finds all sequences in a project with 30Sec in the name:
        sequences = myProject.sequences('30Sec')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all sequences in a project. User can filter by by partial name.
            an array of hiero.core.Sequence objects.
        """
        ...
    def setDeletable(self, deletable):
        """
        sets whether or not a project can be deleted.

        Args:
            deletable: bool
        """
        ...
    def setEditable(self, editable):
        """
        sets whether or not a project can be edited.

        Args:
            editable: bool
        """
        ...
    def setFramerate(self, TimeBase):
        """
        sets project's default framerate for new sequences.This will persist when the application is restarted
        @param TimeBase
        """
        ...
    def setHasMigratedSequenceProperties(self):
        """
        Mark the project as having had deprecated sequence properties converted into soft effects.
        """
        ...
    def setLocalisationEnabled(self):
        """
        set whether localisation is enabled. This will persist when the application is restarted.
        @param whether localisation should be enabled
        """
        ...
    def setOutputFormat(self, Format):
        """
        sets project's default output format for new sequences.

        Args:
            width: width for the output format
            height: height for the output format
            pixelAspect: float for pixel aspect ratio
            name: string for the format name

        Overloads:
            setOutputFormat(width, height, pixelAspect, name) -> sets project's default output format for new sequences. This will persist when the application is restarted
        """
        ...
    def setProjectRoot(self, path):
        """
        Set root path of the project used by default when sending to nuke or using {projectroot} token in export.

        Args:
            path: path to set as project root
        """
        ...
    def setShotPresetName(self, name):
        """
        set the name of Shot Preset which is usedwhen sending to nuke or creating a comp.

        Args:
            name: name
        """
        ...
    def setStartTimecode(self, Time):
        """
        sets project's default start timecode for new sequences. This will persist when the application is restarted
        @param TimeBase start timecode for sequence
        """
        ...
    def setTimeDisplayFormat(self):
        """
        sets project's default displayType for new sequences.  This will persist when the application is restarted
        @param DisplayType to use
        """
        ...
    def setViewsForStereo(self):
        """
        Replaces the project's views with two views named "left" and "right".
        """
        ...
    def shotPresetName(self) -> typing.Text:
        """
        get the name of Shot Preset which is usedwhen sending to nuke or creating a comp.
        """
        ...
    def startTimecode(self) -> Time:
        """
        gets project's default start frame for new sequences.
        """
        ...
    def tagsBin(self) -> Bin:
        """

        Returns:
            the bin object containing the top level tags for this project.
        """
        ...
    def timeDisplayFormat(self) -> DisplayType:
        """
        gets project's default displayType for new sequences.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def trackItems(self, partialName):
        """
        Example: finds all track items in a project with 30Sec in the name:
        trackItems = myProject.trackItems('30Sec')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all track items in a project.
            an array of hiero.core.TrackItem objects.
        """
        ...
    def tracks(
        self, partialName: typing.Text = ...
    ) -> typing.List[typing.Union[VideoTrack, AudioTrack]]:
        """
        Example: finds all tracks in a project with 30Sec in the name:
        tracks = myProject.tracks('30Sec')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all tracks in a project.
            an array of hiero.core.VideoTrack and hiero.core.AudioTrack objects.
        """
        ...
    def undo(self):
        """
        triggers an undo on the last item previously added to the undo stack. Only works on the main thread. If called from any other thread, throws an exception.
        """
        ...
    def undoItemText(self) -> typing.Text:
        """

        Returns:
            the text of the last item on the undo stack. Only works on the main thread. Can be useful for testing that undo/redo works.
        """
        ...
    def videoTrackItems(self, partialName):
        """
        Example: finds all video track items in a project with 30Sec in the name:
        trackItems = myProject.videoTrackItems('30Sec')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all video track items in a project.
            an array of hiero.core.TrackItem objects.
        """
        ...
    def videoTracks(self, partialName):
        """
        Example: finds all video tracks in a project with 30Sec in the name:
        tracks = myProject.videoTracks('30Sec')

        Args:
            partialName: optional string with partial name to match against. Will match if this string is anywhere in the name.

        Returns:
            all video tracks in a project.
            an array of hiero.core.VideoTrack objects.
        """
        ...
    def views(self) -> typing.List[typing.Text]:
        """
        Returns a list of this project's views.
        """
        ...
    ...

class ReformatState(Shiboken.Object):
    """
    Object representing a the reformatting settings for a track item.  This corresponds to the Nuke 'Reformat' node.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def boxForceShape(self) -> bool:
        """

        Returns:
            the box 'force shape' flag.
        """
        ...
    def boxPAR(self) -> double:
        """

        Returns:
            the box pixel aspect ratio.
        """
        ...
    def boxSize(self) -> QSize:
        """

        Returns:
            the box size.
        """
        ...
    def isNull(self, *args, **kwargs):
        """ """
        ...
    def originalResizeFlip(self) -> bool:
        """

        Returns:
            the original resize flip flag, which may be a deprecated value if it was loaded from an old project.
        """
        ...
    def originalResizeFlop(self) -> bool:
        """

        Returns:
            the original resize flop flag, which may be a deprecated value if it was loaded from an old project.
        """
        ...
    def originalResizeTurn(self) -> bool:
        """

        Returns:
            the original resize turn flag, which may be a deprecated value if it was loaded from an old project.
        """
        ...
    def originalType(self) -> typing.Text:
        """

        Returns:
            the original reformat type of the state, which may be a deprecated value if it was loaded from an old project.
        """
        ...
    def resizeCenter(self) -> bool:
        """

        Returns:
            the resize center flag.
        """
        ...
    def resizeFlip(self) -> bool:
        """

        Returns:
            the resize flip flag. Note: the flip option has been removed, this method should not be called.
        """
        ...
    def resizeFlop(self) -> bool:
        """

        Returns:
            the resize flop flag. Note: the flop option has been removed, this method should not be called.
        """
        ...
    def resizeTurn(self) -> bool:
        """

        Returns:
            the resize turn flag. Note: the turn option has been removed, this method should not be called.
        """
        ...
    def resizeType(self) -> typing.Text:
        """

        Returns:
            the resize type.
        """
        ...
    def scale(self) -> double:
        """

        Returns:
            the scaling factor. Note: the scale option has been removed, this method should not be called.
        """
        ...
    def setBoxForceShape(self, setBoxForceShape: bool):
        """
        sets the box 'force shape' flag if the reformat type is set to 'to box'.

        Args:
            setBoxForceShape: bool
        """
        ...
    def setBoxPAR(self, PAR: double):
        """
        sets the box pixel aspect ratio if the reformat type is set to 'to box'.

        Args:
            PAR: double
        """
        ...
    def setBoxSize(self, size: QSize):
        """
        sets the box size if the reformat type is set to 'to box'.

        Args:
            size: QSize
        """
        ...
    def setResizeCenter(self, center: bool):
        """
        sets the resize center flag on the track item.

        Args:
            center: bool
        """
        ...
    def setResizeFlip(self):
        """
        the flip option has been removed, this method exists only for compatibility reasons
        """
        ...
    def setResizeFlop(self):
        """
        the flop option has been removed, this method exists only for compatibility reasons
        """
        ...
    def setResizeTurn(self):
        """
        the turn option has been removed, this method exists only for compatibility reasons
        """
        ...
    def setResizeType(self, newResizeType: typing.Text):
        """
        sets the resize type of the state.

        Args:
            newResizeType: typing.Text
        """
        ...
    def setScale(self):
        """
        the scale option has been removed, this method exists only for compatibility reasons
        """
        ...
    def setType(self, newType: typing.Text):
        """
        sets the reformat type of the state.

        Args:
            newType: typing.Text
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def type(self) -> typing.Text:
        """

        Returns:
            the reformat type of the state.
        """
        ...
    ...

class RenderProgressObserver(Shiboken.Object):
    """
    Observer for tracking the progress of renders on the frame server.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def isNull(self, *args, **kwargs):
        """ """
        ...
    def updateProgress(self, *args, **kwargs):
        """
        RenderProgressObserver.updateProgress() -> called on progress of frame renders

        Args:
            progressList: typing.List[tuples containing (filePath, frame, progress)]
        """
        ...
    ...

class RenderTaskPreset(TaskPresetBase):
    """
    RenderTaskPreset is a specialization of the TaskPreset which contains parameters
    associated with generating Nuke render output.
    """

    def __init__(self, taskType, name, properties):
        """
        Initialise presets to default values
        """
        ...
    def addCustomResolveEntries(self, resolver):
        """
        RenderTaskPreset adds specialized tokens specific to this type of export, such as {ext} which returns the output format extnesion.

        Args:
            resolver: ResolveTable
        """
        ...
    def codecName(self):
        """ """
        ...
    def codecProperties(self):
        """ """
        ...
    def codecSettings(self):
        """ """
        ...
    def extension(self):
        """ """
        ...
    def summary(self):
        """ """
        ...
    ...

class ResolveTable:
    """
    Used to store name/value pairs that can be resolved in strings.
    Example: Assuming the resolve table has an item "{filename}" that resolves to example.mov,
    Then calling resolveTable.resolve(taskObject, "someprefix_{filename}") will return "someprefix_example.mov"
    To use, create an object, call addResolver on it with whatever key/value pairs you want, and then you can call resolve on the object to resolve a string.
    You can also merge two ResolveTable objects, replacing existing key's with those in the ResolveTable passed in.
    And you can use functions to do the resolve. These take one parameter, the task that the resolve is applying to.
    For an example of how to use this, see FnExporterBase.py.
    """

    CallbackItem: ...
    """
    """
    def __init__(self):
        """ """
        ...
    def addEntriesToExportStructureViewer(self, viewer):
        """ """
        ...
    def addResolver(self, name, description, resolver):
        """ """
        ...
    def duplicate(self):
        """ """
        ...
    def entries(self):
        """ """
        ...
    def entryCount(self):
        """

        Returns:
            the number of entries in this resolver.
        """
        ...
    def entryDescription(self, index):
        """

        Returns:
            a description of the item, which can be used to populate a dialog to the user when they are picking keywords.
        """
        ...
    def entryName(self, index):
        """
        self.entryCount(index) -> returns the name of the entry based on the index.
        """
        ...
    def merge(self, resolver):
        """ """
        ...
    def pathSensitiveReplace(self, initialString, findValue, replaceValue, isPath):
        """ """
        ...
    def resolve(self, task, value, isPath=False):
        """ """
        ...
    ...

class Sequence(SequenceBase):
    """
    Object for Sequences.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def addClip(self, clip, time, videoTrackIndex=0, audioTrackIndex=-1):
        """
        alias of _addClip
        Add a clip to a sequence, creating a TrackItem for each video/audio channel in the clip,
        adding them to the appropriate tracks and linking them together.  This has the same effect
        as dragging a clip from the Bin View to the Timeline View in the Hiero UI.

        Args:
            clip: the clip to add
            time: the in time for created track items
            videoTrackIndex: index of the video track to add items to if the clip has video
            audioTrackIndex: index of the audio track to start adding items to if the clip has audio

        Returns:
            list of created hiero.core.TrackItems
        """
        ...
    def addToNukeScript(self, script) -> None:
        """
        alias of _Sequence_addToNukeScript
        Add nodes representing this Sequence to the specified script.
        If there are no clips in the Sequence, nothing is added.

        Args:
            script: Nuke script object to add nodes to.
            includeRetimes: True/False include retimes
            retimeMethod: "Motion", "Blend", "Frame" - Knob setting for OFlow retime method
            additionalNodesCallback: callback to allow custom additional node per item function([Clip|TrackItem|Track|Sequence])
            offset: Optional, Global frame offset applied across whole script
            skipOffline: If True, offline clips are not included in the export
            mediaToSkip: typing.List[MediaSources which should be excluded from the export]
            disconnected: If True, tracks other than that containing the masterTrackItem are not connected to any inputs
            masterTrackItem: Used for controlling the script output if disconnected is specified
            includeAnnotations: If True, annotations are included in the exported script
            includeEffects: If True, soft effects are included in the exported script
            outputToFormat: Format to use for output.  If not specified, the sequence's own format is used.
        """
        ...
    def addTrack(self, track):
        """
        adds a video or audio track to the Sequence.

        Args:
            track: video or audio track to add
        """
        ...
    def audioTrack(self, index) -> AudioTrack:
        """

        Args:
            index: index of the audio track to return

        Returns:
            the audio track for the specified index.
        """
        ...
    def audioTracks(self) -> typing.Tuple[AudioTrack, ...]:
        """

        Returns:
            a tuple with all of the audio tracks.
        """
        ...
    def changeFramerateKeepFrames(self, toTimebase):
        """
        changes the timebase of the sequence, keeping frames of track items the same

        Args:
            toTimebase: timebase to change to
        """
        ...
    def changeFramerateKeepTimecodes(self, toTimebase, roundingMode):
        """
        changes the timebase of the sequence, keeping timecodes of track items the same, according to the specified rounding mode

        Args:
            toTimebase: timebase to change to
            roundingMode: rounding mode to use when converting timebases (hiero.core.TimeBase.kRoundNearest, hiero.core.TimeBase.kRound32Pulldown)
        """
        ...
    def clone(self) -> Sequence:
        """
        WARNING - DEPRECATED ( clone ): This method is deprecated and will not be present in future versions of the Python API.
        This method has been replaced by copy().

        Returns:
            a deep copy of this object.
        """
        ...
    def copy(self) -> Sequence:
        """

        Returns:
            a deep copy of this object.
        """
        ...
    def guid(self, *args, **kwargs):
        """ """
        ...
    def importTracks(self, filePath):
        """
        imports all of the tracks from the file specified by the filePath argument.

        Args:
            filePath: path to the file to import tracks from

        Returns:
            tracks: tuple of created tracks
        """
        ...
    def importTracksFromTimeBaseKeepFrames(self, filePath, srcTimebase):
        """
        imports all of the tracks from the file specified by the filePath argument using the specified timebase.

        Args:
            filePath: path to the file to import tracks from
            srcTimebase: timebase to use when reading the source file

        Returns:
            tracks: tuple of created tracks
        """
        ...
    def importTracksFromTimeBaseKeepTimecodes(
        self, filePath, srcTimebase, roundingMode
    ):
        """
        imports all of the tracks from the file specified by the filePath argument using the specified timebase.

        Args:
            filePath: path to the file to import tracks from
            srcTimebase: timebase to use when reading the source file
            roundingMode: rounding mode to use when converting timebases (hiero.core.TimeBase.kRoundNearest, hiero.core.TimeBase.kRound32Pulldown)

        Returns:
            tracks: tuple of created tracks
        """
        ...
    def items(self) -> typing.Tuple[VideoTrack and hiero.core.AudioTrack, ...]:
        """

        Returns:
            a tuple with all of the video tracks concatenated with all of the audio tracks. Can iterate over the video tracks first by using self.numVideoTracks. The audio tracks follow the video tracks in the tuple returned from this method.
        """
        ...
    def matchMedia(self, path):
        """
        match media using the current rule configuration in hiero.core.conformer().

        Args:
            path: path to the folder with the media to connect
        """
        ...
    def numAudioTracks(self) -> int:
        """

        Returns:
            number of audio tracks contained by this sequence.
        """
        ...
    def numVideoTracks(self) -> int:
        """

        Returns:
            number of video tracks contained by this sequence.
        """
        ...
    def reconnectMedia(self, path):
        """
        For each of the Clips used by this Sequence, reconnects media found in the specified path.

        Args:
            path: path containing media to reconnect to
        """
        ...
    def removeTrack(self, track):
        """
        removes the track from the Sequence.

        Args:
            track: track to remove (hiero.core.AudioTrack or VideoTrack object)
        """
        ...
    def replaceClips(self, path):
        """
        For each of the TrackItems in this sequence, replace it's Clip with media found in the specified path.

        Args:
            path: path containing media to replace with
        """
        ...
    def trackItemAt(self, time) -> TrackItem:
        """

        Args:
            time: frame to get the trackitem for

        Returns:
            the top-most video track item for the specified time that is enabled and has media.
        """
        ...
    def trackItemsAt(self, time, mediaType) -> typing.Tuple[TrackItem, ...]:
        """
        finds enabled track items for the specified time, ordered from top-track to bottom-track (or for audio, min channel to max channel).

        Args:
            time: frame to get the trackitems for
            mediaType: TrackItem.MediaType value specifying the media type of the track items to look for (defaults to kVideo)
        """
        ...
    def videoTrack(self, index) -> VideoTrack:
        """

        Args:
            index: index of the video track to return

        Returns:
            the video track for the specified index.
        """
        ...
    def videoTracks(self) -> typing.Tuple[VideoTrack, ...]:
        """

        Returns:
            a tuple with all of the video tracks.
        """
        ...
    ...

class SequenceBase(Shiboken.Object):
    """
    Base class for Sequence and Clip objects. Has some methods common to both of those objects. Most likely never used directly.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def addTag(self, tag) -> Tag:
        """
        adds a hiero.core.Tag object to the Clip or Sequence.

        Args:
            tag: the tag object to add
        """
        ...
    def addTagToRange(self, tag, inTime, outTime) -> Tag:
        """
        adds a hiero.core.Tag object to the specified range of the Clip or Sequence.

        Args:
            tag: the tag object to add
            inTime: the first time at which the tag is valid
            outTime: the last time at which the tag is valid
        """
        ...
    def binItem(self) -> BinItem:
        """

        Returns:
            the parent BinItem this Sequence or Clip belongs to, if any.
        """
        ...
    def clearInTime(self, t) -> None:
        """
        clear the 'in' point for the clip to Time t.
        """
        ...
    def clearOutTime(self, *args, **kwargs) -> None:
        """
        self.clearInTime(t) -> clear the 'out' point for the clip to Time t.
        """
        ...
    def clearRange(self, start, end, ripple):
        """
        Clears a time range out of the sequence; effectively a razor on any clips straddling the start and end, and a delete of everything else.

        Args:
            start: the start of the range to clear
            end: the end of the range to clear
            ripple: set to True to shift the remaining track items to the left
        """
        ...
    def disableSoftTrims(self):
        """
        disables soft trims on the object.
        """
        ...
    def dropFrame(self):
        """
        get whether sequence timecode is displayed in drop frame format
        """
        ...
    def duration(self):
        """

        Returns:
            the duration of the Clip or Sequence.
            int time value
        """
        ...
    def editFinished(self, trackItems):
        """
        this should be called after finishing editing the sequence to ensure that its internal state is updated properly and to send a signal to all objects listening to changes in this object (e.g. UI views).This function optionally takes a list of track items that is used to selectively rebuild only those sections of the timeline.This allows a faster update when the edited track items are known.

        Args:
            trackItems: optional, the track items to be updated
        """
        ...
    def enableSoftTrims(self, inTime, outTime):
        """
        enables soft trims on the object.

        Args:
            inTime: Time - soft trim in time
            outTime: Time - soft trim out time
        """
        ...
    def format(self) -> Format:
        """

        Returns:
            the output Format object for this Sequence or Clip.
        """
        ...
    def framerate(self) -> TimeBase:
        """

        Returns:
            the framerate of the Sequence or Clip.
        """
        ...
    def inTime(self) -> frame:
        """

        Returns:
            the 'in' point set on the clip.
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            False if this is a valid Sequence or Clip object, True otherwise.
        """
        ...
    def metadata(self) -> DataCollection:
        """

        Returns:
            a collection of metadata for the object.
        """
        ...
    def name(self) -> typing.Text:
        """

        Returns:
            the name of the object.
        """
        ...
    def outTime(self) -> frame:
        """

        Returns:
            the 'out' point set on the clip.
        """
        ...
    def posterFrame(self):
        """
        get the frame in the sequence used for thumbnails
        """
        ...
    def project(self) -> Project:
        """

        Returns:
            the Project object that this is attached to, or None if the object is not attached to a project.
        """
        ...
    def rawView(self) -> typing.Text:
        """

        Returns:
            a string representing the raw view of this sequence or clip.
        """
        ...
    def razorAt(self, time):
        """
        Creates razor cuts on all of the unlocked tracks for the parameter time(s).

        Args:
            time: if a single (integer) value, indicates the razor cut time; if a tuple or list of integer values, then the times to create multiple cuts at
        """
        ...
    def removeTag(self, tag):
        """
        removes the tag from the track.

        Args:
            tag: Tag
        """
        ...
    def setDropFrame(self, drop):
        """
        set whether sequence timecode is displayed in drop frame format
        """
        ...
    def setFormat(self, format):
        """
        set the format of the Sequence or Clip.
        Example: myClipSequence.setFormat( hiero.core.Format(2048, 400, 2.37, 'MyFormat') )

        Args:
            format: a hiero.core.Format object to set for the Clip or Sequence.
        """
        ...
    def setFramerate(self, framerate):
        """
        set the framerate of the Sequence or Clip.

        Args:
            framerate: framerate value to set
        """
        ...
    def setInOutEnabled(self, enable) -> None:
        """
        Enable/Disable the 'in' and 'out' points.
        """
        ...
    def setInTime(self, t) -> None:
        """
        set the 'in' point for the clip to Time t.
        This will also enable the In/Out lock.
        """
        ...
    def setName(self, string):
        """
        set the name of the object.

        Args:
            string: string new name
        """
        ...
    def setOutTime(self, t) -> None:
        """
        set the 'out' point for the clip to Time t.
        This will also enable the In/Out lock.
        """
        ...
    def setPosterFrame(self, frame):
        """
        set the frame in the sequence used for thumbnails
        """
        ...
    def setSoftTrimsInTime(self, inTime):
        """
        sets the in time for the soft trims. Note: this method does not enable soft trims if they are disabled.

        Args:
            inTime: in frame value for the soft trims
        """
        ...
    def setSoftTrimsOutTime(self, outTime):
        """
        sets the out time for the soft trims. Note: this method does not enable soft trims if they are disabled.

        Args:
            outTime: out frame value for the soft trims
        """
        ...
    def setTimecodeStart(self, time):
        """
        sets the value of the start timecode by frame. To convert times to frame values, use TimeCode.HMSFToFrames or TimeCode.stringToTime.

        Args:
            time: frame value to set the time code to
            timecodeValue: string of the format "hh:mm:ss:ff"
            hasDropFrames: True if the timecode includes drop frames, False otherwise

        Overloads:
            self.setTimecodeStart(timecodeValue, hasDropFrames) -> sets the value of the start timecode by formatted string, using the framerate of the Sequence or Clip as the time base. If just passing in a framerate, pass it in as an integer.
        """
        ...
    def softTrimsEnabled(self) -> bool:
        """

        Returns:
            True if soft trims are enabled, False otherwise.
        """
        ...
    def softTrimsInTime(self) -> frame:
        """

        Returns:
            the in time set for the soft trims.
        """
        ...
    def softTrimsOutTime(self) -> frame:
        """

        Returns:
            the out time set for the soft trims.
        """
        ...
    def tags(self) -> typing.Tuple[Tag, ...]:
        """

        Returns:
            a tuple of all of the tags applied to this object.
        """
        ...
    def thumbnail(self, frame, layer) -> QImage:
        """

        Args:
            frame: the frame to get the thumbnail for (defaults to 0)
            layer: the layer to get the thumbnail for (defaults to colour)

        Returns:
            a thumbnail of the frame specified as a QImage object.
        """
        ...
    def timecodeStart(self) -> frame:
        """

        Returns:
            the frame value of the start timecode. To convert this to a time code string, use TimeCode.timeToString.
        """
        ...
    def timelineOffset(self) -> frame:
        """

        Returns:
            the timeline offset value.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def writeAudioToFile(self, filepath, inTime, outTime):
        """
        Bounce down audio tracks and write to wav file at specified location. File will be created or overwritten.

        Args:
            filepath: the filepath of file to be written
            inTime: in point of the timeline to write
            outTime: out point of the timeline to write
        """
        ...
    ...

class Snapshot(Shiboken.Object):
    """
    Object representing a snapshot of a sequence or clip. Can be created with a Clip or a Sequence object.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def comment(self) -> typing.Text:
        """

        Returns:
            the comment set on this snapshot object.
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            True if the object is invalid, False otherwise.
        """
        ...
    def item(self) -> Clip or hiero.core.Sequence:
        """

        Returns:
            the clip or sequence stored with this snapshot.
        """
        ...
    def name(self) -> typing.Text:
        """

        Returns:
            the name of this snapshot.
        """
        ...
    def setComment(self, comment) -> typing.Text:
        """
        sets the comment on this snapshot object.

        Args:
            comment: string to set the comment to
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    ...

class SubTrackItem(TrackItemBase):
    """
    Base class for items that exist in sub-tracks, e.g. Annotation objects. This class should never be used directly.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def descString(self, *args, **kwargs):
        """ """
        ...
    def setTimelineIn(self, inTime):
        """
        sets the in point for this SubTrackItem. Note that this trims the duration of the SubTrackItem.

        Args:
            inTime: frame for the new in point
        """
        ...
    def setTimelineOut(self, outTime):
        """
        sets the out point for this SubTrackItem. Note that this trims the duration of the SubTrackItem.

        Args:
            outTime: frame for the new out point
        """
        ...
    def subTrackIndex(self):
        """
        get the index of the item's parent sub-track.

        Returns:
            int index, -1 if the item has not been added to a track
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    ...

class Tag(Shiboken.Object):
    """
    Object representing a tag in Hiero.
    Can be created with a string name, an optional path to an icon and an optional editable (in gui) boolean parameter
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def copy(self, *args, **kwargs):
        """ """
        ...
    def guid(self):
        """
        Return the Tag guid.

        Returns:
            object guid as string
        """
        ...
    def icon(self) -> typing.Text:
        """
        If the file doesn't exist, it will search for it in the plugin paths and the project folder and return the located file.

        Returns:
            the tags icon path.
        """
        ...
    def inTime(self) -> frame:
        """

        Returns:
            the in time of the tag.
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            True if the tag is invalid, False otherwise.
        """
        ...
    def metadata(self) -> DataCollection:
        """

        Returns:
            the clip's metadata.
        """
        ...
    def name(self) -> typing.Text:
        """

        Returns:
            the label of the tag.
        """
        ...
    def note(self) -> typing.Text:
        """

        Returns:
            the note on the tag.
        """
        ...
    def outTime(self) -> frame:
        """

        Returns:
            the out time of the tag.
        """
        ...
    def project(self) -> Project:
        """

        Returns:
            the Project object that this is attached to, or None if the object is not attached to a project.
        """
        ...
    def setIcon(self, note):
        """
        sets the icon on the tag.

        Args:
            note: path to icon file
        """
        ...
    def setInTime(self, time):
        """
        set the in time of the tag.

        Args:
            time: the in time
        """
        ...
    def setName(self, name):
        """
        sets the name label of the tag.

        Args:
            name: name to assign to tag
        """
        ...
    def setNote(self, note):
        """
        sets the note on the tag.

        Args:
            note: string note to assign to tag
        """
        ...
    def setOutTime(self, time):
        """
        set the out time of the tag.

        Args:
            time: the out time
        """
        ...
    def setVisible(self, visible):
        """
        sets the visiblity of the tag.

        Args:
            visible: visibility state
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def visible(self) -> bool:
        """
        gets the visiblity state of the tag.
        """
        ...
    ...

class TaskBase(core.Hiero.Python.ITask):
    """
    TaskBase is the base class from which all Tasks must derrive.
    """

    def __init__(self, initDictionary):
        """
        Initialise TaskBase Class

        Args:
            initDictionary: a TaskData dictionary which seeds the task with all initialization data
        """
        ...
    def addToQueue(self):
        """
        Called by the processor in order to add the Task to the ExportQueue
        If derrived classes impliment this function, this base function must be called.
        Populates name, description and destination fields in the export queue
        """
        ...
    def availableOutputHandles(self):
        """
        Get the available output handles, based on self._cutHandles.
        If outputting to sequence time, the start handle is clamped to prevent going into negative frames.
        """
        ...
    def clipName(self):
        """
        Returns the name of the clip in the bin
        """
        ...
    def deleteTemporaryFile(self, filePath):
        """
        Delete a file which is an artifact of the export, but should be removed after it's finished.
        Returns whether the file was successfully deleted.
        """
        ...
    def editId(self):
        """
        Returns a str containing the id of this edit.  See hiero.core.TrackItem.eventNumber().
        """
        ...
    def edlEditId(self):
        """
        Returns the id taken from the EDL used to create this edit, if there was one.
        """
        ...
    def fileName(self):
        """
        filename(self)
        Returns the source items filename if applicable
        """
        ...
    def filebase(self):
        """
        Returns the source items file path less extension if applicable
        """
        ...
    def fileext(self):
        """
        Returns the source items file extention if applicable
        """
        ...
    def filehead(self):
        """
        Returns the source filename excluding image sequence frame padding and extension, if applicable
        """
        ...
    def filepadding(self):
        """
        Returns the padding used in source file if an image sequence, empty string otherwise
        """
        ...
    def filepath(self):
        """
        Returns the source file path, if applicable
        """
        ...
    def finishTask(self):
        """
        Called once Task has signaled completion.  Sub-classes should call this base implementation.
        """
        ...
    def hasValidItem(self):
        """
        Get if the task is able to run on the item it was initialised with.
        """
        ...
    def ident(self):
        """
        Returns a string used for identifying the type of export task
        """
        ...
    def inputRange(self, ignoreHandles, ignoreRetimes, clampToSource):
        """
        Returns the input frame range (as a tuple) for this task if applicable

        Args:
            ignoreHandles: ignoreHandles - If True calculate Input Range excluding export handles
            ignoreRetimes: ignoreRetimes - If True calculate Input Range without taking retimes into account
            clampToSource: clampToSource - If True the input range will be clamped to the available media range
        """
        ...
    def isExportingItem(self, item):
        """
        Check if this task is already including an item in its export.
        Used for preventing duplicates when collating shots into a single script.
        """
        ...
    def name(self):
        """ """
        ...
    def outputHandles(self, ignoreRetimes=False):
        """
        Return a tuple of the in/out handles generated by this task.
        Handles may be cropped such as to prevent negative frame indexes.
        Note that both handles are positive, i.e. if 12 frames of handles are specified, this will return (12, 12)
        Sub-classes should reimplement _outputHandles() rather than this method.

        Returns:
            (in_handle, out_handle) tuple
        """
        ...
    def outputRange(self):
        """
        Returns the output file range (as tuple) for this task, if applicable.
        This default implementation works if the task was initialised with a Clip or TrackItem
        """
        ...
    def outputSequenceTime(self):
        """
        Test if the output frame range should be in sequence time rather than source. This
        only applies when a TrackItem is being exported.
        NOTE: This option has been disabled for the time being.  The code is left in place in case we want to re-enable it,
        but it is not available to users.
        """
        ...
    def postSequence(self):
        """
        preSequence()
        This function serves as hook for custom scripts to add functionality on completion of exporting the contents of the sequence
        """
        ...
    def preSequence(self):
        """
        This function serves as hook for custom scripts to add functionality before a task starts exporting anything with the sequence
        """
        ...
    def printState(self):
        """
        Print summary of the task parameters
        """
        ...
    def progress(self):
        """
        Returns a float value 0..1 to indicate progress of task.
        The task is considered complete once the progress is reported as 1.
        """
        ...
    def projectName(self):
        """
        Returns the name of the project, used for resolving the {project} token)
        """
        ...
    def projectRoot(self):
        """
        Returns the project root export path, used for resolving the {projectroot} token
        """
        ...
    def resolvePath(self, path):
        """
        Replace any recognized tokens in path with their current value.
        """
        ...
    def resolvedExportPath(self):
        """
        returns the output path with and tokens resolved
        """
        ...
    def sequenceName(self):
        """
        Returns the name of the sequence or parent sequence (if exporting a track item)
        """
        ...
    def setError(self, desc):
        """
        setError(self, desc) Call to set the state of this task to error, with a description of the error.
        If the task is synchronous, raise exception
        """
        ...
    def shotName(self):
        """
        Returns the Tasks track item name
        """
        ...
    def shotNameIndex(self):
        """
        Returns the index string for the shot, if there are multiple shots with the same name on the sequence.
        """
        ...
    def startTask(self):
        """
        Called when task reaches head of the export queue and begins execution
        """
        ...
    def supportedType(self, item):
        """
        Interface for defining what type of items a Task Supports.
        Return True to indicate
        @param item is of supported type
        """
        ...
    def taskStep(self):
        """
        Called every frame until task completes.
        Return True value to indicate task requires more steps.
        Return False value to indicate synchronous processing of the task is complete.
        The task may continue to run in the background.
        """
        ...
    def timeStamp(self):
        """
        Returns the datetime object from time of task creation
        """
        ...
    def timeStampString(self, localtime):
        """
        Convert a tuple or struct_time representing a time as returned by gmtime() or localtime() to a string formated YEAR/MONTH/DAY TIME.
        """
        ...
    def trackName(self):
        """
        Returns the name of the parent track
        """
        ...
    def updateItem(self, originalItem, localtime):
        """
        updateItem - This is called by the processor prior to taskStart, crucially on the main thread.
        This gives the task an opportunity to modify the original item on the main thread, rather than the clone.
        """
        ...
    def versionString(self):
        """
        Returns the version string used to resolve the {version} token
        """
        ...
    ...

class TaskData(__builtin__.dict):
    """
    TaskData is used as a seed for creating classes, wrapping up all of
    the parameters and making it simpler to add new ones
    """

    kCutHandles: ...
    """
    """

    kExportRoot: ...
    """
    """

    kExportTemplate: ...
    """
    """

    kItem: ...
    """
    """

    kMediaToSkip: ...
    """
    """

    kPreset: ...
    """
    """

    kPresetId: ...
    """
    """

    kProject: ...
    """
    """

    kResolver: ...
    """
    """

    kRetime: ...
    """
    """

    kShotNameIndex: ...
    """
    """

    kShotPath: ...
    """
    """

    kSkipOffline: ...
    """
    """

    kStartFrame: ...
    """
    """

    kStartFrameSource: ...
    """
    """

    kSubmission: ...
    """
    """

    kVersion: ...
    """
    """
    def __init__(
        self,
        preset,
        item,
        exportRoot,
        shotPath,
        version,
        exportTemplate,
        project,
        cutHandles=None,
        resolver=None,
        retime=False,
        startFrame=None,
        startFrameSource=None,
        submission=None,
        skipOffline=True,
        presetId=None,
        shotNameIndex="",
        mediaToSkip=[],
    ):
        """ """
        ...
    ...

class TaskGroup(core.Hiero.Python.ITask):
    """
    TaskGroup is a Task which maintains a list of child Tasks.
    """

    def __init__(self):
        """ """
        ...
    def addChild(self, child):
        """
        Add a child to the list.
        """
        ...
    def addToQueue(self):
        """ """
        ...
    def children(self):
        """
        Get the TaskGroup's children.
        """
        ...
    def getLeafTasks(self):
        """
        Get a list of all leaf tasks recursively, i.e. those with no child tasks.
        """
        ...
    def progress(self):
        """
        Get the group progress.  Returns a value based on the progress of child tasks.
        """
        ...
    ...

class TaskPreset(TaskPresetBase):
    """
    Deprecated - Use TaskPresetBase
    """

    def __init__(self, parentType, presetName):
        """ """
        ...
    ...

class TaskPresetBase(core.Hiero.Python.ITaskPreset):
    """
    TaskPreset is the base class from which all Task Presets must derrive
    The purpose of a Task Preset is to store and data which must be serialized to file
    and shared between the Task and TaskUI user interface component
    """

    def __eq__(self, other):
        """
        Implement equal operator. This will compare the TaskPreset name
        and it's properties. This method will ignore difference between
        lists an tuples, since the same TaskPreset can be copied and
        the only change existing is a list instead of a tuple.
        """
        ...
    def __exportTemplate__eq__(self, selfExportTemplate, otherExportTemplate):
        """
        __eq__ method for the export template property. The export template is
        a list (or tuple) of pairs with format [ path , export template ], and
        these pairs can be a list or a tuple as well. This method compares two
        exportTemplates ignoring the difference between list and tuples, so
        (path1,export1) , (path2,export2)) == [[path1,export1] , [path2,export2]]
        And the order of the pairs is ignored as well. A unique key is defined to
        order the list with the 'path', 'export template type' and 'file type'. So
        ((path1,export1),(path2,export2)) == ((path2,export2),(path1,export1))
        """
        ...
    def __init__(self, parentType, presetName):
        """
        Initialise Exporter Preset Base Class

        Args:
            parentType: Task type to which this preset object corresponds
            presetName: Name of preset
        """
        ...
    def __ne__(self, other):
        """
        Implements not equal operator using self.__eq__
        """
        ...
    def __repr__(self):
        """ """
        ...
    def addCustomResolveEntries(self, resolver):
        """
        Impliment this function on custom export tasks to add resolve entries specific to that class.

        Args:
            resolver: ResolveTable
        """
        ...
    def addDefaultResolveEntries(self, resolver):
        """
        Create resolve entries for default resolve tokens shared by all task types.

        Args:
            resolver: ResolveTable
        """
        ...
    def addUserResolveEntries(self, resolver):
        """
        Override this function to add user specific resolve tokens.
        When adding task specific tokens in derrived classes use TaskBase.addCustomResolveEntries().
        This is reserved for users to extend the available tokens.

        Args:
            resolver: ResolveTable
        """
        ...
    def createResolver(self):
        """
        Instantiate ResolveTable, add default and custom resolve entries
        return ResolveTable object
        """
        ...
    def getResolveEntryCount(self, arg1: typing.Literal["self) (DEPRICATED"]):
        """
        Return the number of resolve entries in the resolve table
        """
        ...
    def ident(self):
        """
        Returns a string used for identifying the type of task
        """
        ...
    def initialiseCallbacks(self, exportStructure):
        """
        When parent ExportStructure is opened in the ui, initialise is called
        for each preset. Register any callbacks here.
        """
        ...
    def markedForDeletion(self):
        """
        Return True if this preset is marked for deletion. Delete will be performed at save
        """
        ...
    def name(self):
        """
        Return Preset Name
        """
        ...
    def nonPersistentProperties(self) -> dict:
        """
        Return the dictionary which contains properties not persisted within the preset.
        Properties which are only relevant during a single session.
        """
        ...
    def parentType(self):
        """
        Returns a the parent Task type for this TaskPreset.

        Returns:
            TaskPreet class type
        """
        ...
    def project(self):
        """
        Return the Project with which this preset is associated. If this is a local preset returns None
        """
        ...
    def properties(self) -> dict:
        """
        Return the dictionary which is used to persist data within this preset.
        """
        ...
    def readOnly(self):
        """
        Return the read only flag for this preset
        """
        ...
    def resolveEntryCount(self):
        """
        Return the number of resolve entries in the resolve table
        """
        ...
    def resolveEntryDescription(self, index):
        """
        return ResolveEntry description by index
        """
        ...
    def resolveEntryName(self, index):
        """
        return ResolveEntry name/token by index
        """
        ...
    def savePath(self):
        """
        Return the path from which this preset was loaded. Will return None if this preset was not loaded from file
        """
        ...
    def setCompsToRender(self, comps):
        """
        Set the list of comps to render.
        """
        ...
    def setCompsToSkip(self, comps):
        """
        Set the list of comps to skip.
        """
        ...
    def setMarkedForDeletion(self, markedForDeletion=True):
        """
        Set this preset as marked for deletion. Delete will be performed at save
        """
        ...
    def setName(self, name):
        """
        Set Preset Name
        """
        ...
    def setProject(self, project):
        """
        Set the Project() object which this preset is associated
        """
        ...
    def setReadOnly(self, readOnly):
        """
        Set Read Only flag on preset, not enforced internally
        """
        ...
    def setSavePath(self, path):
        """
        Set the save path of the preset in order to ensure it is saved to the path it was loaded from
        """
        ...
    def setSkipOffline(self, skip):
        """
        skipOffline(bool)
        Set flag to skip offline TrackItems during export.
        @param bool
        """
        ...
    def skipOffline(self) -> bool:
        """
        Returns True if flag has been set to skip any offline TrackItems
        """
        ...
    def summary(self):
        """
        Called by Hiero to get a summary of the preset settings as a string.
        """
        ...
    ...

class TaskRegistry(core.Hiero.Python.IExporterRegistry):
    def __init__(self):
        """ """
        ...
    def addDefaultPresets(self, overwrite=False):
        """ """
        ...
    def addPresetToProjectExportHistory(self, project, preset):
        """
        Add a preset to the export history for a project.
        """
        ...
    def addProcessorPreset(self, name, preset):
        """
        Register Processor Preset Instance
        """
        ...
    def addSubmission(self, name, submissionClass):
        """ """
        ...
    def assignPresetToProject(self, preset, project):
        """
        Assign preset to project and ensure name is unique within project. Project may be None in which case preset will be assigned 'local'
        """
        ...
    def copyAndAddProcessorPreset(self, preset):
        """ """
        ...
    def copyAndAddProjectPreset(self, preset, project):
        """
        Duplicate a preset and assign it to a project imediately to prevent name clashes
        """
        ...
    def copyPreset(self, preset):
        """
        Create a copy of a preset.  The copy is not added to the registry.
        """
        ...
    def createAndAddProcessorPreset(self, name, typeTemplate):
        """ """
        ...
    def createAndExecuteProcessor(
        self, preset, items, submissionName=None, synchronous=False
    ):
        """
        Instantiate the Processor associated with preset and startProcessing items
        """
        ...
    def createProcessor(self, preset, submissionName=None, synchronous=False):
        """
        Create the processor for an export and return it. This doesn't start
        the export.
        """
        ...
    def createTaskFromPreset(self, preset, initDictionary):
        """ """
        ...
    def discardPresetChanges(self, project):
        """ """
        ...
    def findPresetInProjectExportHistory(self, project, presetId):
        """
        Attempt to find a preset in a project's export history.
        """
        ...
    def getPresetId(self, preset):
        """
        Get the id (hash) of the given preset.
        """
        ...
    def getPresetType(self, ident):
        """ """
        ...
    def getProcessor(self, index):
        """ """
        ...
    def getProcessorFromPreset(self, presetName):
        """ """
        ...
    def getProcessorPreset(self, index):
        """ """
        ...
    def isNukeShotExportPreset(self, preset):
        """
        Check if a preset is valid for Nuke shot export.  To be considered valid, the preset must contain
        a NukeShotExporter and a NukeRenderTask (write node).
        """
        ...
    def isOutputResolutionValid(self, preset, items):
        """
        Implements IExporterRegistry.isOutputResolutionValid.
        """
        ...
    def isSingleSocketAllowed(self):
        """
        Return whether or not single socket exports are allowed.
        """
        ...
    def loadPresets(self, path):
        """
        Load all xml presets within specified path and register
        """
        ...
    def localPresets(self):
        """
        Returns a list of preset names NOT associated with the specified project
        """
        ...
    def localPresetsChanged(self):
        """
        Check if the local task presets have changed since startPresetChanges() was called.
        """
        ...
    def nukeShotExportPresets(self, project):
        """
        Get a list of presets which can export shots as Nuke scripts.
        Includes local presets and those in the project.
        """
        ...
    def numProcessorPresets(self):
        """
        Return the total number of Processor preset instances registered
        """
        ...
    def numProcessors(self):
        """
        Return the number or processors in the Registry
        """
        ...
    def numTasks(self):
        """
        Returns the number of Tasks Registered
        """
        ...
    def presetFromXml(self, xml, register=True):
        """
        Deserialize preset from xml string.
        Requires derived TaskPreset classes to be registered.
        """
        ...
    def presetToXml(self, preset):
        """
        Serialise a TaskPreset to XML and return as string
        """
        ...
    def presetTypeFromIdent(self, ident):
        """
        Resolve preset ident string to Preset class type
        """
        ...
    def presetsSubDirectory(self):
        """ """
        ...
    def processorByIndex(self, index):
        """
        Returns a processor by index
        """
        ...
    def processorFromPreset(self, presetName):
        """
        Return type of task from preset name
        """
        ...
    def processorName(self, index):
        """
        Returns a Processor name by index
        """
        ...
    def processorPresetByIndex(self, index):
        """
        Return instance of TaskPreset Object
        """
        ...
    def processorPresetByName(self, name, project=None):
        """
        Returns the preset with specified name associated with project. If project is None preset will be searched for in local presets
        """
        ...
    def processorPresetName(self, index):
        """
        Return the name of Processor preset by index
        """
        ...
    def processorPresetNames(self):
        """
        Returns a tuple of Processor Preset names
        """
        ...
    def projectDuplicated(self, project, newProject):
        """
        Called on project clone to duplicate the associated project presets
        """
        ...
    def projectExportHistoryXml(self, project):
        """
        Get the project export history as a list of xml fragments. Use the xml to avoid problems with reference
        counting the preset objects when calling from C++.
        """
        ...
    def projectPresets(self, project):
        """
        Returns a list of preset names associated with the specified project
        """
        ...
    def projectPresetsChanged(self, project):
        """
        Check if the task presets for the given project have changed since startPresetChanges(project) was called.
        """
        ...
    def projectUnloaded(self, project):
        """
        Called on project unload to remove presets associated with project
        """
        ...
    def registerPreset(self, parentType, preset):
        """
        Register a preset instance and association with parentType
        """
        ...
    def registerProcessor(self, preset, processor):
        """
        Register the association between a Processor and ProcessorPreset
        """
        ...
    def registerTask(self, preset, task):
        """
        Register the association between a Task and TaskPreset
        """
        ...
    def removeProcessorPreset(self, preset):
        """
        Remove Processor preset from registry
        """
        ...
    def renameProcessorPreset(self, preset, newName):
        """
        Validate and update name of Processor Preset
        """
        ...
    def restoreProjectExportHistoryXml(self, project, presetsXml):
        """
        Set the project export history as a list of xml fragments. Use the xml to avoid problems with reference
        counting the preset objects when calling from C++.
        """
        ...
    def revertDefaultPresets(self):
        """ """
        ...
    def savePresets(self, path):
        """
        Save all registered presets, as xml, to path specified.
        """
        ...
    def setDefaultPresets(self, defaultPresets):
        """ """
        ...
    def startPresetChanges(self, project):
        """ """
        ...
    def submissionByName(self, name):
        """ """
        ...
    def submissionChanged(self, submissionName):
        """ """
        ...
    def submissionNames(self):
        """ """
        ...
    def taskName(self, index):
        """
        Returns a Task name by Index
        """
        ...
    ...

class TimeBase(Shiboken.Object):
    """
    Helper object that wraps up time bases (or frame rates). Stores values internally as integer ratios, as opposed to floating point values.

    Can be initialised with an int, float, or str.  In addition, you can construct a TimeBase using TimeBase.fromRational(numerator, denominator), or use the predefined TimeBase values, for example TimeBase.k30NTSC.
    """

    RoundingMode: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    k24: ... = 24
    """
    """

    k24NTSC: ... = 23.98
    """
    """

    k25: ... = 25
    """
    """

    k30: ... = 30
    """
    """

    k30NTSC: ... = 29.97
    """
    """

    k50: ... = 50
    """
    """

    k60: ... = 60
    """
    """

    k60NTSC: ... = 59.94
    """
    """

    kRound32Pulldown: ...
    """
    """

    kRoundNearest: ... = core.Hiero.Python.TimeBase.RoundingMode.kRoundNearest
    """
    """
    @staticmethod
    def convert(t, arg2: typing.Literal["from"], to) -> int:
        """
        If either of the time bases is invalid, this method returns the t parameter unchanged.

        Args:
            t: the time (frame) to convert from one rate to another
            param2: the time base to convert from
            to: the time base to convert to

        Returns:
            the time specified by the first parameter converted from from parameter's time base into the to parameter's time base.
        """
        ...
    @staticmethod
    def fromRational(numerator, denominator):
        """
        creates a new TimeBase object from the given parameters.
        For example:
          newTimeBase = TimeBase.fromRational(25, 1)
          newTimeBase = TimeBase.fromRational(30000, 1001)
        """
        ...
    @staticmethod
    def fromString(*args, **kwargs) -> TimeBase:
        """
        TimeBase.fromString(str) -> deprecated; a TimeBase can now be constructed directly from a str, e.g. TimeBase('30').  Construct a TimeBase object using a str as input.
        For example:
          newTimeBase = TimeBase.fromString('25')
          newTimeBase = TimeBase.fromString('30000 / 1001')
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def convertTime(self, t, toRate) -> int:
        """
        If either of the time bases is invalid, this method returns the t parameter unchanged.

        Args:
            t: the time (frame) to convert from one rate to another
            toRate: the new time time to convert to

        Returns:
            the time specified by the first parameter converted from this object's time base into the second parameter's time base.
        """
        ...
    def denominator(self) -> int:
        """
        gets the denominator of the time base.
        """
        ...
    def isNTSC(self) -> bool:
        """

        Returns:
            True if the time base is NTSC (24*1000/1001, 30*1000/1001, or 60*1000/1001).
        """
        ...
    def isValid(self) -> bool:
        """

        Returns:
            True if the denominator of the time base is non-zero.
        """
        ...
    def numerator(self) -> int:
        """
        gets the numerator of the time base.
        """
        ...
    def supportsDropFrames(self) -> bool:
        """

        Returns:
            True if the time base supports drop frames (only true for 30 or 60 fps NTSC currently).
        """
        ...
    def toFloat(self) -> float:
        """

        Returns:
            the time base value expressed as a floating point value.
        """
        ...
    def toInt(self) -> int:
        """

        Returns:
            the time base value, rounded to the nearest integer.
        """
        ...
    def toRational(self) -> typing.Tuple[int, ...]:
        """

        Returns:
            a tuple of the numerator and the denominator of the time base.
        """
        ...
    def toRationalString(self) -> typing.Text:
        """

        Returns:
            a string containing the time base expressed as a ratio, for example '30000/1001'.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a string containing the time base as a floating point number. Equivalent to str(object).
        """
        ...
    ...

class Timecode(Shiboken.Object):
    """
    Helper module to convert back and forth between (frames and time bases) and time code values.
    """

    DisplayType: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kDisplayDropFrameTimecode: ...
    """
    """

    kDisplayFrames: ... = core.Hiero.Python.Timecode.DisplayType.kDisplayFrames
    """
    """

    kDisplayTimecode: ...
    """
    """
    @staticmethod
    def HMSFToFrames(timeBase, dropFrame, h, m, s, f) -> frame:
        """
        takes a timebase, whether or not it's got drop frames, an hour, minute, second and frame, and returns a time value.

        Args:
            timeBase: the time base to use
            dropFrames: True if you want drop frames taken into account
            h: hour to use
            m: minute to use
            s: second to use
            f: frame to use
        """
        ...
    @staticmethod
    def displayTypeFromString(s):
        """
        guesses the display type from a timecode string. This can be inferred from separators (though not guaranteed) or if no separators than just display as frames.
        Example:
        displayType = Timecode.displayTypeFromString('01:00:00:00')
        print displayType # prints out hiero.core.Timecode.kDisplayTimecode
        displayType = Timecode.displayTypeFromString('01:00:00;00')
        print displayType # prints out hiero.core.Timecode.kDisplayDropFrameTimecode, because of the semi-colon (;)

        Args:
            s: string to detect time code format from

        Returns:
            hiero.core.Timecode.DisplayType enumeration
        """
        ...
    @staticmethod
    def framesToHMSF(
        time, timeBase, dropFrames
    ) -> typing.Tuple[hour, minute, second, frame]:
        """
        takes a time, timebase and whether or not it's got drop frames, and returns a tuple of the hour, minute, second and frame.
        Example:
        hour, minute, second, frame = Timecode.framesToHMSF(0, timeBase, True)

        Args:
            time: the frame you want to get the time code for
            timeBase: the time base to use
            dropFrames: True if you want drop frames taken into account
        """
        ...
    @staticmethod
    def stringToTime(s, timeBase, displayType, timecodeOffset) -> tuple:
        """

        Args:
            s: the string to convert
            timeBase: the time base to use
            displayType: how the string was formatted; can be (Timecode.kDisplayTimeCode, Timecode.kDisplayDropFrameTimecode, or Time.kDisplayFrames)
            timecodeOffset: an offset to apply before converting to a time code string

        Returns:
            a tuple of hour, minute, second, frame values.
        """
        ...
    @staticmethod
    def timeToString(
        time, timeBase, displayType, includeSign, timecodeOffset
    ) -> typing.Text:
        """

        Args:
            time: the frame to use
            timeBase: the time base to use
            displayType: how to format the returned string (Timecode.kDisplayTimeCode, Timecode.kDisplayDropFrameTimecode, or Time.kDisplayFrames)
            includeSign: if True, a '+' will be put in front of positive time codes
            timecodeOffset: an offset to apply before converting to a time code string

        Returns:
            a string formatted as a time code.
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class TrackBase(Shiboken.Object):
    """
    Base class for VideoTrack and AudioTrack objects. This class should never be used directly.

    Flags for controlling behavior when removing items, these can be combined with bitwise or:
     TrackBase.eRemoveLinkedItems: removing an item will also remove any items it is linked to
     TrackBase.eDontRemoveLinkedItems: removing an item will not remove linked items
     TrackBase.eDontCollapseSubTracks: removing a sub-track item will not cause empty sub-tracks to be removed
    """

    RemoveItemOptions: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    eDontCollapseSubTracks: ...
    """
    """

    eDontRemoveLinkedItems: ...
    """
    """

    eRemoveLinkedItems: ...
    """
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def addItem(self, item) -> TrackItem:
        """
        deprecated; use addTrackItem instead. Adds a track item to this track. Throws an exception if the item overlaps any existing items on the track.

        Args:
            item: the hiero.core.TrackItem to add to this track
        """
        ...
    def addTag(self, tag) -> Tag:
        """
        adds the specified tag to the Track.

        Args:
            tag: Tag object to apply to the track
        """
        ...
    def addTransition(self, transition) -> Transition:
        """
        adds a transition to the timeline for the track.  Can only be called when the track has been added to a Sequence.
        Note that a transition can only be added to a single track. Calling this function with a Transition object which already belongs to a Track will result in an error.
        Transition items can be reomoved from a track using the removeTransition function.

        Args:
            transition: the hiero.core.Transition to add to this track
        """
        ...
    def clearRange(self, start, end, ripple):
        """
        Clears a time range out of the track; effectively a razor on any clips straddling the start and end, and a delete of everything else.

        Args:
            start: the start of the range to clear
            end: the end of the range to clear
            ripple: set to True to shift the remaining track items to the left
        """
        ...
    def guid(self, *args, **kwargs):
        """ """
        ...
    def isEnabled(self) -> bool:
        """

        Returns:
            True if the Track object is enabled.
        """
        ...
    def isLocked(self) -> bool:
        """

        Returns:
            True if the Track object is locked.
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            True if the Track object is invalid.
        """
        ...
    def metadata(self) -> DataCollection:
        """

        Returns:
            the metadata for this Track.
        """
        ...
    def name(self) -> bytes:
        """

        Returns:
            the name of the track. Identical to calling trackName().
        """
        ...
    def numItems(self) -> int:
        """

        Returns:
            the number of items in this track.
        """
        ...
    def numTransitions(self) -> int:
        """

        Returns:
            the number of transitions in this track.
        """
        ...
    def project(self) -> Project:
        """

        Returns:
            the Project object that this item is attached to or None if the object is not attached to a project.
        """
        ...
    def razorAt(self, time):
        """
        Creates razor cuts on a track for the parameter time(s).

        Args:
            time: if a single (integer) value, indicates the razor cut time; if a tuple or list of integer values, then the times to create multiple cuts at
        """
        ...
    def removeItem(self, trackItem, option=eRemoveLinkedItems):
        """
        removes a track item from this track.

        Args:
            trackItem: the hiero.core.TrackItem to remove from this track
            option: options controlling the remove behavior. By default linked items are also removed. Note that if linked effects are not removed, this will put them in an invalid state.
        """
        ...
    def removeTag(self, tag):
        """
        removes the tag from the track.

        Args:
            tag: tag
        """
        ...
    def removeTransition(self, transition):
        """
        removes a transition from the timeline of this track.

        Args:
            transition: the hiero.core.Transition to remove from this track's timeline
        """
        ...
    def setEnabled(self):
        """
        enables or disables the Track.
        """
        ...
    def setLocked(self) -> bool:
        """
        locks or unlocks the Track.
        """
        ...
    def setName(self, string: typing.Text):
        """
        Sets the name of a track.

        Args:
            string: typing.Text
        """
        ...
    def tags(self) -> typing.Tuple[Tag, ...]:
        """

        Returns:
            a tuple of all of the tags applied to this object.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def trackIndex(self, *args, **kwargs):
        """ """
        ...
    def trackName(self) -> typing.Text:
        """

        Returns:
            the name of the track. Identical to calling name().
        """
        ...
    def transitions(self) -> typing.Tuple[Transition, ...]:
        """

        Returns:
            a tuple of all of the transitions applied to this track object.
        """
        ...
    ...

class TrackItem(TrackItemBase):
    """
    Represents a specific item on a Track. Can also be created using the createTrackItem method on VideoTrack and AudioTrack objects. Can be converted to a MediaSource object if isSource() returns True, or a Sequence object if isSequence() returns True.
    Note that the version functions don't cause a scan of any directories for other versions of media and will only skip to versions that have already been discovered. For an example of how to do that, see Plugins/site-packages/hiero/ui/ScanForVersions.py.
    For an example of how to implement custom versioning scheme, see Plugins/site-packages/hiero/core/versioning_example.py.
    """

    MediaType: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kAudio: ... = core.Hiero.Python.TrackItem.MediaType.kAudio
    """
    """

    kUnknown: ... = core.Hiero.Python.TrackItem.MediaType.kUnknown
    """
    """

    kVideo: ... = core.Hiero.Python.TrackItem.MediaType.kVideo
    """
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def addTag(self, tag) -> Tag:
        """
        adds a new tag to the track item.

        Args:
            tag: tag
        """
        ...
    def addToNukeScript(
        self,
        arg2: typing.Literal["script="],
        firstFrame=None,
        additionalNodes=[],
        additionalNodesCallback=None,
        includeRetimes=False,
        retimeMethod=None,
        startHandle=None,
        endHandle=None,
        colourTransform=None,
        offset=0,
        nodeLabel=None,
        includeAnnotations=False,
        includeEffects=True,
        outputToSequenceFormat=False,
    ):
        """
        alias of _TrackItem_addToNukeScript
        This is a variation on the Clip.addToNukeScript() method that remaps the
        Read frame range to the range of the this TrackItem rather than the Clip's
        range. TrackItem retimes and reverses are applied via Retime and OFlow nodes
        if needed. The additionalNodes parameter takes a list of nodes to add before
        the source material is shifted to the TrackItem timeline time and trimmed to
        black outside of the cut. This means timing can be set in the original
        source range and adding channels, etc won't affect frames outside the cut
        length.

        Args:
            retimeMethod: "Motion", "Blend", "Frame" - Knob setting for OFlow retime method
            offset: Optional, Global frame offset applied across whole script
        """
        ...
    def currentVersion(self) -> Version:
        """

        Returns:
            a version object for the current version set on this track item.
        """
        ...
    def eventNumber(self):
        """
        Get the event number of this track item on it's Sequence.

        Returns:
            integer event number
        """
        ...
    def getAvailableOcioColourTransforms(self, *args, **kwargs) -> typing.Text:
        """
        self.    getAvailableOcioColourTransforms() -> returns colour transform for the media source.
        """
        ...
    def handleInLength(self) -> frames:
        """

        Returns:
            the length of the track item's in handle.
        """
        ...
    def handleInTime(self) -> frames:
        """

        Returns:
            the track item's in handle time.
        """
        ...
    def handleOutLength(self) -> frames:
        """

        Returns:
            the length of the track item's out handle.
        """
        ...
    def handleOutTime(self) -> frames:
        """

        Returns:
            the track item's out handle time.
        """
        ...
    def inTransition(self) -> Transition:
        """

        Returns:
            the in transition for this track item.
        """
        ...
    def isMediaPresent(self, *args, **kwargs) -> bool:
        """
        self.isMediaPreset() -> returns True if the track item represent a media source and if the media source is currently available in Hiero (and not offline). Returns False otherwise.
        """
        ...
    def isSequence(self) -> bool:
        """

        Returns:
            True if the track item represents a sequence. If it does, you can create a new hiero.core.Sequence object with this track item.
        """
        ...
    def isSource(self) -> bool:
        """

        Returns:
            True if the track item represents a media source. If it does, you can create a new hiero.core.MediaSource object with this track item.
        """
        ...
    def link(self, trackItem):
        """
        Links track item with another track item. Both track items must point to the same source.

        Args:
            trackItem: track item to link to
        """
        ...
    def mapSourceToTimeline(self, *args, **kwargs):
        """
        self.mapTimelineToSource(time) -> Map from the track item's source time to timeline time.

        Args:
            time: time to map

        Returns:
            mapped time
        """
        ...
    def mapTimelineToSource(self, time):
        """
        Map from timeline time to the track item's source time.

        Args:
            time: time to map

        Returns:
            mapped time
        """
        ...
    def maxVersion(self) -> Version:
        """

        Returns:
            the highest discovered version on this track item.
        """
        ...
    def mediaType(self) -> MediaType:
        """

        Returns:
            media type for the track item.
        """
        ...
    def metadata(self) -> DataCollection:
        """

        Returns:
            the metadata for the track item.
        """
        ...
    def minVersion(self) -> Version:
        """

        Returns:
            the lowest version on this track item.
        """
        ...
    def name(self) -> bytes:
        """

        Returns:
            the track item's name.
        """
        ...
    def nextVersion(self) -> Version:
        """

        Returns:
            the next highest available version on this track item that the application has discovered.
        """
        ...
    def numVersions(self) -> int:
        """

        Returns:
            the total number of versions on this track item currently (nothing to do with the maximum or minimum version number).
        """
        ...
    def outTransition(self) -> Transition:
        """

        Returns:
            the out transition for this track item.
        """
        ...
    def playbackSpeed(self) -> double:
        """

        Returns:
            the playback speed of this track item.
        """
        ...
    def prevVersion(self) -> Version:
        """

        Returns:
            the next lowest version on this track item that the application has discovered.
        """
        ...
    def reconnectMedia(self, path):
        """
        Reconnects media for the Clip used by the TrackItem, using the specified path.

        Args:
            path: path containing media to reconnect to
        """
        ...
    def reformatState(self) -> ReformatState:
        """

        Returns:
            the reformat state for the track item.
        """
        ...
    def removeTag(self, tag):
        """
        removes the tag from the track item.

        Args:
            tag: Tag
        """
        ...
    def replaceClips(self, path):
        """
        Find a new Clip from the specified path, and replace the TrackItem's existing Clip with it.

        Args:
            path: path containing media to replace with
        """
        ...
    def setCameraColourTransform(self, colourTransform):
        """
        sets the camera colour transform for the source media.

        Args:
            colourTransform: Colour transform name
        """
        ...
    def setCurrentVersion(self, version):
        """
        sets the current version (by object) on this track item. Note that this method doesn't check that the versioned media source exists on disk.

        Args:
            version: Version
        """
        ...
    def setCurrentVersionIndex(self, index) -> Version:
        """
        sets the current version on this track item and returns the new version object. Creates a new version if there wasn't one before, but doesn't check that the versioned media source exists on disk.
        WARNING - DEPRECATED ( setCurrentVersionIndex ): This method is deprecated and will not be present in future versions of the Python API.
        Version indices are no longer unique identifiers and should not be used as such. Please use TrackItem.setActiveVersion() instead.

        Args:
            index: the integer index to set the current version on this track item to
        """
        ...
    def setName(self, name: bytes) -> None:
        """
        sets the name of the track item.

        Args:
            name: the value to set the track name to
        """
        ...
    def setPlaybackSpeed(self, newSpeed):
        """
        sets the playback speed of this track item.

        Args:
            newSpeed: double
        """
        ...
    def setSource(self, clip, trackIndex=0):
        """
        sets the source Clip for this TrackItem.
        If the TrackItem is not already in a Track, the duration will be set to the Clip's duration.

        Args:
            clip: the hiero.core.Clip object to set as the source for this track item
            trackIndex: optional track index, for instance if you are adding an audio Clip and want to use its second audio track

        Returns:
            the hiero.core.Clip object passed in
        """
        ...
    def setSourceIn(self, time: float) -> None:
        """
        sets the source in for the track item. This will shrink or grow the duration.

        Args:
            time: frame value
        """
        ...
    def setSourceMediaColourTransform(self, colourTransform):
        """
        sets the input colour transform for the source media.

        Args:
            colourTransform: Colour transform name
        """
        ...
    def setSourceOut(self, time: float) -> None:
        """
        sets the source out for the track item. This will shrink or grow the duration.
        Note that this value depends on speed. For exact editing, edit speed instead in order to avoid rounding errors.

        Args:
            time: frame value
        """
        ...
    def setTimelineIn(self, inTime: int) -> None:
        """
        sets the timeline in value. Shrinks or grows the timeline duration, as appropriate.

        Args:
            inTime: frame value
        """
        ...
    def setTimelineOut(self, outTime: int) -> None:
        """
        sets the timeline out value. Shrinks or grows the timeline duration, as appropriate.

        Args:
            outTime: frame value
        """
        ...
    def setTimes(self, timelineIn: int, timelineOut: int, sourceIn: float, sourceOut: float) -> None:
        """
        sets the timeline and source times for the track item.

        Args:
            timelineIn: timeline in frame
            timelineOut: timeline out frame
            sourceIn: source in frame
            sourceOut: source out frame
        """
        ...
    def source(self):
        """
        depending on the underlying type of the track item, returns a hiero.core.Clip object, a hiero.core.Sequence object or a hiero.core.MediaSource object.

        Returns:
            a hiero.core.Clip object, a hiero.core.Sequence object or a hiero.core.MediaSource object
        """
        ...
    def sourceDuration(self) -> frames:
        """
        Note that this value depends on speed, and may not be an integer value.

        Returns:
            the source duration value for the track item.
        """
        ...
    def sourceIn(self) -> float:
        """
        Note that after a combination of a retime and editing, this value may not be an integer.

        Returns:
            the source in value for the track item.
        """
        ...
    def sourceMediaColourTransform(self, *args, **kwargs) -> typing.Text:
        """
        self.setSourceMediaColourTransform() -> returns colour transform for the media source.
        """
        ...
    def sourceOut(self) -> float:
        """
        Note that this value depends on speed, and may not be an integer value.

        Returns:
            the source out value for the track item.
        """
        ...
    def tags(self) -> typing.Tuple[Tag, ...]:
        """

        Returns:
            a tuple of all of the tags applied to this object.
        """
        ...
    def thumbnail(self, frame, layer) -> QImage:
        """

        Args:
            frame: the frame to get the thumbnail for (defaults to 0)
            layer: the layer to get the thumbnail for (defaults to colour)

        Returns:
            a thumbnail of the frame specified as a QImage object.
        """
        ...
    def toString(self, *args, **kwargs):
        """ """
        ...
    def unlink(self, trackItem):
        """
        Unlinks this track item from given track item.

        Args:
            trackItem: track item from which this track item is being unlinked
        """
        ...
    def unlinkAll(self):
        """
        alias of __TrackItem_unlinkAll
        Unlink all track items that are linked to this one.
        """
        ...
    def versionDown(self) -> Version:
        """
        decrements the current version on this track item and returns the new version object. Creates a new version if there wasn't one before, but doesn't check that the versioned media source exists on disk.
        WARNING - DEPRECATED ( versionDown ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from TrackItem. To find new versions, please use hiero.core.VersionScanner. To obtain the next version, please use TrackItem.prevVersion().
        """
        ...
    def versionMaxAvailable(self) -> Version:
        """
        WARNING - DEPRECATED ( versionMaxAvailable ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from TrackItem. This method has been replaced by TrackItem.maxVersion().

        Returns:
            the highest discovered version on this track item.
        """
        ...
    def versionMinAvailable(self) -> Version:
        """
        WARNING - DEPRECATED ( versionMinAvailable ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from TrackItem. This method has been replaced by TrackItem.minVersion().

        Returns:
            the lowest discovered version on this track item.
        """
        ...
    def versionNextAvailable(self) -> Version:
        """
        WARNING - DEPRECATED ( versionNextAvailable ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from TrackItem. This method has been replaced by TrackItem.nextVersion().

        Returns:
            the next highest available version on this track item that the application has discovered.
        """
        ...
    def versionPrevAvailable(self) -> Version:
        """
        WARNING - DEPRECATED ( versionPrevAvailable ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from TrackItem. This method has been replaced by TrackItem.prevVersion().

        Returns:
            the next lowest version on this track item that the application has discovered.
        """
        ...
    def versionUp(self) -> Version:
        """
        increments the current version on this track item and returns the new version object. Creates a new version if there wasn't one before, but doesn't check that the versioned media source exists on disk.
        WARNING - DEPRECATED ( versionUp ): This method is deprecated and will not be present in future versions of the Python API.
        Only available versions can now be obtained from TrackItem. To find new versions, please use hiero.core.VersionScanner. To obtain the next version, please use TrackItem.nextVersion().
        """
        ...
    ...

class TrackItemBase(Shiboken.Object):
    """
    Base class for objects which can exist on a timeline track which provides some common methods.  Not to be used directly.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @staticmethod
    def moveTrackItems(*args, **kwargs):
        """
        TrackItem.moveTrackItems(trackItems, time) -> moves a group of track items in the sequence.

        Args:
            trackItems: sequence of track items to move
            time: frame value. If positive, the trackitems move right. If negative, the trackitems move left.
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def clone(self):
        """
        WARNING - DEPRECATED ( clone ): This method is deprecated and will not be present in future versions of the Python API.
        This method has been replaced by copy().

        Returns:
            a deep copy of this object.
        """
        ...
    def copy(self) -> TrackItem:
        """

        Returns:
            a deep copy of this object.
        """
        ...
    def duration(self) -> frames:
        """

        Returns:
            the timeline duration value for the item.
        """
        ...
    def guid(self, *args, **kwargs):
        """ """
        ...
    def isEnabled(self) -> bool:
        """

        Returns:
            True if the track item is enabled.
        """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            True if the track item is invalid.
        """
        ...
    def linkedItems(self) -> typing.Tuple[TrackItem, ...]:
        """

        Returns:
            a tuple of track item objects linked to this one.
        """
        ...
    def move(self, time: int) -> None:
        """
        moves the item in the sequence. This will keep the duration.

        Args:
            time: frame value. If positive, the item moves right. If negative, the item moves left.
        """
        ...
    def parent(self) -> typing.Union[AudioTrack, VideoTrack]:
        """

        Returns:
            the AudioTrack or VideoTrack that contains this item.
        """
        ...
    def parentSequence(self) -> Sequence:
        """ """
        ...
    def parentTrack(self) -> typing.Union[VideoTrack, AudioTrack]:
        """ """
        ...
    def project(self) -> typing.Optional[Project]:
        """

        Returns:
            the Project object that this is attached to, or None if the object is not attached to a project.
        """
        ...
    def sequence(self) -> typing.Optional[Sequence]:
        """

        Returns:
            the Sequence object that this is attached to, or None if the object is not attached to a project.
        """
        ...
    def setEnabled(self, enabled) -> bool:
        """
        enables or disables the track item.
        """
        ...
    def setTimelineIn(self, inTime):
        """
        sets the timeline in value. Shrinks or grows the timeline duration, as appropriate.

        Args:
            inTime: frame value
        """
        ...
    def setTimelineOut(self, outTime):
        """
        sets the timeline out value. Shrinks or grows the timeline duration, as appropriate.

        Args:
            outTime: frame value
        """
        ...
    def timelineIn(self) -> int:
        """

        Returns:
            the timeline in value for the track item.
        """
        ...
    def timelineOut(self) -> int:
        """

        Returns:
            the timeline in value for the track item.
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def trimIn(self, time):
        """
        trims the left end of the item. This will grow or shrink the duration and the sourceDuration, but keep the playback speed.

        Args:
            time: frame value. If positive, the item duration shrinks. If negative, the item duration grows.
        """
        ...
    def trimOut(self, time):
        """
        trims the right end of the item. This will grow or shrink the duration and the sourceDuration, but keep the playback speed.

        Args:
            time: frame value. If positive, the item duration shrinks. If negative, the item duration grows.
        """
        ...
    ...

class Transition(TrackItemBase):
    """
    Object representing a transition between two clips.
    """

    Alignments: ...
    """
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    kDissolve: ... = core.Hiero.Python.Transition.Alignments.kDissolve
    """
    """

    kFadeIn: ... = core.Hiero.Python.Transition.Alignments.kFadeIn
    """
    """

    kFadeOut: ... = core.Hiero.Python.Transition.Alignments.kFadeOut
    """
    """

    kUnknown: ... = core.Hiero.Python.Transition.Alignments.kUnknown
    """
    """
    @staticmethod
    def createAudioCrossfadeTransition(
        trackItem1, trackItem2, duration1, duration2
    ) -> Transition:
        """
        creates a new audio crossfade (kDissolve) Transition between two adjacent track items.
        The effect will start at duration frames from the end of the trackItem1 and end at duration frames from the start of trackItem2.
        @seealso: createDissolveTransition for Video equivalent

        Args:
            trackItem1: the earlier hiero.core.TrackItem object to dissolve from. Must be an Audio TrackItem.
            trackItem2: the later hiero.core.TrackItem object to crossfade to. Must be an Audio TrackItem.
            duration1: frames for the crossfade from
            duration2: frames for the crossfade to
        """
        ...
    @staticmethod
    def createAudioFadeInTransition(trackItem, duration) -> Transition:
        """
        creates a new fade in (kFadeIn) Transition with the timelineIn of the trackItem and the duration specified.
        @seealso: createFadeInTransition for Video equivalent

        Args:
            trackItem: TrackItem object to use the timelineIn value from. Must be an Audio TrackItem.
            duration: frames
        """
        ...
    @staticmethod
    def createAudioFadeOutTransition(trackItem, duration) -> Transition:
        """
        creates a new fade out (kFadeOut) Transition. The in point will be the timelineOut of trackItem, minus the duration specified.
        @seealso: createFadeOutTransition for Video equivalent

        Args:
            trackItem: TrackItem object to use the timelineOut value from. Must be an Audio TrackItem.
            duration: frames
        """
        ...
    @staticmethod
    def createDissolveTransition(
        trackItem1, trackItem2, duration1, duration2
    ) -> Transition:
        """
        creates a new dissolve (kDissolve) Transition between two adjacent track items.
        The effect will start at duration frames from the end of the trackItem1 and end at duration frames from the start of trackItem2.
        @seealso: createAudioCrossTransition for Audio equivalent

        Args:
            trackItem1: the earlier hiero.core.TrackItem object to dissolve from. Must be a Video TrackItem.
            trackItem2: the later hiero.core.TrackItem object to dissolve to. Must be a Video TrackItem.
            duration1: frames for the dissolve from
            duration2: frames for the dissolve to
        """
        ...
    @staticmethod
    def createFadeInTransition(trackItem, duration) -> Transition:
        """
        creates a new fade in (kFadeIn) Transition with the timelineIn of the trackItem and the duration specified.
        @seealso: createAudioFadeInTransition for Audio equivalent

        Args:
            trackItem: TrackItem object to use the timelineIn value from. Must be a Video TrackItem.
            duration: frames
        """
        ...
    @staticmethod
    def createFadeOutTransition(trackItem, duration) -> Transition:
        """
        creates a new fade out (kFadeOut) Transition. The in point will be the timelineOut of trackItem, minus the duration specified.
        @seealso: createAudioFadeOutTransition for Audio equivalent

        Args:
            trackItem: TrackItem object to use the timelineOut value from. Must be a Video TrackItem.
            duration: frames
        """
        ...
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def alignment(self):
        """

        Returns:
            the alignment mode of this transition. Either kFadeIn, kDissolve, kFadeOut or kUnknown.
            alignment type (hiero.core.Transition.Alignments)
        """
        ...
    def guid(self, *args, **kwargs):
        """ """
        ...
    def inTrackItem(self):
        """
        Get the in track item for this transition.
        return: hiero.core.TrackItem
        """
        ...
    def outTrackItem(self):
        """
        Get the out track item for this transition.
        return: hiero.core.TrackItem
        """
        ...
    def parent(self) -> AudioTrack or hiero.core.VideoTrack:
        """

        Returns:
            the AudioTrack or VideoTrack that contains this transition.
        """
        ...
    def project(self, *args, **kwargs):
        """ """
        ...
    def setAlignment(self, alignment):
        """
        sets the alignment mode on this transition.

        Args:
            alignment: alignment type (hiero.core.Transition.Alignments), either kFadeIn, kDissolve, or kFadeOut
        """
        ...
    def setTimelineIn(self, inTime):
        """
        sets the in point for this transition. Note that this trims the duration of the transition.

        Args:
            inTime: frame for the new in point
        """
        ...
    def setTimelineOut(self, outTime):
        """
        sets the out point for this transition. Note that this trims the duration of the transition.

        Args:
            outTime: frame for the new out point
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    ...

class UndoGroup(Shiboken.Object):
    """
    Helper class for beginning and ending undo on a project.  Recommended usage is to create with hiero.core.Project.beginUndo(name), using a with block for exception safety to ensure Project.endUndo() is called.  For example:
    with project.beginUndo('My Undo'):
      // Undoable edits
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __enter__(self):
        """
        Allows usage in a with block to automatically end the undo.
        """
        ...
    def __exit__(self):
        """
        Calls self.endUndo().  This allows usage in a with block to automatically end the undo.
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def beginUndo(self):
        """
        starts a new undo action on the project with the initialised name.  See hiero.core.Project.beginUndo()
        """
        ...
    def endUndo(self):
        """
        ends the undo action on the project
        """
        ...
    def isNull(self, *args, **kwargs):
        """ """
        ...
    ...

class Version(Shiboken.Object):
    """
    Object representing a version of a clip or sequence. Can be created with a Clip or Sequence object.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...
    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...
    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...
    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...
    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...
    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def isHidden(self, *args, **kwargs):
        """ """
        ...
    def isNull(self) -> bool:
        """

        Returns:
            True if the object is invalid, False otherwise.
        """
        ...
    def item(self) -> Clip or hiero.core.Sequence:
        """

        Returns:
            the clip or sequence stored with this version.
        """
        ...
    def name(self) -> typing.Text:
        """

        Returns:
            the name of this version.
        """
        ...
    def parent(self) -> BinItem:
        """

        Returns:
            the bin item that contains this version.
        """
        ...
    def setHidden(self, *args, **kwargs):
        """ """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def versionIndex(self) -> typing.Text:
        """
        WARNING - DEPRECATED ( versionIndex ): This method is deprecated and will not be present in future versions of the Python API.
        Version indices are no longer unique identifiers and should not be used as such.

        Returns:
            a string containing the version's index.
        """
        ...
    ...

class VideoTrack(TrackBase):
    """
    Object for manipulating video tracks.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __copy__(self, *args, **kwargs):
        """ """
        ...
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...
    def __nonzero__(self, *args, **kwargs):
        """
        x.__nonzero__() <==> x != 0
        """
        ...
    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...
    def addSubTrackItem(self, subTrackItem, subTrackIndex):
        """
        Add a subtrack item to the track on the given sub-track index.
        This method will cut or delete sub-track items that overlap with the one being added.

        Args:
            subTrackItem: a hiero.core.SubTrackItem object to add.
            subTrackIndex: the index of the sub-track to add to.

        Returns:
            the added item
        """
        ...
    def addTag(self, tag):
        """
        adds a tag to the video track item.

        Args:
            tag: the hiero.core.Tag to add to the video track.
        """
        ...
    def addToNukeScript(
        self,
        arg2: typing.Literal["script="],
        additionalNodes=[],
        additionalNodesCallback=None,
        includeRetimes=False,
        retimeMethod=None,
        offset=0,
        skipOffline=True,
        mediaToSkip=[],
        disconnected=False,
        includeAnnotations=False,
        includeEffects=True,
    ):
        """
        alias of _VideoTrack_addToNukeScript
        Add a Read node for each track item to the script with Merge or Dissolve nodes
        to join them in a sequence. TimeClip nodes are added to pad any gaps between clips.

        Args:
            script: Nuke script object to add nodes to.
            additionalNodes: typing.List[nodes to be added post read, passed on to track]
            additionalNodesCallback: callback to allow custom additional node per item function([Clip|TrackItem|Track|Sequence])
            includeRetimes: True/False include retimes
            retimeMethod: "Motion", "Blend", "Frame" - Knob setting for OFlow retime method
            offset: Optional, Global frame offset applied across whole script
            skipOffline: If True, offline clips are not included in the export
            mediaToSkip: typing.List[MediaSources which should be excluded from the export]
            disconnected: If True, items on the track are not connected and no constant nodes are added to fill gaps
            includeAnnotations: If True, clip-level annotations will be included in the output
            includeEffects: If True, clip-level soft effects will be included in the output
        """
        ...
    @typing.overload
    def addTrackItem(self, clip: TrackItem) -> TrackItem:
        ...   
    @typing.overload
    def addTrackItem(self, clip: Clip, position: int) -> TrackItem:
        """
        if the first parameter is a Clip object, the second parameter must be specified and this method creates a new track item and adds it to this video track at the given position.
        If the first parameter is a TrackItem, then this method just adds the track item specified.
        This method will cut or delete track items that overlap with the one being added.
        This method can only be called if the track has already been added to a Sequence.

        Args:
            clip: a hiero.core.Clip object or a hiero.core.TrackItem object, to add to this video track.
            position: int; insert position. Do not specify if clip is a TrackItem.
        """
        ...
    def blendMode(self):
        """

        Returns:
            a string representing the blend-mode as it appears in the Nuke Merge Node, if the VideoTrack object has blending enabled.
            String containing the blend-mode
        """
        ...
    def clone(self) -> VideoTrack:
        """
        WARNING - DEPRECATED ( clone ): This method is deprecated and will not be present in future versions of the Python API.
        This method has been replaced by copy().

        Returns:
            a deep copy of this object.
        """
        ...
    def copy(self) -> VideoTrack:
        """

        Returns:
            a deep copy of this object.
        """
        ...
    def createEffect(
        self, trackItem=None, timelineIn=None, timelineOut=None, subTrackIndex=None
    ):
        """
        Create an effect item and add it to the track.
        The effect's node will be of type effectType or if cloneFrom is given, will be a clone of that.  It will use timing either based on trackItem if given or timelineIn and timelineOut.  If none of these are specified,
        the effect will cover the full duration of the track's parent sequence.

        Args:
            effectType: the node type to create a soft effect for
            cloneFrom: if given, the new effect item will be cloned from this
            copyFrom: if given, the new effect item will be copied from this
            trackItem: if specified, the effect will be linked to the track item and use the same timing
            timelineIn: the effect start time
            timelineOut: the effect end time
            subTrackIndex: if specified, will be placed on the appropriate sub-track, otherwise will be placed on a new sub-track

        Returns:
            the created EffectTrackItem object
        """
        ...
    def createTrackItem(self, name) -> TrackItem:
        """
        creates a new track item.

        Args:
            name: the name of the new track item
        """
        ...
    def isBlendEnabled(self, *args, **kwargs) -> bool:
        """
        self.isEnabled() -> returns True if the VideoTrack object has blending enabled.
        """
        ...
    def isBlendMaskEnabled(self) -> bool:
        """

        Returns:
            True if the VideoTrack object has blend-masking enabled.
        """
        ...
    def items(self) -> typing.Tuple[TrackItem, ...]:
        """

        Returns:
            a tuple with all of the track items contained by this track.
        """
        ...
    def parent(self) -> Sequence:
        """

        Returns:
            the sequence that contains this track.
        """
        ...
    def removeSubTrackItem(self, subTrackItem, option=eRemoveLinkedItems):
        """
        removes a sub-track item from this track.

        Args:
            subTrackItem: the hiero.core.SubTrackItem to remove from this track
            option: options controlling the remove behavior. By default linked items are also removed.
        """
        ...
    def removeTag(self, tag):
        """
        removes the tag from the video track.

        Args:
            tag: Tag
        """
        ...
    def setBlendEnabled(self, *args, **kwargs):
        """
        self.setEnabled() -> enables or disables blending on the VideoTrack, if it is not locked.
        An error is raised if the track is locked.
        """
        ...
    def setBlendMaskEnabled(self):
        """
        sets whether blend-masking is enabled or not, if it is not locked.
        An error is raised if the track is locked.
        """
        ...
    def setBlendMode(self):
        """
        sets the blend mode to be used, if it is not locked. Expected strings are NUKE Merge Node operations.
        An error is raised if the track is locked.
        """
        ...
    def subTrackItems(self):
        """
        on the corresponding sub track.

        Returns:
            a tuple with an entry for each sub track in this track, each entry being a tuple of items
            tuple of hiero.core.SubTrackItem sub-class objects
        """
        ...
    def toString(self) -> typing.Text:
        """

        Returns:
            a description of the object. Equivalent to str(object).
        """
        ...
    def trackIndex(self, *args, **kwargs):
        """ """
        ...
    ...

def LUTGroup(*args, **kwargs):
    """ """
    ...

def LUTs() -> typing.Tuple[typing.Text, ...]:
    """

    Returns:
        a tuple with the names of all of the available luts.
    """
    ...

def QuickTimePixelFormats(*args, **kwargs):
    """ """
    ...

def _Project_extractSettings(self) -> dict:
    """
    self.extractSettings() -> returns a dict of the project's settings.
    """
    ...

def __EffectTrackItem_name(self) -> typing.Text:
    """
    self.name() -> Get the name of the effect's node.
    """
    ...

def __EffectTrackItem_setName(self, name):
    """
    self.setName() -> Set the name of the effect's node.
    """
    ...

def __TrackItem_unlinkAll(self):
    """
    self.unlinkAll() -> Unlink all track items that are linked to this one.
    """
    ...

def __VideoTrack_addMethods():
    """ """
    ...

def _projectSetting(project, func):
    """ """
    ...

def _setFindMethods():
    """ """
    ...

def addPathRemap(windowsPathPrefix, osxPathPrefix, linuxPathPrefix) -> None:
    """
    adds to the table of file path remapping prefixes that Hiero maintains. Pairs of path prefixes added to this table will be used to convert paths between Windows, OSX and Linux. When on Windows, Hiero will replace any Linux or OSX prefixes found with the corresponding Windows prefix. On OSX, Hiero will search for the Windows and Linux path prefixes and replace them with the corresponding OSX prefix. The same applies for OSX/Windows prefixes being replaced on Linux. These can also be configured through the user interface in the General tab of the Preferences dialog.

    Args:
        windowsPathPrefix: typing.Text
        osxPathPrefix: typing.Text
        linuxPathPrefix: typing.Text
    """
    ...

def addPluginPath(pluginPath: typing.Text) -> None:
    """
    adds a new path to the list of plugin paths searched for Python plugins (in Python/Startup and Python/StartupUI folders). The user's .nuke folder will be the first in this list.

    Args:
        pluginPath: the new path to add
        index: optional; if not specified or negative, the new path will be added to the end of the list

    Overloads:
        hiero.core.addPluginPath(pluginPath, index) -> the same as above, except that the index specifies which item in the list of paths to place the new one before.
    """
    ...

def closeAllProjects(*args, **kwargs):
    """
    hiero.core.closeProject() -> closes all of the existing projects without saving.
    hiero.core.closeProject(bool dontSave) -> same as above, but if the parameter is set to false, unsaved projects will cause Hiero to popup a dialog for each unsaved project, asking the user if they'd like to save.

    Args:
        dontSave: bool
    """
    ...

def conformer() -> Conformer:
    """

    Returns:
        an interface for setting the conforming options.
    """
    ...

def defaultFrameRates() -> typing.Tuple[float, ...]:
    """

    Returns:
        the list of frame rates displayed in Hiero's user interface.
    """
    ...

def executeInMainThread(call, *args, **kwargs):
    """
    Execute the callable 'call' with optional arguments 'args' and named arguments 'kwargs' in
    the main thread and return immediately.
    Note that this method expects a single item for args or a tuple, and a dictionary for kwargs.
    It will not accept anything else.
    Examples of how to use this method (that work):

    def someMethod(firstParameter, kwArg0=None, kwArg1=None)
      print firstParameter

    executeInMainThread(someMethod, "First positional parameter")
    executeInMainThread(someMethod, "First positional parameter", {'kwArg0': "arg0"})
    executeInMainThread(someMethod, ("First positional parameter", "kwArg0 passed as positional parameter"))
    executeInMainThread(someMethod, ("First positional parameter", "kwArg0 passed as positional parameter"), {'kwArg1': "arg1 as well"})
    executeInMainThread(someMethod, "First positional parameter", {'kwArg1': "arg1"})
    An example of what won't work:

    executeInMainThread(someMethod, "First positional parameter", "Second positional parameter")
    The above fails because the second parameter to executeInMainThread must be a dictionary.
    """
    ...

def executeInMainThreadWithResult(call, *args, **kwargs):
    """
    Execute the callable 'call' with optional arguments 'args' and named arguments 'kwargs' in
    the main thread and wait for the result.
    Note that this method expects a single item for args or a tuple, and a dictionary for kwargs.
    It will not accept anything else.
    Examples of how to use this method (that work):

    def someMethod(firstParameter, kwArg0=None, kwArg1=None)
      print firstParameter
      return kwArg1

    result = executeInMainThreadWithResult(someMethod, "First positional parameter")
    result = executeInMainThreadWithResult(someMethod, "First positional parameter", {'kwArg0': "arg0"})
    result = executeInMainThreadWithResult(someMethod, ("First positional parameter", "kwArg0 passed as positional parameter"))
    result = executeInMainThreadWithResult(someMethod, ("First positional parameter", "kwArg0 passed as positional parameter"), {'kwArg1': "arg1 as well"})
    result = executeInMainThreadWithResult(someMethod, "First positional parameter", {'kwArg1': "arg1"})
    An example of what won't work:

    result = executeInMainThreadWithResult(someMethod, "First positional parameter", "Second positional parameter")
    The above fails because the second parameter to executeInMainThread must be a dictionary.
    """
    ...

def filenameList(directory, splitSequences, returnDirectories, returnHiddenFiles):
    """
    Returns a list of strings representing the items found in the specified directory, putting image sequences together as one element.
    For a directory with the following items:
    item1.txt
    item2.txt
    quicktime.mov
    highres1.dpx
    You'd get a tuple with the same list of items (txt files are recognized as not being image sequences).
    With a directory with the following items:
      * quicktime.mov
      * highres1.dpx
      * highres2.dpx
      * highres3.dpx
      * highres4.dpx
      * highres5.dpx
    You'd get a tuple with:
    ("quicktime.mov", "highres#.dpx 1-4")
    If you had the following in a directory:
      * highres1.dpx
      * highres2.dpx
      * highres4.dpx
      * highres5.dpx
    Note the missing 3 in the above list.
    If you set splitSequences to False, you'd get:
    ("highres#.dpx 1-5")
    If instead you set splitSequences to True, you'd get:
    ("highres#.dpx 1-3", "highres#.dpx 4-5")
    If you had a directory with this:
      * highres001.dpx
      * highres002.dpx
      * highres003.dpx
      * highres004.dpx
      * highres005.dpx
    You'd get a tuple like this:
    ("highres###.dpx 1-5")
    If you had a directory with this:
      * highres99.dpx
      * highres100.dpx
    You'd get this:
    ("highres#.dpx 99-100")
    In the above example, the sequence number crosses over from 2 digits to 3, so it is treated as one and the number of hashes (#) is put to 1, which means the number is wild.
    If instead you had a directory with this:
      * highres099.dpx
      * highres100.dpx
    You'd get this:
    ("highres###.dpx 99-100")
    Note that in this last example, the 99 is prefixed with 0.

    Args:
        directory: path to the directory to query
        splitSequences: optional, defaults to False. If set to True, then splits broken image sequences up. Otherwise, broken sequences create only one entry in the returned list
        returnDirectories: optional, defaults to True. If set to True, sub directories will be included in the returned list
        returnHiddenFiles: optional, defaults to True. If set to True, hidden/system files will be returned in the list
    """
    ...

findItems = findItemsInProject

def findItemsInBin(rootBin, filter=None, partialName=None, verbose=0):
    """
    Returns all items recursively in a Bin, found in rootBin.
    Example uses:
    myBin = hiero.core.projects()[0].clipsBin()[0] # A hiero.core.Bin object
    allItemsInMyBin = findItemsInBin(myBin)
    allClipsAndSequencesInMyBin = findItemsInBin(myBin, filter = [hiero.core.Sequence, hiero.core.Clip])
    allClipsWithPartialName = findItems(myProj, 'clips', 'C00')
    allSubBinsOnly = findItems(myProj, hiero.core.Bin)

    Args:
        rootBin: Bin object, to find the items on.
        filter: optional. Used to filter the returned list. Can be None, a case insensitive single string or type, or a list of case insensitive strings and types.
        partialName: optional string. If specified, objects will only be returned if their name contains this string.
        verbose: optional value. If not None/False/0, findItems will print out information as it searches.

    Returns:
        list of objects.
    """
    ...

def findItemsInProject(proj=None, filter=None, partialName=None, verbose=0):
    """
    findItemsInProject -> Returns all items in a Project's clipsBin.
    User can filter by a specific type(s) or by partial name, and optionally print a verbose log to the output window.
    Takes up to 4 keyword arguments : Project object, a string, a type or an array of strings for filter type, partial name of item, and a bool to enable/disable verbose mode
    Returns an array of items. Note: to find Tags in a Project, use the findProjectTags method.
    Example uses:
    allItems = findItemsInProject(myProj)
    allSeqsAndTracksWith30SecInName = findItemsInProject(myProj, ['sequences', 'Tracks'], '30Sec', 1)
    allTracks = findItemsInProject(myProj, "Track")
    videoTracks = findItemsInProject(myProj, "VideoTrack")
    sequences = findItemsInProject(myProj, "Sequence") # Can also use plural: 'Sequences'
    sequences = findItemsInProject(myProj, hiero.core.Sequence)
    sequencesAndClips = findItemsInProject(myProj, [hiero.core.Sequence, hiero.core.Clip])
    binsOnly = findItemsInProject(myProj, hiero.core.Bin)
    hiero.core.findItems is deprecated. Please use hiero.core.findItemsInProject instead.

    Args:
        proj: Project object, to find the items on. If None, then the last project in the currently loaded projects will be used.
        filter: optional. Used to filter the returned list. Can be None, a case insensitive single string or type, or a list of case insensitive strings and types.
        partialName: optional string. If specified, objects will only be returned if their name contains this string.
        verbose: optional value. If not None/False/0, findItems will print out information as it searches.

    Returns:
        list of objects.
    """
    ...

def findProjectTags(proj=None, tagName=None, iconName=None, verbose=0):
    """
    findProjectTags -> Returns all Tags in a project. User can filter by tag name, icon name, and optionally print a verbose log to the output window.
    Takes up to 4 arguments : Project object, partial name of Tag, partial icon name, and a bool to enable/disable verbose mode
    Returns a list of Tag objects.
    Example uses:
    allTags = findItems(myProj)
    allTagsWithNameLens = findItems(myProj, tagName = 'Lens')
    allTagsWithIconPath = findItems(myProj, iconName = 'lens.png')

    Args:
        proj: Project object, to find the items on. If None, then the last project in the currently loaded projects will be used.
        tagName: optional string. If specified, Tags will only be returned if their name contains this string.
        iconName: optional string. If specified, Tags will only be returned if their icon path contains this string.
        verbose: optional value. If not None/False/0, findProjectTags will print out information as it searches.

    Returns:
        list of Tag objects.
    """
    ...

def formats() -> typing.Tuple[Format, ...]:
    """

    Returns:
        a tuple with all of the formats currently available.
    """
    ...

def getBundledNukePath():
    """
    return the bundled Nuke executable

    Returns:
        A string containing the bundled Nuke executable path.
    """
    ...

def getBundledPythonPath():
    """
    return the bundled Python executable

    Returns:
        A string containing the bundled Python executable path.
    """
    ...

def getFilenameList(*args, **kwargs):
    """
    Deprecated. Do not use. Use hiero.core.filenameList() instead
    """
    ...

def getLibraryDirectory(subdirectory):
    """
    deprecated; use hiero.core.libraryDirectory() instead.
    """
    ...

def getPluginPath():
    """
    deprecated; please use hiero.core.pluginPath instead.
    """
    ...

def hieroNukePath():
    """

    Returns:
        the HieroNuke executable path which ships with Hiero. DEPRECATED Use getBundledNukePath() instead.
        A string containing the HieroNuke executable path.
    """
    ...

def isHieroPlayer(*args, **kwargs):
    """ """
    ...

def isNC(*args, **kwargs):
    """ """
    ...

def isQuickTimeFileExtension(fileExtension):
    """
    Returns True if the fileExtension is a recognised QuickTime extension, False otherwise.
    """
    ...

def isVideoFileExtension(fileExtension):
    """
    Returns True if the fileExtension is a recognised video format extension, i.e not an image Sequence (QuickTime/MXF/R3D media)
    """
    ...

def libraryDirectory(subdirectory) -> typing.Text:
    """

    Args:
        subdirectory: path to append to the .nuke directory

    Returns:
        the input appended to the location of the user's .nuke directory.
    """
    ...

def newProject() -> Project:
    """
    creates and returns a new Project object.
    """
    ...

def openProject(path):
    """
    Opens the project found at the specified path. Must be called on the main thread. Throws an exception on failure.

    Args:
        path: Path to the project file (\\*.hrox).

    Returns:
        Opened project.
    """
    ...

def openProjectStartup(path, asStartup) -> Project:
    """
    for internal use only, hiero.core.openProject(path) should be used instead.
    """
    ...

def overrideApplicationSettingsSetValue():
    """
    # ApplicationSettings setValue takes strings, but we often use it with Qt stuff, which returns QStrings, and causes a crash if not cast.
    # So we override it here so that we can pass QStrings and other things along
    """
    ...

def pathRemappings():
    """

    Returns:
        the path remappings specified in the application preferences, or added through addPathRemap().
        a list of path remappings each containing the mapping for (windows, osx, linux)
    """
    ...

def pluginPath() -> typing.Tuple[typing.Text, ...]:
    """
    Returns a tuple of the search paths used by Hiero to load Python scripts.
    """
    ...

def presetProjects() -> typing.Tuple[Project, ...]:
    """
    hiero.core.projects() -> returns a tuple of all of the currently loaded preset projects.
    @deprecated: Use hiero.core.projects(Project.kStartupProjects) instead
    """
    ...

def project(name) -> Project:
    """

    Returns:
        the Project with the specified name, if it can be found, or None.
    """
    ...

def projects(projectTypes) -> typing.Tuple[Project, ...]:
    """

    Args:
        projectTypes: optional; one of Project.kAllProjects, Project.kUserProjects, Project.kStartupProjects

    Returns:
        a tuple of currently loaded projects which are user projects (not startup). Same effect as calling the method below passing Project.kUserProjects.

    Overloads:
        hiero.core.projects(projectTypes) -> returns a tuple of currently loaded projects, filtered according to projectTypes. Use hiero.core.projects()[-1] to get the last loaded project.
    """
    ...

def quit(exitCode):
    """
    shuts down Hiero, without saving any existing projects. Safer than calling sys.exit(), which doesn't always clean up properly and can cause Hiero to crash. This version sets the exit code of the Hiero process to 0.
    Note that this must be the last line in a script.

    Args:
        exitCode: optional; integer value to set the process's exit code to

    Overloads:
        hiero.core.quit(exitCode) -> same as the first version of this method, except that this one sets the exit code of the process to the exitCode variable.
    """
    ...

def redo(*args, **kwargs):
    """ """
    ...

def redoSize(*args, **kwargs):
    """ """
    ...

def remapPath(path) -> typing.Text:
    """
    uses the platform specific path remapping rules from the user's preferences and applies them to the input path.

    Args:
        path: string path to apply the path remapping rules to
    """
    ...

def setLocalisationForAllVersionsInProject(proj, policy):
    """
    Sets localisation policy for all Versions of All Clips in a project

    Args:
        proj: Project
        policy: policy - the localisation policy from hiero.core.Clip. Options: kOnLocalise, kAutoLocalise, kOffLocalise
    """
    ...

def setLocalisationPolicyOnBin(bin, policy, recursive=True):
    """
    Sets localisation policy for all Clips found in a Bin and recursively found in all Sub-Bins

    Args:
        clipList: clipList - a list of hiero.core.Clip objects
        policy: policy - the localisation policy from hiero.core.Clip. Options: kOnLocalise, kAutoLocalise, kOffLocalise
        recursive: recursive (optional, default = True) - localises all Clips found recursively in a Bin Structure
    """
    ...

def setLocalisationPolicyOnSequence(sequence, policy):
    """
    Sets localisation policy for all Clips used by TrackItems in a Sequence with a given policy.

    Args:
        sequence: sequence - a hiero.core.Sequence
        policy: policy - the localisation policy from hiero.core.Clip. Options: kOnLocalise, kAutoLocalise, kOffLocalise
    """
    ...

def setLocalisationPolicyOnTrack(track, policy):
    """
    Sets localisation policy for all Clips used by TrackItems in a Track with a given policy.

    Args:
        track: track - a hiero.core.Track
        policy: policy - the localisation policy from hiero.core.Clip. Options: kOnLocalise, kAutoLocalise, kOffLocalise
    """
    ...

def setLocalisationPolicyOnTrackItem(trackItem, policy):
    """
    Sets localisation policy for the source Clip of a TrackItem

    Args:
        track: track - a  hiero.core.TrackItem
        policy: policy - the localisation policy from hiero.core.Clip. Options: kOnLocalise, kAutoLocalise, kOffLocalise
    """
    ...

def stopScriptAndQuit(*args, **kwargs):
    """ """
    ...

def undo(*args, **kwargs):
    """ """
    ...

def undoSize(*args, **kwargs):
    """ """
    ...

GUI: bool
"""
True
"""

NonZeroStartFrameMovieFileExtensions: ...
"""
['.mov', '.m4v', '.mp4', '.m4a'...
"""

QuickTimeExtensions: ...
"""
['.mov', '.m4v', '.mp4', '.m4a', '.m4p', '.m4b',...
"""

VideoFileExtensions: ...
"""
['.mov', '.m4v', '.mp4', '.m4a', '.m4p', '.m4b',...
"""

__all__: ...
"""
['Annotation', 'AnnotationElement', 'AnnotationStroke', 'Ann...
"""

__main_thread_event: ...
"""
<threading._Event object>
"""

__main_thread_lock: ...
"""
<thread.lock object>
"""

env: ...
"""
{'ApplicationName': 'Hiero', 'BundledNukeExeName': 'Nuke10.5', '...
"""

kMaxTime: int = -1

kMaxTimeDuration: int = -1

kNoTimeSet: int = 0

rawArgs: list
"""
[r'C:\\Program Files\\Nuke10.5v7\\Nuke10.5.exe', '--hiero']
"""

taskRegistry: ...
"""
<hiero.core.FnExportRegistry.TaskRegistry object>
"""
