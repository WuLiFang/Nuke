# -*- coding=UTF-8 -*-
# This typing file was generated by typing_from_help.py and modified after that.
"""
_nuke
"""

# spell-checker: words    nukemath CATMULL bitmask autoplace precomps frameholds timeblurs motionblur viewcount
# spell-checker: words    viewshort clipname colorspace somefile scenefile flipbook maxviews thefoundry classknob
# spell-checker: words    infoxml nodegraph checkmarks noisetools denoise fullscreen nodepreset invalidhint multiview
# spell-checker: words    POSTAGESTAMPS PHASENUMBER TABBEGINCLOSEDGROUP TABBEGINGROUP TABENDGROUP TABKNOB

import _geo
import _nukemath

from typing import (
    Optional,
    Union,
    overload,
    Iterable,
    Callable,
    Literal,
    type_check_only,
    Sequence,
    IO,
)
from wulifang._compat.str import Str

class _Unknown:
    pass

class AColor_Knob(Color_Knob):
    """
    AColor_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = ...,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class AnimationCurve:
    """
    AnimationCurve
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def addKey(self, keys) -> None:
        """
        Insert a sequence of keys.

        @param keys: Sequence of AnimationKey.

        @return: None.
        """
        ...

    def changeInterpolation(self, keys, type) -> None:
        """
        Change interpolation (and extrapolation) type for the keys.

        @param keys: Sequence of keys.

        @param type: Interpolation type. One of:

               nuke.HORIZONTAL

               nuke.BREAK

               nuke.BEFORE_CONST

               nuke.BEFORE_LINEAR

               nuke.AFTER_CONST

               nuke.AFTER_LINEAR.

        @return: None.
        """
        ...

    def clear(self) -> None:
        """
        Delete all keys.

        @return: None.
        """
        ...

    def constant(self) -> bool:
        """
        True if the animation appears to be a horizontal line, is a simple

        number, or it is the default and all the points are at the same y value and

        have 0 slopes. False otherwise.
        """
        ...

    def derivative(self, t, n) -> float:
        """
        The n'th derivative at time 't'. If n is less than 1 it returns evaluate(t).

        @param t: Time.

        @param n: Optional. Default is 1.

        @return: The value of the derivative.
        """
        ...

    def evaluate(self, t) -> float:
        """
        Value at time 't'.

        @param t: Time.

        @return: The value of the animation at time 't'.
        """
        ...

    def expression(self) -> Str:
        """
        Get the expression.@return: String.
        """
        ...

    def fixSlopes(self) -> None:
        """
        None.
        """
        ...

    def fromScript(self, s) -> None:
        """
        @param s: String.

        @return: None.
        """
        ...

    def identity(self) -> bool:
        """
        True if the animation appears to be such that y == x everywhere. This

        is True only for an expression of 'x' or the default expression and all points

        having y == x and slope == 1. Extrapolation is ignored.
        """
        ...

    def integrate(self, t1, t2) -> float:
        """
        Calculate the area underneath the curve from t1 to t2.

        @param t1 The start of the integration range.

        @param t2 The end of the integration range.

        @return: The result of the integration.
        """
        ...

    def inverse(self, y) -> float:
        """
        The inverse function at value y. This is the value of x such that evaluate(x)

        returns y.

        This is designed to invert color lookup tables. It only works if the

        derivative is zero or positive everywhere.

        @param y: The value of the function to get the inverse for.

        @return: Float.
        """
        ...

    def keys(self) -> list[Str]:
        """
        List of keys.
        """
        ...

    def knob(self) -> Knob:
        """
        Return knob this animation belongs to.@return: Knob.
        """
        ...

    def knobAndFieldName(self) -> Str:
        """
        Knob and field name combined (e.g. 'translate.x').

        @return: String.
        """
        ...

    def knobIndex(self) -> int:
        """
        Return the knob index this animation belongs to.@return: Int.
        """
        ...

    def noExpression(self) -> bool:
        """
        True if the expression is the default expression (i.e. the keys

        control the curve), False otherwise.
        """
        ...

    def removeKey(self, keys) -> None:
        """
        Remove some keys from the curve.

        @param keys: The sequence of keys to be removed.

        @return: None.
        """
        ...

    def selected(self) -> bool:
        """
        True if selected, False otherwise.
        """
        ...

    def setExpression(self, s) -> None:
        """
        Set expression.

        @param s: A String containing the expression.

        @return: None.
        """
        ...

    def setKey(self, t, y) -> ...:
        """
        Set a key at time t and value y. If there is no key

        there one is created. If there is a key there it is moved

        vertically to be at y.  If a new key is inserted the

        interpolation and extrapolation are copied from a neighboring key, if

        there were no keys then it is set to nuke.SMOOTH interpolation and

        nuke.CONSTANT extrapolation.

        @param t: The time to set the key at.

        @param y: The value for the key.

        @return: The new key.
        """
        ...

    def size(self) -> int:
        """
        Number of keys.
        """
        ...

    def toScript(self, selected) -> Str:
        """
        @param selected: Optional parameter. If this is given and is True, then only

        process the selected curves; otherwise convert all.

        @return: A String containing the curves.
        """
        ...

    def view(self) -> Str:
        """
        The view this AnimationCurve object is associated with.

        @return: String.
        """
        ...
    ...

class AnimationKey:
    """
    A control point for an animation curve.
    @var x
    The horizontal position of the point
    @var y
    The vertical position of the point
    @var lslope
    The derivative to the left of the point. If interpolation does not have
    USER_SET_SLOPE then this may not be correct until after evaluate() has been
    called.
    @var rslope
    The derivative to the right of the point. If interpolation does not have
    USER_SET_SLOPE then this may not be correct until after evaluate() has been
    called.
    @var la
    The left 'bicubic' value. This represents the horizontal
    position of the left bezier handle end, where 1.0 means 1/3 of the
    distance to the previous point. If both handles for a span are 1.0
    then the horizontal interpolation is linear and thus the vertical
    interpolation a cubic function.  The legal values are 0 to
    3. Setting outside of this range will produce undefined results.
    @var ra
    The right 'bicubic' value, again the legal range is 0 to 3.
    @var interpolation
    Used to calculate all the slopes except for the left slope of the first key
    and the right slope of the last key.
    Legal values are:
    - USER_SET_SLOPE: If this bit is on, the slopes are fixed by
                      the user and interpolation and extrapolation are ignored.
    - CONSTANT: The value of the curve is equal to the y of the
                point to the left.
    - LINEAR: slopes point directly at the next key.
    - SMOOTH: same as CATMULL_ROM but the slopes are clamped so that the
              convex-hull property is preserved (meaning no part of the curve
              extends vertically outside the range of the keys on each side of
              it). This is the default.
    - CATMULL_ROM: the slope at key n is set to the slope between the control
                   points n-1 and n+1. This is used by lots of software.
    - cubic: the slope is calculated to the only cubic interpolation which makes
             the first and second derivatives continuous. This type of
             interpolation was very popular in older animation software.  A
             different cubic interpolation is figured out for each set of adjacent
             points with the CUBIC type.
    - for the smooth, CATMULL_ROM, and CUBIC interpolations, the first and last
      key have slopes calculated so that the second derivative is zero at them.
    @var extrapolation
    controls how to set the left slope of the first point and the right slope of
    the last point. Notice that this can be set differently on the first and last
    points, and is also remembered on all internal points so if end points are
    deleted old behavior is restored).
    - constant: the left slope of the first point, and the right slope of the last
                point, are set to zero.
    - linear: (and all other values): The left slope of the first point is set
              equal to it's right slope (calculated by the interpolation).
    the right slope of the last point is set equal to it's left slope.
    if there is only one point both slopes are set to zero.
    @var selected
    True if the point is selected in the curve editor.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Array_Knob(Knob):
    """
    A knob which holds an array of values.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def animation(self, chan, view) -> Optional[AnimationCurve]:
        """
        Return the AnimationCurve for the  channel 'chan' and view 'view'. The view argument is optional.

        @param channel: The channel index.

        @param view: Optional view.

        @return: AnimationCurve or None.
        """
        ...

    def animations(self, view) -> list[AnimationCurve]:
        """
        @param view: Optional view.

        @return: AnimationCurve list.

        Example:

        b = nuke.nodes.Blur()

        k = b['size']

        k.setAnimated(0)

        a = k.animations()

        a[0].setKey(0, 11)

        a[0].setKey(10, 20)
        """
        ...

    def array(self) -> list[object]:
        """
        List of knob values.
        """
        ...

    def arraySize(self) -> int:
        """
        Number of elements in array.
        """
        ...

    def clearAnimated(self, index, view) -> bool:
        """
        Delete animation.

        @param index: Optional index.

        @param view: Optional view.

        @return: True if succeeded, False otherwise.
        """
        ...

    def copyAnimation(self, channel, curve, view) -> None:
        """
        Copies the i'th channel of the AnimationCurve curve to this object. The view is optional and defaults to the current view.

        @param channel: The channel index.

        @param curve: AnimationCurve.

        @param view: Optional view. Defaults to current.

        @return: None.
        """
        ...

    def copyAnimations(self, curves, view) -> None:
        """
        Copies the AnimationCurves from curves to this object. The view is optional and defaults to the current view.

        @param curves: AnimationCurve list.

        @param view: Optional view. Defaults to current.

        @return: None.
        """
        ...

    def defaultValue(self) -> ...:
        """
        Default value.
        """
        ...

    def deleteAnimation(self, curve) -> None:
        """
        Deletes the AnimationCurve.

        @param curve: An AnimationCurve instance which belongs to this Knob.

        @return: None. Raises ValueError if not found.
        """
        ...

    def dimensions(self) -> list[object]:
        """
        Dimensions in array.
        """
        ...

    def frame(self) -> int:
        """
        Frame number.
        """
        ...

    def fromScript(self, s: Str) -> bool:
        """
        Set value of the knob to a user defined script (TCL syntax, as in .nk file). Return True if successful.

        @param s: Nuke script to be set on knob.

        @return: True if successful, False otherwise.
        """
        ...

    def getDerivative(self, *args, **kwargs):
        """
        Return derivative at time 't' and index 'i'.
        """
        ...

    def getIntegral(self, *args, **kwargs):
        """
        Return integral at time interval [t1, t2] and index 'i'.
        """
        ...

    def getKeyIndex(self, *args, **kwargs):
        """
        Return index of the keyframe at time 't' and channel 'c'.
        """
        ...

    def getKeyTime(self, *args, **kwargs):
        """
        Return time of the keyframe at time 't' and channel 'c'.
        """
        ...

    def getNthDerivative(self, *args, **kwargs):
        """
        Return n'th derivative at time 't' and index 'i'.
        """
        ...

    def getNumKeys(self, *args, **kwargs):
        """
        Return number of keys at channel 'c'.
        """
        ...

    def getValue(self, *args, **kwargs):
        """
        self.value(index, view, time) -> Floating point or List of floating point values (in case some are different).

        @param index: Optional index. Default is 0.

        @param view: Optional view.

        @param time: Optional time.

        @return: Floating point or List of floating point values (in case some are different).
        """
        ...

    def getValueAt(
        self, time: int, index: int = ..., view: Str = ...
    ) -> Union[float, list[float]]:
        """
        self.valueAt(time, index, view) -> Floating point or List of floating point values (in case some are different).

        Return value for this knob at specified time, optional index and view.

        @param time: Time.

        @param index: Optional index. Default is 0.

        @param view: Optional view.

        @return: Floating point or List of floating point values (in case some are different).
        """
        ...

    def hasExpression(self, index: int = ...) -> bool:
        """
        @param index: Optional index.

        @return: True if has expression, False otherwise.
        """
        ...

    def height(self) -> int:
        """
        Height of array of values.
        """
        ...

    def isAnimated(self, index, view) -> bool:
        """
        @param index: Optional index.

        @param view: Optional view.

        @return: True if animated, False otherwise.
        """
        ...

    def isKey(self, index, view) -> bool:
        """
        @param index: Optional index.

        @param view: Optional view.

        @return: True if succeeded, False otherwise.
        """
        ...

    def isKeyAt(self, time, index, view) -> bool:
        """
        Returns True if there is a keyframe at specified time, optional index and view, otherwise returns False.

        @param time: Time.

        @param index: Optional index.

        @param view: Optional view.

        @return: True if succeeded, False otherwise.
        """
        ...

    def max(self) -> ...:
        """
        Maximum value.
        """
        ...

    def maximum(self, *args, **kwargs):
        """
        self.max() -> Maximum value.

        @return: Maximum value.
        """
        ...

    def min(self) -> ...:
        """
        Minimum value.
        """
        ...

    def minimum(self, *args, **kwargs):
        """
        self.min() -> Minimum value.

        @return: Minimum value.
        """
        ...

    def notDefault(self) -> bool:
        """
        True if any of the values is not set to the default, False otherwise.
        """
        ...

    def removeKey(self, index, view) -> bool:
        """
        Remove key.

        @param index: Optional index.

        @param view: Optional view.

        @return: True if succeeded, False otherwise.
        """
        ...

    def removeKeyAt(self, time, index, view) -> bool:
        """
        Remove keyframe at specified time, optional index and view. Return True if successful.

        @param time: Time.

        @param index: Optional index.

        @param view: Optional view.

        @return: True if succeeded, False otherwise.
        """
        ...

    def resize(self, w, h) -> bool:
        """
        Resize the array.

        @param w: New width

        @param h: Optional new height

        @return: True if successful, False otherwise.
        """
        ...

    def setAnimated(self, index, view) -> bool:
        """
        Create an Animation object. Return True if successful, in which case caller must initialise it by calling setValue() or setValueAt().

        @param index: Optional index.

        @param view: Optional view.

        @return: True if succeeded, False otherwise.
        """
        ...

    def setDefaultValue(self, s) -> None:
        """
        @param s: Sequence of floating-point values.

        @return: None.
        """
        ...

    def setExpression(self, expression, channel=-1, view=None) -> bool:
        """
        Set the expression for a knob. You can optionally specify a channel to set the expression for.



        @param expression: The new expression for the knob. This should be a String.

        @param channel: Optional parameter, specifying the channel to set the expression for. This should be an integer.

        @param view: Optional view parameter. Without, this command will set the expression for the current view the interface is displaying. Can be the name of the view or the index.

        @return: True if successful, False if not.
        """
        ...

    def setKeyAt(self, time, index, view) -> None:
        """
        Set a key on element 'index', at time and view.

        @param time: Time.

        @param index: Optional index.

        @param view: Optional view.

        @return: None.
        """
        ...

    def setRange(self, f1: ..., f2: ...) -> None:
        """
        Set range of values.

        @param f1 Min value.

        @param f2 Max value.

        @return: None.
        """
        ...

    def setSingleValue(self, b, view) -> None:
        """
        Set to just hold a single value or not.

        @param b: Boolean object.

        @param view: Optional view. Default is current view.

        @return: None.
        """
        ...

    def setValue(
        self,
        value: Union[float, Sequence[float]],
        /,
        *,
        index: int = ...,
        time: int = ...,
        view: Str = ...,
    ) -> bool:
        """
        Set index to value at time and view.

        @param value: Floating point value.

        @param index: Optional index.

        @param time: Optional time.

        @param view: Optional view.

        @return: True if value changed, False otherwise. Safe to ignore.
        """
        ...

    def setValueAt(self, value, time, index, view) -> bool:
        """
        Set value of element 'index' at time for view. If the knob is animated, it will set a new keyframe or change an existing one. Index and view are optional. Return True if successful.

        @param value: Floating point value.

        @param time: Time.

        @param index: Optional index.

        @param view: Optional view.

        @return: True if value changed, False otherwise. Safe to ignore.
        """
        ...

    def singleValue(self, view) -> bool:
        """
        @param view: Optional view. Default is current view.

        @return: True if holds a single value.
        """
        ...

    def splitView(self, view) -> None:
        """
        Split the view away from the current knob value.

        @param view: Optional view. Default is current view.

        @return: None.
        """
        ...

    def toScript(self, quote, context) -> Str:
        """
        Return the value of the knob in script syntax.

        @param quote: Optional, default is False. Specify True to return the knob value quoted in {}.

        @param context: Optional context, default is current, None will be "contextless" (all views, all keys) as in a .nk file.

        @return: String.
        """
        ...

    def unsplitView(self, view) -> None:
        """
        Unsplit the view so that it shares a value with other views.

        @param view: Optional view. Default is current view.

        @return: None.
        """
        ...

    def value(
        self, index: int = 0, view=..., time: int = ...
    ) -> Union[float, list[float]]:
        """
        @param index: Optional index. Default is 0.

        @param view: Optional view.

        @param time: Optional time.

        @return: Floating point or List of floating point values (in case some are different).
        """
        ...

    def valueAt(self, time, index, view) -> Union[list[float], float]:
        """
        Return value for this knob at specified time, optional index and view.

        @param time: Time.

        @param index: Optional index. Default is 0.

        @param view: Optional view.

        @return: Floating point or List of floating point values (in case some are different).
        """
        ...

    def vect(self) -> list[object]:
        """
        List of knob values.
        """
        ...

    def width(self) -> int:
        """
        Width of array of values.
        """
        ...
    ...

class Axis_Knob(Knob):
    """
    A knob which describes a 3D affine transformation, by combining rotations around each principal axis, scaling, translation, skew and a pivot point.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def pivot(self) -> XYZ_Knob:
        """
        Return pivot knob.
        """
        ...

    def rotate(self) -> XYZ_Knob:
        """
        Return rotation knob.
        """
        ...

    def scale(self) -> Scale_Knob:
        """
        Return scale knob.
        """
        ...

    def skew(self) -> XYZ_Knob:
        """
        Return skew knob.
        """
        ...

    def translate(self) -> XYZ_Knob:
        """
        Return translation knob.
        """
        ...

    def uniformScale(self) -> Double_Knob:
        """
        Return uniform scale knob.
        """
        ...

    def value(self) -> _nukemath.Matrix4:
        """
        Return the transform matrix formed by combining the input knob values for translate, rotate, scale, skew and pivot.
        """
        ...
    ...

class BBox_Knob(Array_Knob):
    """
    A knob which holds a bounding box.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def fromDict(self, box) -> None:
        """
        Set the bounding box from the given box.

        @param box: Dictionary containing the x, y, r and t keys.

        @return: None
        """
        ...

    def names(self, *args, **kwargs):
        """
        Return name for dimension 'i'
        """
        ...

    def r(self, *args, **kwargs):
        """
        Return value for R extent.
        """
        ...

    def setR(self, *args, **kwargs):
        """
        Set value for R extent.
        """
        ...

    def setT(self, *args, **kwargs):
        """
        Set value for T extent.
        """
        ...

    def setX(self, *args, **kwargs):
        """
        Set value for X position.
        """
        ...

    def setY(self, *args, **kwargs):
        """
        Set value for Y position.
        """
        ...

    def t(self, *args, **kwargs):
        """
        Return value for T extent.
        """
        ...

    def toDict(self) -> dict:
        """
        Returns the bounding box as a dict with x, y, r, and t keys.

        @return: dict with x, y, r and t keys
        """
        ...

    def value(self, *args, **kwargs):
        """
        Return value for dimension 'i'
        """
        ...

    def x(self, *args, **kwargs):
        """
        Return value for X position.
        """
        ...

    def y(self, *args, **kwargs):
        """
        Return value for Y position.
        """
        ...
    ...

class BackdropNode(Node):
    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...

    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...

    def __str__(self, *args, **kwargs):
        """
        x.__str__() <==> Str(x)
        """
        ...

    def getNodes(self) -> list[Node]:
        """
        Get the nodes contained inside a backdrop node
        Example:
        backdrop = nuke.toNode("BackdropNode1")
        nodesInBackdrop = backdrop.getNodes()

        @return: a list of nodes contained inside the backdrop.
        """
        ...

    def selectNodes(self, selectNodes: bool = ...) -> None:
        """
        Select or deselect all nodes in backdrop node
        Example:
        backdrop = nuke.toNode("BackdropNode1")
        backdrop.selectNodes(True)

        @return: None.
        """
        ...
    ...

class BeginTabGroup_Knob(Knob):
    """
    Begin a group of tabs. Subsequent knobs will all be part of the same tab group, until a matching EndTabGroup knob is found.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    ...

class Bitmask_Knob(Enumeration_Knob):
    """
    Bitmask_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    ...

class Boolean_Knob(Array_Knob):
    """
    A knob which holds a boolean value. This appears in a Node panel as a check box.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ): ...
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        value: bool = ...,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def setValue(self, b: bool) -> bool:
        """
        Set the boolean value of this knob.
        @param b: Boolean convertible object.
        @return: True if modified, False otherwise.
        """
        ...

    def value(self) -> bool:
        """
        Get the boolean value for this knob.
        @return: True or False.
        """
        ...
    ...

class Box:
    """
    A 2-dimensional rectangle. Described by left, right, top and bottom coords (width and height are calculated as necessary).
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def centerX(self) -> float:
        """
        Return center in X.
        """
        ...

    def centerY(self) -> float:
        """
        Return height in Y.
        """
        ...

    def clampX(self, x) -> int:
        """
        Return x reStricted to pointing at a pixel in the box.
        """
        ...

    def clampY(self, y) -> int:
        """
        Return y reStricted to pointing at a pixel in the box.
        """
        ...

    def clear(self) -> None:
        """
        Set to is_constant().
        """
        ...

    def h(self) -> int:
        """
        Return height.
        """
        ...

    def intersect(self, x, y, r, t) -> None:
        """
        Intersect with the given edges.
        """
        ...

    def isConstant(self) -> bool:
        """
        True if box is 1x1 in both directions, False otherwise
        """
        ...

    def merge(self, x, y, r, t) -> None:
        """
        Merge with the given edges.
        """
        ...

    def move(self, dx, dy) -> None:
        """
        Move all the sides and thus the entire box by the given deltas.
        """
        ...

    def pad(self, dx, dy, dr, dt) -> None:
        """
        Move all the sides and thus the entire box by the given deltas.
        """
        ...

    def r(self) -> int:
        """
        Return the right edge of the box.
        """
        ...

    def set(self, x, y, r, t) -> None:
        """
        Set all values at once.
        """
        ...

    def setH(self, n) -> None:
        """
        Set height by moving top edge.
        """
        ...

    def setR(self, n) -> None:
        """
        Set the right edge. The parameter n is an integer.
        """
        ...

    def setT(self, n) -> None:
        """
        Set top edge.
        """
        ...

    def setW(self, n) -> None:
        """
        Set width by moving right edge.
        """
        ...

    def setX(self, n) -> None:
        """
        Set the left edge. The parameter n is an integer.
        """
        ...

    def setY(self, n) -> None:
        """
        Set the bottom edge. The parameter n is an integer.
        """
        ...

    def t(self) -> int:
        """
        Return top edge.
        """
        ...

    def w(self) -> int:
        """
        Return width.
        """
        ...

    def x(self) -> int:
        """
        The left edge of the box.
        """
        ...

    def y(self) -> int:
        """
        Return the bottom edge.
        """
        ...
    ...

class Box3_Knob(Array_Knob):
    """
    A 3-dimensional box.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def f(self, *args, **kwargs):
        """
        Return value for F extent. F (far) is the maximum Z extent of the box.
        """
        ...

    def n(self, *args, **kwargs):
        """
        Return value for N position. N (near) is the minimum Z extent of the box.
        """
        ...

    def names(self, *args, **kwargs):
        """
        Return name for dimension 'i'
        """
        ...

    def r(self, *args, **kwargs):
        """
        Return value for R extent. R (right) is the right extent of the box.
        """
        ...

    def setF(self, *args, **kwargs):
        """
        Set value for F extent. F (far) is the maximum Z extent of the box.
        """
        ...

    def setN(self, *args, **kwargs):
        """
        Set value for N position. N (near) is the minimum Z extent of the box.
        """
        ...

    def setR(self, *args, **kwargs):
        """
        Set value for R extent. R (right) is the right extent of the box.
        """
        ...

    def setT(self, *args, **kwargs):
        """
        Set value for T extent. T (top) is the maximum vertical extent of the box.
        """
        ...

    def setX(self, *args, **kwargs):
        """
        Set value for X position. X is the minimum horizontal extent of the box.
        """
        ...

    def setY(self, *args, **kwargs):
        """
        Set value for Y position. Y is the minimum vertical extent of the box.
        """
        ...

    def t(self, *args, **kwargs):
        """
        Return value for T extent. T (top) is the maximum vertical extent of the box.
        """
        ...

    def value(self, *args, **kwargs):
        """
        Return value for dimension 'i'
        """
        ...

    def x(self, *args, **kwargs):
        """
        Return value for X position. X is the minimum horizontal extent of the box.
        """
        ...

    def y(self, *args, **kwargs):
        """
        Return value for Y position. Y is the minimum vertical extent of the box.
        """
        ...
    ...

class CancelledError(Exception):
    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """

    ...

class CascadingEnumeration_Knob(Enumeration_Knob):
    """
    Stores a single value between 0 and some maximum, and manages a

    set of keywords visible to the user. The words themselves are

    displayed on a pulldown list in the user interface, and are written

    to the saved scripts (so that the numerical values can change). To

    create cascading submenus simply use the forward slash ( '/' )

    e.g. menu/item1self.__init__(name, label, items) -> None

    @param name: Name.

    @param label: Label.

    @param items: List of Strings.

    Example:

    k = nuke.Enumeration_Knob('MyEnumKnobName', 'MyEnumKnobLabel', ['menu1/label1', 'label2'])
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class ChannelMask_Knob(Channel_Knob):
    """
    ChannelMask_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Channel_Knob(Knob):
    """
    A knob which lets you select a layer and enable or disable individual channels.

    self.__init__(s, label, depth) -> None

    ConStructor.

    @param s: name.

    @param label: Optional name to appear in GUI. Defaults to the knob's name.

    @param depth: Optional number of channels with zero being the Nuke default number of channels. Defaults to 0.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ): ...
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        depth: int = ...,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def channelSelector(self) -> bool:
        """ """
        ...

    def checkMarks(self) -> bool:
        """ """
        ...

    def depth(self) -> int:
        """
        Get the channel depth.

        @return: The depth of the channel as an int.
        """
        ...

    def enableChannel(self, name, b) -> None:
        """
        Enable or disable a channel.

        @param name: The name of the channel.

        @param b: True to enable the channel, False to disable it.

        @return: None
        """
        ...

    def inputKnob(self) -> bool:
        """ """
        ...

    def inputNumber(self) -> int:
        """ """
        ...

    def isChannelEnabled(self, name) -> bool:
        """
        Test if a channel is enabled.

        @param name: The name of the channel.@return: True if the channel is enabled, False otherwise.
        """
        ...

    def layerSelector(self) -> bool:
        """ """
        ...

    def setEnable(self, name) -> None:
        """
        Enable a channel.

        @param name: The name of the channel to enable.

        @return: None
        """
        ...

    def setInput(self, num) -> None:
        """
        Set the input number for this knob.@param num: The number of the new input.

        @return: None
        """
        ...

    def setValue(self, name: Str) -> None:
        """
        Set the selected channel using the channel name.

        @param name: The name of the new channel as a String.

        @return: None

        @raise ValueError exception if the channel doesn't exist.
        """
        ...

    def value(self) -> Str:
        """
        Get the name of the selected channel.

        @return: The name of the channel as a String.
        """
        ...
    ...

class ColorChip_Knob(Unsigned_Knob):
    """
    A knob which holds a single unsigned int that describes a user interface colour. The color format is 0xRRGGBB00.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Color_Knob(Array_Knob):
    """
    A knob which holds a color. Provides a UI for picking colours as well as editing the values directly.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def inputNumber(self) -> int:
        """
        Return input number.
        """
        ...

    def names(self, n) -> Str:
        """
        Return name for dimension n. The argument n is an integer.
        """
        ...

    def array(self) -> list[float]:
        """
        List of knob values.
        """
        ...
    ...

class Disable_Knob(Boolean_Knob):
    """
    A knob which holds a boolean value representing the disabled state of a node. This appears in a Node panel as a check box.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def setValue(self, b) -> bool:
        """
        Set the boolean value of this knob.

        @param b: Boolean convertible object.

        @return: True if modified, False otherwise.
        """
        ...

    def value(self) -> bool:
        """
        Get the boolean value for this knob.

        @return: True or False.
        """
        ...
    ...

class Double_Knob(Array_Knob):
    """
    A knob which holds one or more double-precision floating point values.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class EditableEnumeration_Knob(Enumeration_Knob):
    """
    Stores a single value between 0 and some maximum, and manages a

    set of Radio Buttons visible to the user. This is essentially an

    Enumeration_Knob with a different widget.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def enumName(self, n) -> Str:
        """
        Return name of enumeration n. The argument n is an integer and in the range of 0 and numValues. Deprecated.
        """
        ...

    def numValues(self) -> int:
        """
        Return number of values. Deprecated.
        """
        ...

    def setValue(self, item) -> None:
        """
        Set the current value. item will first be converted into a String and matched against the enum values.

        If this fails, it will attempt to be used as an index into the enum.

        @param item: String or Integer.

        @return: None.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.setValue('exr')
        """
        ...

    def setValues(self, items) -> None:
        """
        (Re)initialise knob to the supplied list of items.

        @param items: The new list of values.

        @return: None.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.setValues(['exr'])
        """
        ...

    def value(self) -> Str:
        """
        Current value.

        @return: String.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.value()
        """
        ...

    def values(self) -> list[Str]:
        """
        Return list of items.

        @return: List of Strings.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.values()
        """
        ...
    ...

class EndTabGroup_Knob(Knob):
    """
    End a group of tabs. This is only valid when a BeginTabGroup knob has already been used.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    ...

class Enumeration_Knob(Unsigned_Knob):
    """
    Stores a single value between 0 and some maximum, and manages a

    set of keywords visible to the user. The words themselves are

    displayed on a pulldown list in the user interface, and are written

    to the saved scripts (so that the numerical values can change).

    self.__init__(name, label, items) -> None

    @param name: Name.

    @param label: Label.

    @param items: List of Strings.

    Example:

    k = nuke.Enumeration_Knob('MyEnumKnobName', 'MyEnumKnobLabel', ['label1', 'label2'])
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    def __init__(
        self,
        name: Str,
        label: Optional[Str],
        options: Sequence[Str],
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def enumName(self, n: int) -> Str:
        """
        Return name of enumeration n. The argument n is an integer and in the range of 0 and numValues. Deprecated.
        """
        ...

    def numValues(self) -> int:
        """
        Return number of values. Deprecated.
        """
        ...

    def setValue(self, item: Str) -> None:
        """
        Set the current value. item will first be converted into a String and matched against the enum values.

        If this fails, it will attempt to be used as an index into the enum.

        @param item: String or Integer.

        @return: None.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.setValue('exr')
        """
        ...

    def setValues(self, items: Sequence[Str]) -> None:
        """
        (Re)initialise knob to the supplied list of items.

        @param items: The new list of values.

        @return: None.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.setValues(['exr'])
        """
        ...

    def value(self) -> Str:
        """
        Current value.

        @return: String.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.value()
        """
        ...

    def values(self) -> list[Str]:
        """
        Return list of items.

        @return: List of Strings.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.values()
        """
        ...
    ...

class EvalString_Knob(String_Knob):
    """
    A String-valued knob which evaluates it's value as a TCL expression.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def evaluate(self, frame: int = ...) -> Str:
        """
        Evaluate the String, performing substitutions.

        @return: String.
        """
        ...
    ...

class Eyedropper_Knob(AColor_Knob):
    """
    Eyedropper_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class File_Knob(EvalString_Knob):
    """
    A knob which holds a filename. When it appears in a Node panel it provides a text field to show the filename and a button which opens the file chooser dialog.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def fromScript(self, s: Str) -> None:
        """
        Assign String to knob.

        @param s: String to assign.

        @return: None.
        """
        ...

    def fromUserText(self, s: Str) -> None:
        """
        Assign String to knob, parses frame range off the end and opens file to get set the format.

        @param s: String to assign.

        @return: None.
        """
        ...

    def getEvaluatedValue(self, oc: OutputContext = ...) -> Str:
        """
        self.getValue(oc) -> String.

        Returns the String on this knob, will be normalized to technical notation if sequence (%4d). Will also evaluate the String for any tcl expressions

        @parm oc: the output context to use, if None the knob uiContext will be used.

        @return: String.
        """
        ...

    def getValue(self, *args, **kwargs):
        """
        self.getEvaluatedValue() -> String.

        Returns the String on this knob, will be normalized to technical notation if sequence (%4d).

        @return: String.
        """
        ...

    def setValue(
        self,
        s: Str,
        /,
    ) -> None:
        """
        self.fromScript(s) -> None.

        Assign String to knob.

        @param s: String to assign.

        @return: None.
        """
        ...

    def value(self) -> Str:
        """
        self.getEvaluatedValue() -> String.

        Returns the String on this knob, will be normalized to technical notation if sequence (%4d).

        @return: String.
        """
        ...
    ...

class Format:
    """
    A format.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        width: int,
        height: int,
        x: int,
        y: int,
        right: int,
        top: int,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def add(self, name) -> None:
        """
        Add this instance to a list of "named" formats. The name parameter is the name of the list to add the format to.
        """
        ...

    def fromUV(self, u, v) -> list[int]:
        """
        Transform a UV coordinate in the range 0-1 into the format's XY range. Returns a list containing the x and y coordinates.

        @param u: The U coordinate.

        @param v: The V coordinate.

        @return: [x, y]
        """
        ...

    def height(self) -> int:
        """
        Return the height of image file in pixels.
        """
        ...

    def name(self) -> Str:
        """
        Returns the user-visible name of the format.
        """
        ...

    def pixelAspect(self) -> float:
        """
        Returns the pixel aspect ratio (pixel width divided by pixel height) for this format.
        """
        ...

    def r(self) -> int:
        """
        Return the right edge of image file in pixels.
        """
        ...

    def scaled(self, sx, sy, tx, ty) -> Format:
        """
        Scale and translate this format by sx, sy, tx and ty.



        @param sx: Scale factor in X.@param sy: Scale factor in Y.@param tx: Offset factor in X.@param ty: Offset factor in Y.@return: Format.
        """
        ...

    def setHeight(self, newHeight) -> None:
        """
        Set the height of image file in pixels. newHeight is the new height for the image; it should be a positive integer.
        """
        ...

    def setName(self, name) -> None:
        """
        Set name of this format. The name parameter is the new name for the format.
        """
        ...

    def setPixelAspect(self, aspectRatio) -> None:
        """
        Set a new pixel aspect ratio for this format. The aspectRatio parameter is the new ratio, found by dividing the desired pixel width by the desired pixel height.
        """
        ...

    def setR(self, newR) -> None:
        """
        Set the right edge of image file in pixels. newR is the new right edge for the image; it should be a positive integer.
        """
        ...

    def setT(self, newT) -> None:
        """
        Set the top edge of image file in pixels. newY is the new top edge for the image; it should be a positive integer.
        """
        ...

    def setWidth(self, newWidth) -> None:
        """
        Set the width of image file in pixels.newWidth is the new width for the image; it should be a positive integer.
        """
        ...

    def setX(self, newX) -> None:
        """
        Set the left edge of image file in pixels. newX is the new left edge for the  image; it should be a positive integer.
        """
        ...

    def setY(self, newY) -> None:
        """
        Set the bottom edge of image file in pixels. newY is the new bottom edge for the image; it should be a positive integer.
        """
        ...

    def t(self) -> int:
        """
        Return the top edge of image file in pixels.
        """
        ...

    def toUV(self, x, y) -> list[int]:
        """
        Back-transform an XY coordinate in the format's space into UV space.



        @param x: The X coordinate.

        @param y: The Y coordinate.

        @return: [u, v].
        """
        ...

    def width(self) -> int:
        """
        Return the width of image file in pixels.
        """
        ...

    def x(self) -> int:
        """
        Return the left edge of image file in pixels.
        """
        ...

    def y(self) -> int:
        """
        Return the bottom edge of image file in pixels.
        """
        ...
    ...

class Font_Knob(Knob):
    """
    A knob for choosing a font.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Format_Knob(Knob):
    """
    Format_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, name: Str, label: Optional[Str] = None, /):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def actualValue(self) -> Format:
        """
        Return value of knob.
        """
        ...

    def fromScript(self, s) -> bool:
        """
        Initialise from script s.
        True if succeeded, False otherwise
        """
        ...

    def name(self) -> Str:
        """
        Return name of knob.
        """
        ...

    def notDefault(self) -> bool:
        """
        True if set to its default value, False otherwise
        """
        ...

    def setValue(self, format) -> bool:
        """
        Set value of knob to format (either a Format object or a name of a format, e.g. "NTSC").
        True if succeeded, False otherwise
        """
        ...

    def toScript(self, quote, context=...) -> Str:
        """
        Return the value of the knob in script syntax.

        Pass True for quote to return results quoted in {}.

        Pass None for context to get results for all views and key times (as stored in a .nk file).
        """
        ...

    def value(self) -> Format:
        """
        Return value of knob.
        """
        ...
    ...

class FrameRange:
    """
    A frame range, with an upper and lower bound and an increment.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @overload
    def __init__(self, first: int, last: int, increment: int) -> None: ...
    @overload
    def __init__(self, s: Str) -> None:
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def __iter__(self) -> int:
        """
        x.__iter__() <==> iter(x)
        """
        ...

    def __str__(self) -> Str:
        """
        x.__str__() <==> Str(x)
        """
        ...

    def first(self) -> int:
        """
        return the first frame of the range.
        """
        ...

    def frames(self) -> int:
        """
        return the numbers of frames defined in the range.
        """
        ...

    def getFrame(self, n: int) -> int:
        """
        return the frame according to the index, parameter n must be between 0 and frames().
        """
        ...

    def increment(self) -> int:
        """
        return the increment between two frames.
        """
        ...

    def isInRange(self, n: int) -> bool:
        """
        return if the frame is inside the range.
        """
        ...

    def last(self) -> int:
        """
        return the last frame of the range.
        """
        ...

    def maxFrame(self) -> int:
        """
        return the maximum frame define in the range.
        """
        ...

    def minFrame(self) -> int:
        """
        return the minimum frame define in the range.
        """
        ...

    def next(self) -> int:
        """
        x.next() -> the next value, or raise StopIteration
        """
        ...

    def setFirst(self, n: int) -> None:
        """
        set the first frame of the range.
        """
        ...

    def setIncrement(self, n: int) -> None:
        """
        set the increment between two frames.
        """
        ...

    def setLast(self, n: int) -> None:
        """
        set the last frame of the range.
        """
        ...

    def stepFrame(self) -> int:
        """
        return the absolute increment between two frames.
        """
        ...
    ...

class FrameRanges:
    """
    A sequence of FrameRange objects with convenience functions for iterating over all frames in all ranges.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        o: Union[
            Str,
            list[FrameRange],
            list[Str],
            list[int],
        ] = ...,
    ) -> None:
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def __iter__(self) -> FrameRange:
        """
        x.__iter__() <==> iter(x)
        """
        ...

    def __str__(self) -> Str:
        """
        x.__str__() <==> Str(x)
        """
        ...

    def add(self, r: FrameRange) -> None:
        """
        add a new frame range.
        """
        ...

    def clear(self) -> None:
        """
        reset all store frame ranges.
        """
        ...

    def compact(self) -> None:
        """
        compact all the frame ranges.
        """
        ...

    def getRange(self) -> FrameRange:
        """
        return a range from the list
        """
        ...

    def maxFrame(self) -> int:
        """
        get maximum frame of all ranges.
        """
        ...

    def minFrame(self) -> int:
        """
        get minimum frame of all ranges.
        """
        ...

    def next(self) -> FrameRange:
        """
        x.next() -> the next value, or raise StopIteration
        """
        ...

    def size(self) -> int:
        """
        return the ranges number.
        """
        ...

    def toFrameList(self) -> list[int]:
        """
        return a list of frames in a vector
        """
        ...
    ...

class FreeType_Knob(Knob):
    """
    A knob which holds a font family and style name.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, name: Str, label: Optional[Str] = None, /):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def getValue(self) -> list[Str]:
        """
        Returns the font family/style on this knob.

        @return: [String, String].
        """
        ...

    def setValue(self, family: Str, style: Str) -> None:
        """
        self.setValue(filename,index) -> None.

        Change font family/style with a new one.

        It raises an exception if the font is not available.

        @param family: String of the font family name.

        @param style: String of the font style name.

        @param filename: Font filename.

        @param index: Face index.

        @return: None.
        """
        ...
    ...

class GeoSelect_Knob(Knob):
    """
    A knob which allows selection of parts of a 3D object.
    """

    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...

    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...

    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...

    def getGeometry(self) -> _geo.GeometryList:
        """
        Get the geometry which this knob can select from.
        """
        ...

    def getSelection(self) -> list[list[float]]:
        """
        Returns the selection weights for each vertex as a float. If you access the result as selection[obj][pt], then obj is the index of the object in the input geometry and pt is the index of the point in that object.
        """
        ...
    ...

class Gizmo(Group):
    def __getitem__(self, name: Str) -> Knob:
        """
        x.__getitem__(y) <==> x[y]
        """
        ...

    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...

    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...

    def __str__(self, *args, **kwargs):
        """
        x.__str__() <==> Str(x)
        """
        ...

    def command(self) -> Str:
        """
        Gizmo command.

        @return: String.
        """
        ...

    def filename(self) -> Str:
        """
        Gizmo filename.

        @return: String.
        """
        ...

    def makeGroup(self) -> Group:
        """
        Creates a Group node copy of the Gizmo node.

        @return: Group.
        """
        ...
    ...

class GlobalsEnvironment:
    """
    Dictionary-style object holding global Nuke state.

    Example:

    nuke.env['threads'] = 4
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __delitem__(self, *args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
        ...

    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...

    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...

    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...

    def __setitem__(self, *args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
        ...
    ...

class Group(Node):
    def __enter__(self, *args, **kwargs):
        """ """
        ...

    def __exit__(self, *args, **kwargs):
        """ """
        ...

    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...

    def __reduce_ex__(self, *args, **kwargs):
        """ """
        ...

    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...

    def __str__(self, *args, **kwargs):
        """
        x.__str__() <==> Str(x)
        """
        ...

    def begin(self) -> Group:
        """
        All python code that follows will be executed in the context of node. All names are evaluated relative to this object. Must be paired with end.

        @return: Group.
        """
        ...

    def connectSelectedNodes(self, backward, inputA) -> None:
        """
        Connect the selected nodes.

        @param backward.

        @param inputA.

        @return: None.
        """
        ...

    def end(self) -> None:
        """
        All python code that follows will no longer be executed in the context of node. Must be paired with begin.

        @return: None.
        """
        ...

    def expand(self) -> None:
        """
        Moves all nodes from the group node into its parent group, maintaining node input

        and output connections, and deletes the group.

        Returns the nodes that were moved, which will also be selected.

        @return: None.
        """
        ...

    def node(self, s: Str) -> Optional[Node]:
        """
        Locate a node by name.

        @param s: A String.

        @return: Node with name s or None.
        """
        ...

    def nodes(self) -> list[Node]:
        """
        List of nodes in group.

        @return: List of nodes
        """
        ...

    def numNodes(self) -> int:
        """
        Number of nodes in group.

        @return: Number of nodes
        """
        ...

    def output(self) -> Optional[Node]:
        """
        Return output node of group.

        @return: Node or None.
        """
        ...

    def run(self, callable) -> ...:
        """
        Execute in the context of node. All names are evaluated relative to this object.

        @param callable: callable to execute.

        @return: Result of callable.
        """
        ...

    def selectedNode(self) -> Optional[Node]:
        """
        Returns the node the user is most likely thinking about. This is the last node the user clicked on, if it is selected.  Otherwise it is an 'output' (one with no selected outputs) of the set of selected nodes. If no nodes are selected then None is returned.

        @return: Node or None.
        """
        ...

    def selectedNodes(self) -> Optional[Node]:
        """
        Selected nodes.

        @return: Node or None.
        """
        ...

    def splaySelectedNodes(self, backward, inputA) -> None:
        """
        Splay the selected nodes.

        @param backward.

        @param inputA.

        @return: None.
        """
        ...
    ...

class Hash:
    """
    A hash value for any number of objects.

    The append() method is used to add objects to the hash; the value will be recomputed efficiently as each new object is added.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...

    def __eq__(self, *args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
        ...

    def __ge__(self, *args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
        ...

    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...

    def __gt__(self, *args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
        ...

    def __hash__(self, *args, **kwargs):
        """
        x.__hash__() <==> hash(x)
        """
        ...

    def __le__(self, *args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
        ...

    def __lt__(self, *args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
        ...

    def __ne__(self, *args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
        ...

    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...

    def append(self, *args, **kwargs):
        """
        Add another value to the hash.
        """
        ...

    def getHash(self, *args, **kwargs):
        """
        Get the current value of the hash.
        """
        ...

    def reset(self, *args, **kwargs):
        """
        Reset the hash.
        """
        ...

    def setHash(self, *args, **kwargs):
        """
        Set the current value of the hash.
        """
        ...
    ...

class Help_Knob(Knob):
    """
    Help_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Histogram_Knob(Knob):
    """
    Histogram_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class IArray_Knob(Array_Knob):
    """
    IArray_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def dimensions(self, *args, **kwargs):
        """
        Return number of dimensions.
        """
        ...

    def height(self, *args, **kwargs):
        """
        Return height of the array.
        """
        ...

    def value(self, *args, **kwargs):
        """
        Return value of the array at position (x, y).
        """
        ...

    def width(self, *args, **kwargs):
        """
        Return width of the array.
        """
        ...
    ...

class Info:
    """
    An info object stores x, y, w and h values.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def h(self) -> float:
        """
        Return height.
        """
        ...

    def w(self) -> float:
        """
        Return width.
        """
        ...

    def x(self) -> float:
        """
        Return left edge.
        """
        ...

    def y(self) -> float:
        """
        Return the bottom edge.
        """
        ...
    ...

class Int_Knob(Array_Knob):
    """
    A knob which holds one or more integer values.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def setValue(self, val: int) -> bool:
        """
        Set the integer value of this knob.

        @param val: The new value. Must be an integer.

        @return: True if succeeded, False otherwise.
        """
        ...

    def value(self) -> int:
        """
        Get the integer value of this knob.

        @return: The value of this knob as an int.
        """
        ...
    ...

class Keyer_Knob(Array_Knob):
    """
    Keyer_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def names(self, n) -> Str:
        """
        @param n: The index of the name to return.

        @return: The name at position n.
        """
        ...

    def value(self, outputCtx, n) -> float:
        """
        Get the value of argument n.

        @param outputCtx: The OutputContext to evaluate the argument in.

        @param n: The index of the argument to get the value of.

        @return: The value of argument n.
        """
        ...
    ...

class Knob:
    """
    A modifiable control that appears (unless hidden) in the panel for a node.
    This is a base class that specific knob types inherit from.

    Knobs can be animated, have expressions, be disabled or hidden and more.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def Class(self) -> Str:
        """
        Class name.
        """
        ...

    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """ """
        ...

    def clearAnimated(self, *args, **kwargs):
        """
        Clear animation for channel 'c'. Return True if successful.
        """
        ...

    def clearFlag(self, f: int) -> None:
        """
        Clear flag.

        @param f: Flag.

        @return: None.
        """
        ...

    def critical(self, message) -> None:
        """
        @param message: message to put the knob in error, and do a popup.

        @return: None.
        """
        ...

    def debug(self, message) -> None:
        """
        @param message: message to put out to the error console, attached to the knob, if the verbosity level is set high enough.

        @return: None.
        """
        ...

    def enabled(self) -> bool:
        """
        True if the knob is enabled, False if it's disabled.
        """
        ...

    def error(self, message) -> None:
        """
        @param message: message to put the knob in error.

        @return: None.
        """
        ...

    def fromScript(self, __script: Str) -> None:
        """
        Initialise from script.
        """
        ...

    def fullyQualifiedName(self, channel=-1) -> Str:
        """
        Returns the fully-qualified name of the knob within the node. This can be useful for expression linking.



        @param channel: Optional parameter, specifies the channel number of the sub-knob (for example, channels of  0 and 1 would refer to the x and y of a XY_Knob respectively), leave blank or set to -1 to get the  qualified name of the knob only.

        @return: The String of the qualified knob or sub-knob, which can be used directly in expression links.
        """
        ...

    def getDerivative(self, *args, **kwargs):
        """
        Return derivative at time 't' for channel 'c'.
        """
        ...

    def getFlag(self, f: int) -> bool:
        """
        Returns whether the input flag is set.

        @param f: Flag.

        @return: True if set, False otherwise.
        """
        ...

    def getIntegral(self, *args, **kwargs):
        """
        Return integral at the interval [t1, t2] for channel 'c'.
        """
        ...

    def getKeyIndex(self, *args, **kwargs):
        """
        Return keyframe index at time 't' for channel 'c'.
        """
        ...

    def getKeyList(self, *args, **kwargs):
        """
        Get all unique keys on the knob.  Returns list.
        """
        ...

    def getKeyTime(self, *args, **kwargs):
        """
        Return index of the keyframe at time 't' for channel 'c'.
        """
        ...

    def getNthDerivative(self, *args, **kwargs):
        """
        Return nth derivative at time 't' for channel 'c'.
        """
        ...

    def getNumKeys(self, *args, **kwargs):
        """
        Return number of keyframes for channel 'c'.
        """
        ...

    def getValue(self, *args, **kwargs):
        """
        Return value at the current frame for channel 'c'.
        """
        ...

    def getValueAt(self, *args, **kwargs):
        """
        Return value at time 't' for channel 'c'.
        """
        ...

    def hasExpression(self, index=-1) -> bool:
        """
        Return True if animation at index 'index' has an expression.

        @param index: Optional index parameter. Defaults to -1 if not specified. This can be specified as a keyword parameter if desired.

        @return: True if has expression, False otherwise.
        """
        ...

    def isAnimated(self, *args, **kwargs):
        """
        Return True if channel 'c' is animated.
        """
        ...

    def isKey(self, *args, **kwargs):
        """
        Return True if there is a keyframe at the current frame for channel 'c'.
        """
        ...

    def isKeyAt(self, *args, **kwargs):
        """
        Return True if there is a keyframe at time 't' for channel 'c'.
        """
        ...

    def label(self) -> Str:
        """
        label.
        """
        ...

    def name(self) -> Str:
        """
        name.
        """
        ...

    def node(self) -> Node:
        """
        Return the node that this knob belongs to. If the node has been cloned, we'll always return a reference to the original.

        @return: The node which owns this knob, or None if the knob has no owner yet.
        """
        ...

    def removeKey(self, *args, **kwargs):
        """
        Remove key for channel 'c'. Return True if successful.
        """
        ...

    def removeKeyAt(self, *args, **kwargs):
        """
        Remove key at time 't' for channel 'c'. Return True if successful.
        """
        ...

    def setAnimated(self, *args, **kwargs):
        """
        Set channel 'c' to be animated.
        """
        ...

    def setEnabled(self, enabled: bool) -> None:
        """
        Enable or disable the knob.

        @param enabled: True to enable the knob, False to disable it.
        """
        ...

    def setExpression(
        self,
        expression: Str,
        channel: int = -1,
        view: Union[int, Str, None] = None,
    ) -> bool:
        """
        Set the expression for a knob. You can optionally specify a channel to set the expression for.



        @param expression: The new expression for the knob. This should be a String.

        @param channel: Optional parameter, specifying the channel to set the expression for. This should be an integer.

        @param view: Optional view parameter. Without, this command will set the expression for the current view the interface is displaying. Can be the name of the view or the index.

        @return: True if successful, False if not.
        """
        ...

    def setFlag(self, f: int) -> None:
        """
        Logical OR of the argument and existing knob flags.

        @param f: Flag.

        @return: None.
        """
        ...

    def setLabel(self, s: Str) -> None:
        """
        @param s: New label.

        @return: None.
        """
        ...

    def setName(self, s) -> None:
        """
        @param s: New name.

        @return: None.
        """
        ...

    def setTooltip(self, s) -> None:
        """
        @param s: New tooltip.

        @return: None.
        """
        ...

    def setValue(self, val: _Unknown, chan: Str = ..., /) -> bool:
        """
        Sets the value 'val' at channel 'chan'.
        @return: True if successful, False if not.

        **NOTICE**: should assert to concrete knob type instead.
        """
        ...

    def setValueAt(self, val, time, chan) -> bool:
        """
        Sets the value 'val' at channel 'chan' for time 'time'.

        @return: True if successful, False if not.
        """
        ...

    def setVisible(self, visible: bool) -> None:
        """
        Show or hide the knob.

        @param visible: True to show the knob, False to hide it.
        """
        ...

    def toScript(self, quote: bool = ..., context=...) -> Str:
        """
        Return the value of the knob in script syntax.

        Pass True for quote to return results quoted in {}.

        Pass None for context to get results for all views and key times (as stored in a .nk file).
        """
        ...

    def tooltip(self) -> Str:
        """
        tooltip.
        """
        ...

    def value(self, index: int = ...) -> object:
        """
        Return value at the current frame for channel 'c'.
        """
        ...

    def visible(self) -> bool:
        """
        True if the knob is visible, False if it's hidden.
        """
        ...

    def warning(self, message) -> None:
        """
        @param message: message to put a warning on the knob.

        @return: None.
        """
        ...
    ...

class KnobType:
    """
    Constants for use in parameters which require a knob type.
    """

    ...

class Layer:
    """
    A layer is a set of channels.
    """

    def __new__(cls, name: Str, channels: list[Str] = ...): ...
    def channels(self) -> list[Str]:
        """
        Get a list of the channels in this layer.

        @return: A list of Strings, where each String is the name of a channel in this layer.
        """
        ...

    def name(self) -> Str:
        """
        Get the layer name.

        @return: The layer name, as a String.
        """
        ...

    def setName(self, newName) -> None:
        """
        Set the name of this layer.

        @param newName: The new name for this layer.
        """
        ...

    def visible(self) -> bool:
        """
        Check whether the layer is visible.

        @return: True if visible, False if not.
        """
        ...
    ...

class Link_Knob(Knob):
    """
    Link_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def getLink(self) -> ...:
        """
        s
        """
        ...

    def getLinkedKnob(self) -> Knob:
        """ """
        ...

    def makeLink(self, s, t) -> None:
        """ """
        ...

    def setLink(self, s) -> None:
        """ """
        ...

    def setValue(self) -> None:
        """
        Set value of knob.
        """
        ...

    def value(self) -> Str:
        """
        Return value of knob.
        """
        ...
    ...

class LinkableKnobInfo:
    """
    A linkable knob description. Holds a reference to a knob that may be linked to, as well as an indication whether this knob should be used as part of an absolute or relative expression and whether it is enabled.
    """

    def __delattr__(self, *args, **kwargs):
        """
        x.__delattr__('name') <==> del x.name
        """
        ...

    def __getattribute__(self, *args, **kwargs):
        """
        x.__getattribute__('name') <==> x.name
        """
        ...

    def __setattr__(self, *args, **kwargs):
        """
        x.__setattr__('name', value) <==> x.name = value
        """
        ...

    def absolute(self) -> bool:
        """
        Returns whether the values of this knob should be treated as absolute or relative. This may be useful for positions.
        """
        ...

    def displayName(self) -> Str:
        """
        Returns the custom display name that will appear in Link-to menus.
        """
        ...

    def enabled(self) -> bool:
        """
        Returns whether the knob is currently enabled or not.
        """
        ...

    def indices(self) -> list:
        """
        Returns a list of the knob channels that should be used with this linkable knob.
        """
        ...

    def knob(self) -> Knob:
        """
        Returns the knob that may be linked to.
        """
        ...
    ...

class LookupCurves_Knob(Knob):
    """
    Provide a set of user-editable lookup curves.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def addCurve(self, curve, expr=None) -> None:
        """
        Adds a curve.

        @param curve: The name of an animation curve, or an AnimationCurve instance.

        @param expr: Optional parameter giving an expression for the curve.

        @return: None
        """
        ...

    def delCurve(self, curve) -> None:
        """
        Deletes a curve.

        @param curve: The name of the animation curve.

        @return: None
        """
        ...

    def editCurve(self, curve, expr=None) -> None:
        """
        Edits an existing curve.

        @param curve: The name of an animation curve.

        @param expr: The new expression for the curve.

        @return: None
        """
        ...
    ...

class Lut:
    """
    Lut
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def fromByte(self, float) -> float:
        """
        Converts byte values in the range 0-255 to floating point.
        """
        ...

    def fromByteSingle(self, *args, **kwargs):
        """
        self.fromByte(float) -> float.

        Converts byte values in the range 0-255 to floating point.
        """
        ...

    def fromFloat(self, src, alpha) -> list[float]:
        """
        Convert a sequence of floating-point values to from_byte(x*255).
        Alpha is an optional argument and if present unpremultiply by alpha, convert, and then multiply back.
        """
        ...

    def isLinear(self) -> bool:
        """
        True if toByte(x) appears to return x*255, False otherwise
        """
        ...

    def isZero(self) -> bool:
        """
        True if toByte(0) returns a value <= 0, False otherwise
        """
        ...

    def toByte(self, float) -> float:
        """
        Converts floating point values to byte values in the range 0-255.
        """
        ...

    def toByteSingle(self, *args, **kwargs):
        """
        self.toByte(float) -> float.

        Converts floating point values to byte values in the range 0-255.
        """
        ...

    def toFloat(self, src, alpha) -> list[float]:
        """
        Convert a sequence of floating-point values to to_byte(x)/255.
        Alpha is an optional argument and if present unpremultiply by alpha, convert, and then multiply back.
        """
        ...
    ...

class Menu(MenuItem):
    """
    Menu
    """

    def addAction(self, action) -> bool:
        """
        Adds the QAction to the menu.
        """
        ...

    def addCommand(
        self,
        name: Str,
        command: Union[Str, Callable[..., object]] = ...,
        shortcut: Str = ...,
        icon: Str = ...,
        tooltip: Str = ...,
        index: int = ...,
        readonly: bool = ...,
        shortcutContext: int = ...,
    ) -> MenuItem:
        """
        Add a new command to this menu/toolbar. Note that when invoked, the command is automatically enclosed in an undo group, so that undo/redo functionality works. Optional arguments can be specified by name.

        Note that if the command argument is not specified, then the command will be auto-created as a "nuke.createNode()" using the name argument as the node to create.



        Example:

        menubar = nuke.menu('Nuke')

        fileMenu = menubar.findItem('File')

        fileMenu.addCommand('NewCommand', 'print 10', shortcut='t')



        @param name: The name for the menu/toolbar item. The name may contain submenu names delimited by '/' or '', and submenus are created as needed.

        @param command: Optional. The command to add to the menu/toolbar. This can be a String to evaluate or a Python Callable (function, method, etc) to run.

        @param shortcut: Optional. The keyboard shortcut for the command, such as 'R', 'F5' or 'Ctrl-H'. Note that this overrides pre-existing other uses for the shortcut.

        @param icon: Optional. An icon for the command. This should be a path to an icon in the nuke.pluginPath() directory. If the icon is not specified, Nuke will automatically try to find an icon with the name argument and .png appended to it.

        @param tooltip: Optional. The tooltip text, displayed on mouseover for toolbar buttons.

        @param index: Optional. The position to insert the new item in, in the menu/toolbar. This defaults to last in the menu/toolbar.

        @param readonly: Optional. True/False for whether the item should be available when the menu is invoked in a read-only context.

        @param shortcutContext: Optional. Sets the shortcut context (0==Window, 1=Application, 2=DAG).

        @return: The menu/toolbar item that was added to hold the command.
        """
        ...

    def addMenu(
        self,
        name: Str,
        *,
        icon: Str = ...,
        tooltip: Str = ...,
        index: int = ...,
    ) -> Menu:
        """
        Add a new submenu.

        @param **kwargs The following keyword arguments are accepted:

                        name      The name for the menu/toolbar item

                        icon      An icon for the menu. Loaded from the nuke search path.

                        tooltip   The tooltip text.

                        index     The position to insert the menu in. Use -1 to add to the end of the menu.

        @return: The submenu that was added.
        """
        ...

    def addSeparator(self, index: int = ...) -> MenuItem:
        """
        Add a separator to this menu/toolbar.

        @param **kwargs The following keyword arguments are accepted:

        index     The position to insert the new separator in, in the menu/toolbar.

        @return: The separator that was created.
        """
        ...

    def clearMenu(self, *args, **kwargs):
        """
        self.clearMenu()

        Clears a menu.

        @param **kwargs The following keyword arguments are accepted:

                        name      The name for the menu/toolbar item

        @return: true if cleared, false if menu not found
        """
        ...

    def findItem(self, name: Str) -> Optional[Menu]:
        """
        Finds a submenu or command with a particular name.

        @param name: The name to search for.

        @return: The submenu or command we found, or None if we could not find anything.
        """
        ...

    def items(self) -> None:
        """
        Returns a list of sub menu items.
        """
        ...

    def menu(self, name: Str) -> Optional[MenuItem]:
        """
        Finds a submenu or command with a particular name.

        @param name: The name to search for.

        @return: The submenu or command we found, or None if we could not find anything.
        """
        ...

    def name(self) -> Str:
        """
        Returns the name of the menu item.
        """
        ...

    def removeItem(self, name: Str) -> bool:
        """
        Removes a submenu or command with a particular name. If the containing menu becomes empty, it will be removed too.

        @param name: The name to remove for.

        @return: true if removed, false if menu not found
        """
        ...

    def updateMenuItems(self) -> None:
        """
        Updates menu items' states. Call on about to show menu.
        """
        ...
    ...

class MenuBar:
    """
    MenuBar
    """

    def addAction(self, action) -> bool:
        """
        Adds the QAction to the menu.
        """
        ...

    def addCommand(
        self, name, command, shortcut, icon, tooltip, index, readonly
    ) -> Union[Menu, ToolBar]:
        """
        Add a new command to this menu/toolbar. Note that when invoked, the command is automatically enclosed in an undo group, so that undo/redo functionality works. Optional arguments can be specified by name.
        Note that if the command argument is not specified, then the command will be auto-created as a "nuke.createNode()" using the name argument as the node to create.

        Example:
        menubar = nuke.menu('Nuke')
        fileMenu = menubar.findItem('File')
        fileMenu.addCommand('NewCommand', 'print 10', shortcut='t')

        @param name: The name for the menu/toolbar item. The name may contain submenu names delimited by '/' or '', and submenus are created as needed.
        @param command: Optional. The command to add to the menu/toolbar. This can be a String to evaluate or a Python Callable (function, method, etc) to run.
        @param shortcut: Optional. The keyboard shortcut for the command, such as 'R', 'F5' or 'Ctrl-H'. Note that this overrides pre-existing other uses for the shortcut.
        @param icon: Optional. An icon for the command. This should be a path to an icon in the nuke.pluginPath() directory. If the icon is not specified, Nuke will automatically try to find an icon with the name argument and .png appended to it.
        @param tooltip: Optional. The tooltip text, displayed on mouseover for toolbar buttons.
        @param index: Optional. The position to insert the new item in, in the menu/toolbar. This defaults to last in the menu/toolbar.
        @param readonly: Optional. True/False for whether the item should be available when the menu is invoked in a read-only context.
        @param shortcutContext: Optional. Sets the shortcut context (0==Window, 1=Application, 2=DAG).
        @return: The menu/toolbar item that was added to hold the command.
        """
        ...

    def addMenu(self, **kwargs) -> Menu:
        """
        Add a new submenu.
        @param **kwargs The following keyword arguments are accepted:
                        name      The name for the menu/toolbar item
                        icon      An icon for the menu. Loaded from the nuke search path.
                        tooltip   The tooltip text.
                        index     The position to insert the menu in. Use -1 to add to the end of the menu.
        @return: The submenu that was added.
        """
        ...

    def addSeparator(self, **kwargs) -> ...:
        """
        Add a separator to this menu/toolbar.
        @param **kwargs The following keyword arguments are accepted:
        index     The position to insert the new separator in, in the menu/toolbar.
        @return: The separator that was created.
        """
        ...

    def clearMenu(self, *args, **kwargs):
        """
        self.clearMenu()
        Clears a menu.
        @param **kwargs The following keyword arguments are accepted:
                        name      The name for the menu/toolbar item
        @return: true if cleared, false if menu not found
        """
        ...

    def findItem(self, name) -> Optional[Menu]:
        """
        Finds a submenu or command with a particular name.
        @param name: The name to search for.
        @return: The submenu or command we found, or None if we could not find anything.
        """
        ...

    def items(self) -> None:
        """
        Returns a list of sub menu items.
        """
        ...

    def menu(self, name) -> Optional[Menu]:
        """
        Finds a submenu or command with a particular name.
        @param name: The name to search for.
        @return: The submenu or command we found, or None if we could not find anything.
        """
        ...

    def name(self) -> Str:
        """
        Returns the name of the menu item.
        """
        ...

    def removeItem(self, name) -> None:
        """
        Removes a submenu or command with a particular name. If the containing menu becomes empty, it will be removed too.
        @param name: The name to remove for.
        @return: true if removed, false if menu not found
        """
        ...

    def updateMenuItems(self) -> None:
        """
        Updates menu items' states. Call on about to show menu.
        """
        ...
    ...

class MenuItem:
    """
    MenuItem
    """

    def action(self) -> None:
        """
        Get the action associated with this menu item.
        """
        ...

    def icon(self) -> Str:
        """
        Returns the name of the icon on this menu item as path of the icon.
        """
        ...

    def invoke(self) -> None:
        """
        Perform the action associated with this menu item.
        """
        ...

    def name(self) -> Str:
        """
        Returns the name of the menu item.
        """
        ...

    def script(self) -> Str:
        """
        Returns the script that gets executed for this menu item.
        """
        ...

    def setEnabled(self, enabled, recursive) -> None:
        """
        Enable or disable the item.

        @param enabled: True to enable the object; False to disable it.

        @param recursive: True to also setEnabled on submenu actions.
        """
        ...

    def setIcon(self, icon) -> None:
        """
        Set the icon on this menu item.

        @param icon: the new icon as a path
        """
        ...

    def setScript(self, script) -> None:
        """
        Set the script to be executed for this menu item.

        Note: To call a python script file, you can use the execfile() function. i.e:

        menu.setScript("execfile('script.py')")
        """
        ...

    def setShortcut(self, keySequence: Str) -> None:
        """
        Set the keyboard shortcut on this menu item.

        @param keySequence: the new shortcut in PortableText format, e.g. "Ctrl+Shift+P"
        """
        ...

    def setVisible(self, visible: bool) -> None:
        """
        Show or hide the item.

        @param visible: True to show the object; False to hide it.
        """
        ...

    def shortcut(self) -> Str:
        """
        Returns the keyboard shortcut on this menu item. The format of this is the PortableText format. It will return a String such as "Ctrl+Shift+P". Note that on Mac OS X the Command key is equivalent to Ctrl.
        """
        ...
    ...

class MultiView_Knob(Knob):
    """
    MultiView_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def fromScript(self, s) -> bool:
        """
        Initialise from script s.
        True if succeeded, False otherwise
        """
        ...

    def notDefault(self) -> bool:
        """
        True if set to its default value, False otherwise
        """
        ...

    def setValue(self, *args, **kwargs):
        """
        fromScript(s) -> True if succeeded, False otherwise.



        Initialise from script s.
        """
        ...

    def toScript(self, quote, context=...) -> Str:
        """
        Return the value of the knob in script syntax.

        Pass True for quote to return results quoted in {}.

        Pass None for context to get results for all views and key times (as stored in a .nk file).
        """
        ...

    def value(self, *args, **kwargs):
        """
        toScript(quote, context=current) -> String.

        Return the value of the knob in script syntax.

        Pass True for quote to return results quoted in {}.

        Pass None for context to get results for all views and key times (as stored in a .nk file).
        """
        ...
    ...

class Multiline_Eval_String_Knob(EvalString_Knob):
    """
    A knob which evaluates it's String value as a TCL expression. It provides a multiline text area when it appears in a Node panel.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Node:
    def __new__(
        cls,
        node: Str,
        args: Str = ...,
        /,
        inpanel: bool = True,
    ) -> Node:
        """
        NOT OFFICIAL DOCUMENTED
        seems same as `createNode`
        """
        ...

    def Class(self) -> Str:
        """
        Class of node.
        """
        ...

    def __getitem__(
        self,
        name: Str,
        /,
    ) -> Knob:
        """
        x.__getitem__(y) <==> x[y]
        """
        ...

    def __len__(self) -> int:
        """
        x.__len__() <==> len(x)
        """
        ...

    def __repr__(self) -> Str:
        """
        x.__repr__() <==> repr(x)
        """
        ...

    def __str__(self) -> Str:
        """
        x.__str__() <==> Str(x)
        """
        ...

    def addKnob(self, k: Knob) -> None:
        """
        Add knob k to this node or panel.

        @param k: Knob.

        @return: None.
        """
        ...

    def allKnobs(self) -> list[Knob]:
        """
        Get a list of all knobs in this node, including nameless knobs.



        For example:



           >>> b = nuke.nodes.Blur()

           >>> b.allKnobs()



        @return: List of all knobs.



        Note that this doesn't follow the links for Link_Knobs
        """
        ...

    def autoplace(self) -> None:
        """
        Automatically place nodes, so they do not overlap.

        @return: None.
        """
        ...

    def bbox(self) -> Info:
        """
        Bounding box of the node.

        @return: List of x, y, w, h.
        """
        ...

    def canSetInput(self, i: int, node: Node) -> bool:
        """
        Check whether the output of 'node' can be connected to input i.

        @param i: Input number.

        @param node: The node to be connected to input i.

        @return: True if node can be connected, False otherwise.
        """
        ...

    def channels(self) -> list[Str]:
        """
        List channels output by this node.

        @return: String list.
        """
        ...

    def clones(self) -> int:
        """
        Number of clones.
        """
        ...

    def connectInput(self, i, node) -> bool:
        """
        Connect the output of 'node' to the i'th input or the next available unconnected input. The requested input is tried first, but if it is already set then subsequent inputs are tried until an unconnected one is found, as when you drop a connection arrow onto a node in the GUI.

        @param i: Input number to try first.

        @param node: The node to connect to input i.

        @return: True if a connection is made, False otherwise.
        """
        ...

    def deepSample(self, c, x, y, n) -> float:
        """
        Return pixel values from a deep image.

        This requires the image to be calculated, so performance may be very bad if this is placed into an expression in

        a control panel.

        @param c: Channel name.

        @param x: Position to sample (X coordinate).

        @param y: Position to sample (Y coordinate).

        @param n: Sample index (between 0 and the number returned by deepSampleCount() for this pixel, or -1 for the frontmost).

        @return: Floating point value.
        """
        ...

    def deepSampleCount(self, x, y) -> int:
        """
        Return number of samples for a pixel on a deep image.

        This requires the image to be calculated, so performance may be very bad if this is placed into an expression in

        a control panel.

        @param x: Position to sample (X coordinate).

        @param y: Position to sample (Y coordinate).

        @return: Integer value.
        """
        ...

    def dependencies(self, what: int = ...) -> list[Node]:
        """
        List all nodes referred to by this node. 'what' is an optional integer (see below).

        You can use the following constants or'ed together to select what types of dependencies are looked for:

                 nuke.EXPRESSIONS = expressions

                 nuke.INPUTS = visible input pipes

                 nuke.HIDDEN_INPUTS = hidden input pipes.

        The default is to look for all types of connections.



        Example:

        nuke.toNode('Blur1').dependencies( nuke.INPUTS | nuke.EXPRESSIONS )

        @param what: Or'ed constant of nuke.EXPRESSIONS, nuke.INPUTS and nuke.HIDDEN_INPUTS to select the types of dependencies. The default is to look for all types of connections.

        @return: List of nodes.
        """
        ...

    def dependent(self, what: int = ..., forceEvaluate: bool = ...) -> list[Node]:
        """
        List all nodes that read information from this node.  'what' is an optional integer:

                 You can use any combination of the following constants or'ed together to select what types of dependent nodes to look for:

                         nuke.EXPRESSIONS = expressions

                         nuke.INPUTS = visible input pipes

                         nuke.HIDDEN_INPUTS = hidden input pipes.

        The default is to look for all types of connections.



        forceEvaluate is an optional boolean defaulting to True. When this parameter is true, it forces a re-evaluation of the entire tree.

        This can be expensive, but otherwise could give incorrect results if nodes are expression-linked.



        Example:

        nuke.toNode('Blur1').dependent( nuke.INPUTS | nuke.EXPRESSIONS )

        @param what: Or'ed constant of nuke.EXPRESSIONS, nuke.INPUTS and nuke.HIDDEN_INPUTS to select the types of dependent nodes. The default is to look for all types of connections.

        @param forceEvaluate: Specifies whether a full tree evaluation will take place. Defaults to True.

        @return: List of nodes.
        """
        ...

    def error(self) -> bool:
        """
        True if the node or any in its input tree have an error, or False otherwise.



        Error state of the node and its input tree.  Deprecated; use hasError or treeHasError instead.

        Note that this will always return false for viewers, which cannot generate their input trees.  Instead, choose an input of the viewer (e.g. the active one), and call treeHasError() on that.
        """
        ...

    def fileDependencies(self, start, end) -> list[Union[Node, list[Str]]]:
        """
        @param start: first frame

        @param end: last frame

        Returns the list of input file dependencies for this node and all nodes upStream from this node for the given frame range.

        The file dependencies are calculated by searching for Read ops or ops with a File knob.

        All views are considered and current proxy mode is used to decide on whether full format or proxy files are returned.

        Note that Write nodes files are also included but precomps, gizmos and external plugins are not.

        Any time shifting operation such as frameholds, timeblurs, motionblur etc are taken into consideration.

        @return The return list is a list of nodes and files they require.

        Eg.  [Read1, ['file1.dpx, file2.dpx'] ], [Read2, ['file3.dpx', 'file4.dpx'] ] ]
        """
        ...

    def firstFrame(self) -> int:
        """
        First frame in frame range for this node.

        @return: int.
        """
        ...

    def forceValidate(self) -> None:
        """
        Force the node to validate itself, updating its hash.
        """
        ...

    def format(self) -> Format:
        """
        Format of the node.

        @return: Format.
        """
        ...

    def frameRange(self) -> FrameRange:
        """
        Frame range for this node.

        @return: FrameRange.
        """
        ...

    def fullName(self) -> Str:
        """
        Get the name of this node and any groups enclosing it in 'group.group.name' form.

        @return: The fully-qualified name of this node, as a String.
        """
        ...

    def getNumKnobs(self) -> int:
        """
        self.numKnobs() -> The number of knobs.

        @return: The number of knobs.
        """
        ...

    def hasError(self) -> bool:
        """
        True if the node itself has an error, regardless of the state of the ops in its input tree, or False otherwise.



        Error state of the node itself, regardless of the state of the ops in its input tree.

        Note that an error on a node may not appear if there is an error somewhere in its input tree, because it may not be possible to validate the node itself correctly in that case.
        """
        ...

    def height(self) -> int:
        """
        Height of the node.

        @return: int.
        """
        ...

    def help(self) -> Str:
        """
        Help for the node.
        """
        ...

    def hideControlPanel(self) -> None:
        """
        None
        """
        ...

    def input(self, i: int) -> Node:
        """
        @param i: Input number.

        @return: The i'th input.
        """
        ...

    def inputs(self) -> int:
        """
        Number of the highest connected input + 1. If inputs 0, 1, and 3 are connected, this will return 4.
        """
        ...

    def isSelected(self) -> bool:
        """
        Returns the current selection state of the node.  This is the same as checking the 'selected' knob.

        @return: True if selected, or False if not.
        """
        ...

    def knob(self, p: Union[int, Str]) -> Optional[Knob]:
        """
        @param p: A String or an integer.

        @return: The knob named p or the pth knob.



        Note that this follows the links for Link_Knobs
        """
        ...

    def knobs(self) -> dict[Str, Knob]:
        """
        Get a dictionary of (name, knob) pairs for all knobs in this node.



        For example:



           >>> b = nuke.nodes.Blur()

           >>> b.knobs()



        @return: Dictionary of all knobs.



        Note that this doesn't follow the links for Link_Knobs
        """
        ...

    def lastFrame(self) -> int:
        """
        Last frame in frame range for this node.

        @return: int.
        """
        ...

    def linkableKnobs(self, knobType) -> list:
        """
        Returns a list of any knobs that may be linked to from the node as well as some meta information about the knob. This may include whether the knob is enabled and whether it should be used for absolute or relative values. Not all of these variables may make sense for all knobs..

        @param knobType A KnobType describing the type of knobs you want.@return: A list of LinkableKnobInfo that may be empty .
        """
        ...

    def maxInputs(self) -> int:
        """
        Maximum number of inputs this node can have.
        """
        ...

    def maxOutputs(self) -> int:
        """
        Maximum number of outputs this node can have.
        """
        ...

    def maximumInputs(self) -> int:
        """
        Maximum number of inputs this node can have.
        """
        ...

    def maximumOutputs(self) -> int:
        """
        Maximum number of outputs this node can have.
        """
        ...

    @overload
    def metadata(
        self, *, time: int = ..., view: Str = ...
    ) -> dict[Str, Union[Str, float]]: ...
    @overload
    def metadata(
        self, key: Str, time: int = ..., view: Str = ...
    ) -> Union[Str, float, None]:
        """
        Return the metadata item for key on this node at current output context, or at optional time and view.

        If key is not specified a dictionary containing all key/value pairs is returned.

        None is returned if key does not exist on this node.

        @param key: Optional name of the metadata key to retrieve.

        @param time: Optional time to evaluate at (default is taken from node's current output context).

        @param view: Optional view to evaluate at (default is taken from node's current output context).

        @return: The requested metadata value, a dictionary containing all keys if a key name is not provided, or None if the specified key is not matched.
        """
        ...

    def minInputs(self) -> int:
        """
        Minimum number of inputs this node can have.
        """
        ...

    def minimumInputs(self) -> int:
        """
        Minimum number of inputs this node can have.
        """
        ...

    def name(self) -> Str:
        """
        Name of node.
        """
        ...

    def numKnobs(self) -> int:
        """
        The number of knobs.
        """
        ...

    def opHashes(self) -> list[int]:
        """
        Returns a list of hash values, one for each op in this node.
        """
        ...

    def optionalInput(self) -> int:
        """
        Number of first optional input.
        """
        ...

    def performanceInfo(self, category) -> ...:
        """
        @category: performance category ( optional ).A performance category, must be either nuke.PROFILE_STORE, nuke.PROFILE_VALIDATE, nuke.PROFILE_REQUEST or nuke.PROFILE_ENGINE The default is nuke.PROFILE_ENGINE which gives the performance info of the render engine.

        @return: A dictionary containing the cumulative performance info for this category, where:

        callCount = the number of calls made

        timeTakenCPU =  the CPU time spent in microseconds

        timeTakenWall = the actual time ( wall time ) spent in microseconds
        """
        ...

    def pixelAspect(self) -> int:
        """
        Pixel Aspect ratio of the node.

        @return: float.
        """
        ...

    def proxy(self) -> bool:
        """
        True if proxy is enabled, False otherwise.
        """
        ...

    def readKnobs(self, s) -> None:
        """
        Read the knobs from a String (TCL syntax).

        @param s: A String.

        @return: None.
        """
        ...

    def redraw(self) -> None:
        """
        Force a redraw of the node.

        @return: None.
        """
        ...

    def removeKnob(self, k: Knob) -> None:
        """
        Remove knob k from this node or panel. Throws a ValueError exception if k is not found on the node.

        @param k: Knob.

        @return: None.
        """
        ...

    def resetKnobsToDefault(self) -> None:
        """
        Reset all the knobs to their default values.
        """
        ...

    def running(self) -> ...:
        """
        Class method.

        @return: Node rendering when paralleled threads are running or None.
        """
        ...

    def sample(
        self,
        c: Str,
        x: float,
        y: float,
        dx: float = ...,
        dy: float = ...,
        frame: float = ...,
    ) -> float:
        """
        Return pixel values from an image.

        This requires the image to be calculated, so performance may be very bad if this is placed into an expression in

        a control panel. Produces a cubic filtered result. Any sizes less than 1, including 0, produce the same filtered result,

        this is correct based on sampling theory. Note that integers are at the corners of pixels, to center on a pixel add .5 to both coordinates.

        If the optional dx,dy are not given then the exact value of the square pixel that x,y lands in is returned. This is also called 'impulse filtering'.

        @param c: Channel name.

        @param x: Centre of the area to sample (X coordinate).

        @param y: Centre of the area to sample (Y coordinate).

        @param dx: Optional size of the area to sample (X coordinate).

        @param dy: Optional size of the area to sample (Y coordinate).

        @param frame: Optional frame to sample the node at.

        @return: Floating point value.
        """
        ...

    def screenHeight(self) -> int:
        """
        Height of the node when displayed on screen in the DAG, at 1:1 zoom, in pixels.

        @return: int.
        """
        ...

    def screenWidth(self) -> int:
        """
        Width of the node when displayed on screen in the DAG, at 1:1 zoom, in pixels.

        @return: int.
        """
        ...

    def selectOnly(self) -> None:
        """
        Set this node to be the only selection, as if it had been clicked in the DAG.

        @return: None.
        """
        ...

    def setInput(self, i: int, node: Optional[Node]) -> bool:
        """
        Connect input i to node if canSetInput() returns true.

        @param i: Input number.

        @param node: The node to connect to input i.

        @return: True if canSetInput() returns true, or if the input is already correct.
        """
        ...

    def setName(
        self,
        name: Str,
        uncollide: bool = True,
        updateExpressions: bool = False,
    ) -> None:
        """
        Set name of the node and resolve name collisions if optional named argument 'uncollide' is True.

        @param name: A String.

        @param uncollide: Optional boolean to resolve name collisions. Defaults to True.

        @param updateExpressions: Optional boolean to update expressions in other nodes to point at the new name. Defaults to False.

        @return: None
        """
        ...

    def setSelected(self, selected: bool) -> None:
        """
        Set the selection state of the node.  This is the same as changing the 'selected' knob.

        @param selected: New selection state - True or False.

        @return: None.
        """
        ...

    def setTab(self, tabIndex) -> None:
        """
        @param tabIndex: The tab to show (first is 0).

        @return: None
        """
        ...

    def setXYpos(self, x: int, y: int) -> None:
        """
        Set the (x, y) position of node in node graph.

        @param x: The x position of node in node graph.

        @param y: The y position of node in node graph.

        @return: None.
        """
        ...

    def setXpos(self, x: int) -> None:
        """
        Set the x position of node in node graph.

        @param x: The x position of node in node graph.

        @return: None.
        """
        ...

    def setYpos(self, y: int) -> None:
        """
        Set the y position of node in node graph.

        @param y: The y position of node in node graph.

        @return: None.
        """
        ...

    def showControlPanel(self, forceFloat: bool = False) -> None:
        """
        @param forceFloat: Optional python object. If it evaluates to True the control panel will always open as a floating panel. Default is False.

        @return: None
        """
        ...

    def showInfo(self, s) -> None:
        """
        Creates a dialog box showing the result of script s.

        @param s: A String.

        @return: None.
        """
        ...

    def shown(self) -> bool:
        """
        true if the properties panel is open. This can be used to skip updates that are not visible to the user.
        """
        ...

    def treeHasError(self) -> bool:
        """
        True if the node or any in its input tree have an error, or False otherwise.



        Error state of the node and its input tree.

        Note that this will always return false for viewers, which cannot generate their input trees.  Instead, choose an input of the viewer (e.g. the active one), and call treeHasError() on that.
        """
        ...

    def upStreamFrameRange(self, i) -> FrameRange:
        """
        Frame range for the i'th input of this node.

        @param i: Input number.

        @return: FrameRange. Returns None when querying an invalid input.
        """
        ...

    def width(self) -> int:
        """
        Width of the node.

        @return: int.
        """
        ...

    def writeKnobs(self, i: int) -> Str:
        """
        Return a tcl list. If TO_SCRIPT | TO_VALUE is not on, this is a simple list

        of knob names. If it is on, it is an alternating list of knob names

        and the output of to_script().



        Flags can be any of these or'ed together:

        - nuke.TO_SCRIPT produces to_script(0) values

        - nuke.TO_VALUE produces to_script(context) values

        - nuke.WRITE_NON_DEFAULT_ONLY skips knobs with not_default() false

        - nuke.WRITE_USER_KNOB_DEFS writes addUserKnob commands for user knobs

        - nuke.WRITE_ALL writes normally invisible knobs like name, xpos, ypos



        @param i: The set of flags or'ed together. Default is TO_SCRIPT | TO_VALUE.

        @return: String in .nk form.
        """
        ...

    def xpos(self) -> int:
        """
        X position of node in node graph.
        """
        ...

    def ypos(self) -> int:
        """
        Y position of node in node graph.
        """
        ...
    ...

class NodeConStructor:
    """
    NodeConStructor
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __call__(
        self,
        *,
        inputs: Iterable[Optional[Node]] = ...,
        autolabel: Str = ...,
        gl_color: int = ...,
        help: Str = ...,
        hide_input: bool = ...,
        icon: Str = ...,
        indicators=...,
        knobChanged: Str = ...,
        label: Str = ...,
        name: Str = ...,
        note_font_color: int = ...,
        note_font_size: int = ...,
        note_font: Str = ...,
        onCreate: Str = ...,
        onDeStroy: Str = ...,
        panel=...,
        selected: bool = ...,
        tile_color: int = ...,
        updateUI: Str = ...,
        xpos: int = ...,
        ypos: int = ...,
        **kwargs,
    ) -> Node:
        """
        ConStruct a node and assign knob values to it.
        """
        ...
    ...

class Nodes:
    """
    Nodes
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __getattribute__(self, name: str) -> NodeConStructor: ...
    ...

class Obsolete_Knob(Knob):
    """
    For internal use only.
    """

    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class OneView_Knob(Enumeration_Knob):
    """
    OneView_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """

    ...

class OutputContext:
    """
    Describes a context in which expressions can be evaluated.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def frame(self) -> float:
        """
        Return frame value.
        """
        ...

    def setFrame(self, f) -> bool:
        """
        Set frame value. The f argument is a float.
        """
        ...

    def setView(self, n) -> bool:
        """
        Set view number. The n argument is an integer in the range of 0 to number of views.
        """
        ...

    def view(self) -> int:
        """
        Return view number.
        """
        ...

    def viewFromName(self, name) -> int:
        """
        Returns the index of the view with name matching the argument name or -1 if there is no match.
        """
        ...

    def viewcount(self) -> int:
        """
        Return number of views.
        """
        ...

    def viewname(self, n) -> Str:
        """
        Return name of the view. The n argument is an integer in the range of 0 to number of views.
        """
        ...

    def viewshort(self, n) -> Str:
        """
        Return short name of the view. The n argument is an integer in the range of 0 to number of views.
        """
        ...
    ...

class Panel:
    """
    Panel
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        arg2: int = ...,
        /,
    ): ...
    def addBooleanCheckBox(self, name: Str, value) -> bool:
        """
        Add a boolean check box knob to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addButton(self, name: Str, value) -> bool:
        """
        Add a button to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addClipnameSearch(self, name: Str, value) -> bool:
        """
        Add a clipname search knob to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addEnumerationPulldown(self, name: Str, value) -> bool:
        """
        Add a pulldown menu to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addExpressionInput(self, name: Str, value: Str) -> bool:
        """
        Add an expression evaluator to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addFilenameSearch(self, name: Str, value: Str) -> bool:
        """
        Add a filename search knob to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addMultilineTextInput(self, name: Str, value: Str) -> bool:
        """
        Add a multi-line text knob to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addNotepad(self, name: Str, value: Str) -> bool:
        """
        Add a text edit widget to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addPasswordInput(self, name: Str, value: Str) -> bool:
        """
        Add a password input knob to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addRGBColorChip(self, name: Str, value) -> bool:
        """
        Add a color chooser to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addScriptCommand(self, name: Str, value) -> bool:
        """
        Add a script command evaluator to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addSingleLineInput(self, name: Str, value: Str) -> bool:
        """
        Add a single-line input knob to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def addTextFontPulldown(self, name: Str, value: Str) -> bool:
        """
        Add a font chooser to the panel.

        @param name: The name for the new knob.

        @param value: The initial value for the new knob.

        @return: True if successful.
        """
        ...

    def clear(self) -> None:
        """
        Clear all panel attributes.
        """
        ...

    def execute(self, name: Str) -> Optional[Str]:
        """
        Execute the script command associated with a particular label and return the result as a String.

        @param name: The name of the script field to execute.

        @return: The result of the script as a String, or None if it fails.
        """
        ...

    def setTitle(self, val: Str) -> bool:
        """
        Set the current title for the panel.

        @param val: The title as a String.

        @return: True if successful.
        """
        ...

    def setWidth(self, val: int) -> bool:
        """
        Set the width of the panel.

        @param val: The width as an int.

        @return: True if successful.
        """
        ...

    def show(self) -> int:
        """
        Display the panel.

        @return: An int value indicating how the dialog was closed (normally, or cancelled).
        """
        ...

    def title(self) -> Str:
        """
        Get the current title for the panel.

        @return: The title as a String.
        """
        ...

    def value(self, name: Str) -> Optional[Str]:
        """
        Get the value of a particular control in the panel.

        @param name: The name of the knob to get a value from.

        @return: The value for the field if any, otherwise None.
        """
        ...

    def width(self) -> int:
        """
        Get the width of the panel.

        @return: The width as an int.
        """
        ...
    ...

class PanelNode:
    """
    PanelNode
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __str__(self, *args, **kwargs):
        """
        x.__str__() <==> Str(x)
        """
        ...

    def addKnob(self, k) -> None:
        """
        Add knob k to this node or panel.
        @param k: Knob.
        @return: None.
        """
        ...

    def createWidget(self, *args, **kwargs):
        """
        Create the widget for the panel
        """
        ...

    def knobs(self) -> dict:
        """
        Get a dictionary of (name, knob) pairs for all knobs in this node.

        For example:

           >>> b = nuke.nodes.Blur()
           >>> b.knobs()

        @return: Dictionary of all knobs.

        Note that this doesn't follow the links for Link_Knobs
        """
        ...

    def readKnobs(self, s) -> None:
        """
        Read the knobs from a String (TCL syntax).
        @param s: A String.
        @return: None.
        """
        ...

    def removeKnob(self, k) -> None:
        """
        Remove knob k from this node or panel. Throws a ValueError exception if k is not found on the node.
        @param k: Knob.
        @return: None.
        """
        ...

    def writeKnobs(self, i) -> Str:
        """
        Return a tcl list. If TO_SCRIPT | TO_VALUE is not on, this is a simple list
        of knob names. If it is on, it is an alternating list of knob names
        and the output of to_script().

        Flags can be any of these or'ed together:
        - nuke.TO_SCRIPT produces to_script(0) values
        - nuke.TO_VALUE produces to_script(context) values
        - nuke.WRITE_NON_DEFAULT_ONLY skips knobs with not_default() false
        - nuke.WRITE_USER_KNOB_DEFS writes addUserKnob commands for user knobs
        - nuke.WRITE_ALL writes normally invisible knobs like name, xpos, ypos

        @param i: The set of flags or'ed together. Default is TO_SCRIPT | TO_VALUE.
        @return: String in .nk form.
        """
        ...
    ...

class Password_Knob(Knob):
    """
    A knob which holds a password String value. Appears as a password entry field in a Node panel.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def getText(self) -> Str:
        """
        Return text associated with knob.
        """
        ...

    def setValue(self, val, view="default") -> None:
        """
        Set value of knob.

        @param val: The new value.

        @param view: Optional parameter specifying which view to set the value for. If omitted, the value will be set for the default view.

        @return: None
        """
        ...

    def value(self) -> Str:
        """
        Get the value of this knob as a String.

        @return: String value.
        """
        ...
    ...

class Precomp(Group):
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...

    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...

    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...

    def __str__(self, *args, **kwargs):
        """
        x.__str__() <==> Str(x)
        """
        ...

    def reload(self) -> None:
        """
        Precomp Node reload()
        @return: None
        """
        ...
    ...

class ProgressTask:
    """
    ProgressTask
    """

    __new__: ...
    def __init__(self, name: Str, /) -> None: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def isCancelled(self) -> bool:
        """
        True if the user has requested the task to be cancelled
        """
        ...

    def setMessage(self, s: Str) -> None:
        """
        set the message for the progress task
        """
        ...

    def setProgress(self, i: int) -> None:
        """
        i is an integer representing the current progress
        """
        ...
    ...

class Pulldown_Knob(Enumeration_Knob):
    """
    Pulldown_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def commands(self, n) -> Str:
        """
        Return command n. The argument n is an integer and in the range of 0 and numValues.
        """
        ...

    def itemName(self, n) -> Str:
        """
        Return name of item n. The argument n is an integer and in the range of 0 and numValues.
        """
        ...

    def numValues(self) -> int:
        """
        Return number of values.
        """
        ...

    def setValues(self, items) -> None:
        """
        (Re)initialise knob to the list of items.

        @param items: Dictionary of name/value pairs.

        @param sort: Optional parameter as to whether to sort the names.

        @return: None.

        Example:

        w = nuke.nodes.NoOp()

        k = nuke.Pulldown_Knob('knob_name', 'knob_label')

        k.setValues({'label/command' : 'eval("3*2")'})

        w.addKnob(k)

        k = w['knob_name']
        """
        ...
    ...

class PyCustom_Knob(Script_Knob):
    """
    PyCustom_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        content: Str = ...,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def getObject(self, *args, **kwargs):
        """
        Returns the custom knob object as created in the by the 'command' argument to the PyCustom_Knob conStructor.
        """
        ...
    ...

class PyScript_Knob(Script_Knob):
    """
    PyScript_Knob(name, label=None, command=None)

    A button that executes a Python script.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ): ...
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        value: Str = ...,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class PythonCustomKnob(Script_Knob):
    """
    PythonCustomKnob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def getObject(self, *args, **kwargs):
        """
        Returns the custom knob object as created in the by the 'command' argument to the PyCustom_Knob conStructor.
        """
        ...
    ...

class PythonKnob(String_Knob):
    """
    A String-valued knob which evaluates its value as a Python expression.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Radio_Knob(Enumeration_Knob):
    """
    Stores a single value between 0 and some maximum, and manages a

    set of Radio Buttons visible to the user. This is essentially an

    Enumeration_Knob with a different widget.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def enumName(self, n) -> Str:
        """
        Return name of enumeration n. The argument n is an integer and in the range of 0 and numValues. Deprecated.
        """
        ...

    def numValues(self) -> int:
        """
        Return number of values. Deprecated.
        """
        ...

    def setValue(self, item) -> None:
        """
        Set the current value. item will first be converted into a String and matched against the enum values.

        If this fails, it will attempt to be used as an index into the enum.

        @param item: String or Integer.

        @return: None.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.setValue('exr')
        """
        ...

    def setValues(self, items) -> None:
        """
        (Re)initialise knob to the supplied list of items.

        @param items: The new list of values.

        @return: None.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.setValues(['exr'])
        """
        ...

    def value(self) -> Str:
        """
        Current value.

        @return: String.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.value()
        """
        ...

    def values(self) -> list[Str]:
        """
        Return list of items.

        @return: List of Strings.

        Example:

        w = nuke.nodes.Write()

        k = w['file_type']

        k.values()
        """
        ...
    ...

class Range_Knob(Array_Knob):
    """
    A knob which the minimum and maximum for a range of values.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Root(Group):
    def __new__(cls):
        """
        T.__new__(S, ...) -> a new object with type S, a subtype of T
        """
        ...

    def __len__(self) -> int:
        """
        x.__len__() <==> len(x)
        """
        ...

    def __repr__(self) -> Str:
        """
        x.__repr__() <==> repr(x)
        """
        ...

    def __str__(self) -> Str:
        """
        x.__str__() <==> Str(x)
        """
        ...

    def addView(self, name, color) -> None:
        """
        Add view.

        @param name: String - name of view.

        @param color: Optional. String in the format #RGB, #RRGGBB, #RRRGGGBBB, #RRRRGGGGBBBB or a name from the list of colors defined in the list of SVG color keyword names.

        @return: None.
        """
        ...

    def channels(self) -> list[Str]:
        """
        nuke.Root.channels() -> Channel list.

        Class method.

        @return: Channel list.
        """
        ...

    def deleteView(self, s) -> None:
        """
        Delete view.

        @param s: Name of view.

        @return: None.
        """
        ...

    def firstFrame(self) -> int:
        """
        First frame.

        @return: Integer.
        """
        ...

    def fps(self) -> int:
        """
        Return the FPS rounded to an int. This is deprecated. Please use real_fps().
        """
        ...

    def getOCIOColorspaceFamily(self, *args, **kwargs):
        """
        nuke.root.getOCIOColorspaceFamily(colorspace) -> Family of colorspace

        Gets the name of the family to which the specified colorspace belongs,

        for the root node's current OCIO config.

        @param colorspace: Colorspace name.

        @return: Family name, may be an empty String.
        """
        ...

    def getOCIOColorspaceFromViewTransform(self, *args, **kwargs):
        """
        nuke.root.getOCIOColorspaceFromViewTransform(display, view) -> Colorspace name

        Gets the name of the colorspace to which the specified display and view names are mapped

        for the root node's current OCIO config.

        @param display: Display name.

        @param view: View name.

        @return: The corresponding colorspace name.
        """
        ...

    def lastFrame(self) -> int:
        """
        Last frame.

        @return: Integer.
        """
        ...

    def layers(self, *args, **kwargs):
        """
        nuke.Root.layers() -> Layer list.

        Class method.

        @return: Layer list.
        """
        ...

    def mergeFrameRange(self, a, b) -> None:
        """
        Merge frame range.

        @param a: Low-end of interval range.

        @param b: High-end of interval range.

        @return: None.
        """
        ...

    def modified(self) -> bool:
        """
        Get or set the 'modified' flag in a script

        @return: True if modified, False otherwise.
        """
        ...

    def proxy(self) -> bool:
        """
        True if proxy is set, False otherwise.
        """
        ...

    def realFps(self) -> float:
        """
        The global frames per second setting.
        """
        ...

    def setFrame(self, n: int) -> None:
        """
        Set frame.

        @param n: Frame number.

        @return: None.
        """
        ...

    def setModified(self, b: bool) -> None:
        """
        Set the 'modified' flag in a script.

        Setting the value will turn the indicator in the title bar on/off and will start or stop the autosave timeout.

        @param b: Boolean convertible object.

        @return: None.
        """
        ...

    def setProxy(self, b) -> None:
        """
        Set proxy.

        @param b: Boolean convertible object.

        @return: None.
        """
        ...

    def setView(self, s) -> None:
        """
        Set view.

        @param s: Name of view.

        @return: None.
        """
        ...
    ...

class RunInMainThread:
    """
    RunInMainThread
    """

    def request(self, *args, **kwargs):
        """ """
        ...
    ...

class Scale_Knob(Array_Knob):
    """
    Scale_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def names(self, n) -> Str:
        """
        Return name for dimension n. The argument n is an integer.
        """
        ...

    def value(self, n, oc) -> float:
        """
        Return value for dimension n. The optional argument oc is an OutputContext.
        """
        ...

    def x(self, oc) -> float:
        """
        Return value for x. The optional oc argument is an OutputContext
        """
        ...

    def y(self, oc) -> float:
        """
        Return value for y. The optional oc argument is an OutputContext
        """
        ...

    def z(self, oc) -> float:
        """
        Return value for z. The optional oc argument is an OutputContext
        """
        ...
    ...

class SceneView_Knob(Unsigned_Knob):
    """
    Displays a list of items as a hierarchy.

    The hierarchy is specified using back or forward slashes within the item names

    to specify their level in the tree. Handles multiple selection of items within the tree.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def addItems(self) -> None:
        """
        Adds a list of String items to the knob. New items are automatically set as imported and selected.
        """
        ...

    def getAllItems(self) -> list:
        """
        Returns a list of Strings containing all items that the knob can import.
        """
        ...

    def getHighlightedItem(self) -> Str:
        """
        Returns a String containing the item which is currently highlighted.
        """
        ...

    def getImportedItems(self) -> list:
        """
        Returns a list of Strings containing all items imported into the knob.
        """
        ...

    def getSelectedItems(self) -> list:
        """
        Returns a list of Strings containing all currently selected items in the knob.
        """
        ...

    def removeItems(self) -> None:
        """
        Removes a list of String items from the knob.
        """
        ...

    def setAllItems(self, items, autoSelect) -> None:
        """
        Sets a list of Strings containing all items that the knob can import.

        After calling this function, only items from this list can be imported into the nodes.

        @param items: List of imported items.

        @param autoSelect: If True, all items are automatically set as imported and selected.

        @return: None.
        """
        ...

    def setImportedItems(self, items) -> None:
        """
        Sets a list of Strings containing all items imported into the knob. This will overwrite the current imported items list.@param items: List of imported items.

        @return: None.
        """
        ...

    def setSelectedItems(self) -> None:
        """
        Takes a list of Strings of items contained in the knob and sets them as selected.
        """
        ...
    ...

class Script_Knob(String_Knob):
    """
    A button which executes a TCL script.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def command(self) -> Str:
        """
        Get the current command.

        @return: The current command as a String, or None if there is no current command.
        """
        ...

    def execute(self) -> None:
        """
        Execute the command.

        @return: None.
        """
        ...

    def setCommand(self, cmd) -> None:
        """
        Set the new command for this knob.

        @param cmd: String containing a TCL command.

        @return: None.
        """
        ...

    def setValue(self, cmd) -> None:
        """
        Set the new command for this knob.

        @param cmd: String containing a TCL command.

        @return: None.
        """
        ...

    def value(self) -> Str:
        """
        Get the current command.

        @return: The current command as a String, or None if there is no current command.
        """
        ...
    ...

class String_Knob(Knob):
    """
    A knob which holds a String value. Appears as a text entry field in a Node panel.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @overload
    def __init__(
        self,
        name: Str,
        /,
    ): ...
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ): ...
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        value: Str = ...,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def getText(self, oc: OutputContext = ...) -> Str:
        """
        Get the non-evaluated value of this knob - also see `value()`

        @param oc: Optional parameter specifying the output context.

        Return text associated with knob.
        """
        ...

    def getValue(self, oc: OutputContext = ...) -> Str:
        """
        self.value(oc) -> Str



        Get the evaluated value of this knob as a String - also see `getText()`.

        @param oc: Optional parameter specifying the output context.

        @return: String value.
        """
        ...

    def setText(self, value: Str, *, view: Str = ...) -> None:
        """
        self.setValue(val, view='default') -> None



        Set value of knob.

        @param val: The new value.

        @param view: Optional parameter specifying which view to set the value for. If omitted, the value will be set for the default view.

        @return: None
        """
        ...

    def setValue(self, val: Str, view: Str = ...) -> None:
        """
        Set value of knob.

        @param val: The new value.

        @param view: Optional parameter specifying which view to set the value for. If omitted, the value will be set for the default view.

        @return: None
        """
        ...

    def splitView(self, view) -> None:
        """
        Split the view away from the current knob value.

        @param view: Optional view. Default is current view.

        @return: None.
        """
        ...

    def unsplitView(self, view) -> None:
        """
        Unsplit the view so that it shares a value with other views.

        @param view: Optional view. Default is current view.

        @return: None.
        """
        ...

    def value(self, oc: OutputContext = ...) -> Str:
        """
        Get the evaluated value of this knob as a String - also see `getText()`.

        @param oc: Optional parameter specifying the output context.

        @return: String value.
        """
        ...
    ...

class Tab_Knob(Knob):
    """
    Groups subsequent knobs onto a tab.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @overload
    def __init__(
        self,
        name: Str,
        /,
    ): ...
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ): ...
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        flags: int = ...,
        /,
    ): ...
    ...

class Text_Knob(Knob):
    """
    A knob which holds a String value.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ): ...
    @overload
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        content: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def setValue(self, val: Str, view: Str = ...) -> None: ...
    ...

class ToolBar:
    """
    ToolBar
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def addAction(self, action) -> bool:
        """
        Adds the QAction to the menu.
        """
        ...

    def addCommand(
        self, name, command, shortcut, icon, tooltip, index, readonly
    ) -> Union[Menu, ToolBar]:
        """
        Add a new command to this menu/toolbar. Note that when invoked, the command is automatically enclosed in an undo group, so that undo/redo functionality works. Optional arguments can be specified by name.

        Note that if the command argument is not specified, then the command will be auto-created as a "nuke.createNode()" using the name argument as the node to create.



        Example:

        menubar = nuke.menu('Nuke')

        fileMenu = menubar.findItem('File')

        fileMenu.addCommand('NewCommand', 'print 10', shortcut='t')



        @param name: The name for the menu/toolbar item. The name may contain submenu names delimited by '/' or '', and submenus are created as needed.

        @param command: Optional. The command to add to the menu/toolbar. This can be a String to evaluate or a Python Callable (function, method, etc) to run.

        @param shortcut: Optional. The keyboard shortcut for the command, such as 'R', 'F5' or 'Ctrl-H'. Note that this overrides pre-existing other uses for the shortcut.

        @param icon: Optional. An icon for the command. This should be a path to an icon in the nuke.pluginPath() directory. If the icon is not specified, Nuke will automatically try to find an icon with the name argument and .png appended to it.

        @param tooltip: Optional. The tooltip text, displayed on mouseover for toolbar buttons.

        @param index: Optional. The position to insert the new item in, in the menu/toolbar. This defaults to last in the menu/toolbar.

        @param readonly: Optional. True/False for whether the item should be available when the menu is invoked in a read-only context.

        @param shortcutContext: Optional. Sets the shortcut context (0==Window, 1=Application, 2=DAG).

        @return: The menu/toolbar item that was added to hold the command.
        """
        ...

    def addMenu(self, **kwargs) -> Menu:
        """
        Add a new submenu.

        @param **kwargs The following keyword arguments are accepted:

                        name      The name for the menu/toolbar item

                        icon      An icon for the menu. Loaded from the nuke search path.

                        tooltip   The tooltip text.

                        index     The position to insert the menu in. Use -1 to add to the end of the menu.

        @return: The submenu that was added.
        """
        ...

    def addSeparator(self, **kwargs) -> ...:
        """
        Add a separator to this menu/toolbar.

        @param **kwargs The following keyword arguments are accepted:

        index     The position to insert the new separator in, in the menu/toolbar.

        @return: The separator that was created.
        """
        ...

    def clearMenu(self, *args, **kwargs):
        """
        self.clearMenu()

        Clears a menu.

        @param **kwargs The following keyword arguments are accepted:

                        name      The name for the menu/toolbar item

        @return: true if cleared, false if menu not found
        """
        ...

    def findItem(self, name) -> Optional[Menu]:
        """
        Finds a submenu or command with a particular name.

        @param name: The name to search for.

        @return: The submenu or command we found, or None if we could not find anything.
        """
        ...

    def items(self) -> None:
        """
        Returns a list of sub menu items.
        """
        ...

    def menu(self, name) -> Optional[Menu]:
        """
        Finds a submenu or command with a particular name.

        @param name: The name to search for.

        @return: The submenu or command we found, or None if we could not find anything.
        """
        ...

    def name(self) -> Str:
        """
        Returns the name of the menu item.
        """
        ...

    def removeItem(self, name) -> None:
        """
        Removes a submenu or command with a particular name. If the containing menu becomes empty, it will be removed too.

        @param name: The name to remove for.

        @return: true if removed, false if menu not found
        """
        ...

    def updateMenuItems(self) -> None:
        """
        Updates menu items' states. Call on about to show menu.
        """
        ...
    ...

class Transform2d_Knob(Knob):
    """
    Transform2d_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def value(self, oc) -> ...:
        """
        Return transformation matrix. The argument oc is an OutputContext. Both arguments are optional.
        """
        ...
    ...

class UV_Knob(Array_Knob):
    """
    A knob which describes a texture coordinate.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def names(self, n) -> Str:
        """
        Return name for dimension n. The argument n is an integer.
        """
        ...
    ...

class Undo:
    """
    Undo
    """

    __new__: ...
    __enter__: ...
    __exit__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    @staticmethod
    def begin(
        name: Str,
        /,
    ) -> None:
        """
        Begin a new user-visible group of undo actions.
        """
        ...

    @staticmethod
    def cancel() -> None:
        """
        Undoes any actions recorded in the current set and throws it away.
        """
        ...

    @staticmethod
    def disable() -> None:
        """
        Prevent recording undo until matching enable()
        """
        ...

    @staticmethod
    def disabled() -> None:
        """
        True if disable() has been called
        """
        ...

    @staticmethod
    def enable() -> None:
        """
        Undoes the previous disable()
        """
        ...

    @staticmethod
    def end() -> None:
        """
        Complete current undo set and add it to the undo list.
        """
        ...

    @staticmethod
    def name(
        v: Str,
        /,
    ) -> None:
        """
        Name current undo set.
        """
        ...

    @staticmethod
    def new() -> None:
        """
        Same as end();begin().
        """
        ...

    @staticmethod
    def redo() -> None:
        """
        Redoes 0'th redo.
        """
        ...

    @staticmethod
    def redoDescribe(
        n: int,
        /,
    ) -> Str:
        """
        Return short description of redo n.
        """
        ...

    @staticmethod
    def redoDescribeFully(
        n: int,
        /,
    ) -> Str:
        """
        Return long description of redo n.
        """
        ...

    @staticmethod
    def redoSize() -> int:
        """
        Number of redo's that can be done.
        """
        ...

    @staticmethod
    def redoTruncate(
        n: int,
        /,
    ) -> None:
        """
        DeStroy any redo's greater or equal to n.
        """
        ...

    @staticmethod
    def undo() -> None:
        """
        Undoes 0'th undo.
        """
        ...

    @staticmethod
    def undoDescribe(
        n: int,
        /,
    ) -> None:
        """
        Return short description of undo n.
        """
        ...

    @staticmethod
    def undoDescribeFully(
        n: int,
        /,
    ) -> None:
        """
        Return long description of undo n.
        """
        ...

    @staticmethod
    def undoSize() -> int:
        """
        Number of undo that can be done.
        """
        ...

    @staticmethod
    def undoTruncate() -> None:
        """
        DeStroy any undo greater or equal to n.
        """
        ...
    ...

class Unsigned_Knob(Array_Knob):
    """
    A knob which holds one or more unsigned integer values.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def setValue(self, val: int) -> bool:
        """
        Set the unsigned integer value of this knob.

        @param val: The new value for the knob. Must be an integer >= 0.

        @return: True if succeeded, False otherwise.
        """
        ...

    def value(self) -> int:
        """
        Get the value of this knob as an integer.

        @return: int
        """
        ...
    ...

class View:
    """
    A named view.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def __str__(self, *args, **kwargs):
        """
        x.__str__() <==> Str(x)
        """
        ...

    def String(self) -> Str:
        """
        @return: Name of view.
        """
        ...

    def value(self) -> ...:
        """
        @return: Value of view.
        """
        ...
    ...

class ViewView_Knob(Knob):
    """
    ViewView_Knob
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...
    ...

class Viewer(Node):
    def __getitem__(self, *args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
        ...

    def __len__(self, *args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
        ...

    def __repr__(self, *args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
        ...

    def __str__(self, *args, **kwargs):
        """
        x.__str__() <==> Str(x)
        """
        ...

    def capture(self, file) -> None:
        """
        Capture the viewer image to a file.  Only jpg files are supported at present.  The image is captured immediately even if the viewer is mid-render.To capture a fully rendered image at a frame or frame range use nuke.render passing in the viewer node you want to capture.When using nuke.render the filename is specified by the 'file' knob on the viewer node.
        """
        ...

    def frameCached(self, f) -> bool:
        """
        Determine whether frame /f/ is known to be in the memory cache.
        """
        ...

    def isPlayingOrRecording(self) -> bool:
        """
        @return: Is a recording being made or played?
        """
        ...

    def playbackRange(self) -> FrameRange:
        """
        Return the frame range that's currently set to be played back in the viewer.@return: FrameRange.
        """
        ...

    def recordMouse(self) -> bool:
        """
        Start viewer window mouse recording.@return: Recording started?
        """
        ...

    def recordMouseStop(self, *args, **kwargs):
        """
        recordMouseStop()

        Stop viewer window mouse recording.
        """
        ...

    def replayMouseAsync(self, xmlRecordingFilename) -> bool:
        """
        Start timer based (asynchronous) playback of a viewer window mouse recording.@param: Name of recording xml file to play@return: Replay started?
        """
        ...

    def replayMouseSync(self, xmlRecordingFilename) -> bool:
        """
        Start direct (synchronous) playback of a viewer window mouse recording.@param: Name of recording xml file to play@return: Replay succeeded?
        """
        ...

    def roi(self) -> dict:
        """
        Region of interest set in the viewer in pixel space coordinates.
        Returns None if the Viewer has no window yet.
        @return: Dict with keys x, y, r and t or None.
        """
        ...

    def roiEnabled(self) -> bool:
        """
        Whether the viewing of just a region of interest is enabled.
        Returns None if the Viewer has no window yet.
        @return: Boolean or None.
        """
        ...

    def sendMouseEvent(self) -> bool:
        """
        Temporary:
        Post a mouse event to the viewer window.
        """
        ...

    def setRoi(self, box) -> None:
        """
        Set the region of interest in pixel space.
        @param box: A dictionary with the x, y, r and t keys.@return: None.
        """
        ...

    def toggleMouseTrails(self) -> bool:
        """
        Toggle mouse trails in the viewer window on/off.@return: Trails now showing?
        """
        ...

    def toggleWaitOnReplayEvents(self, *args, **kwargs):
        """
        toggleWaitOnEvents() -> Bool

        Toggle whether asynchronous playback waits on each event.
        Otherwise events will be handled by the next nuke update.@return: Now waiting?
        """
        ...
    ...

class ViewerProcess:
    """
    ViewerProcess
    """

    def node(self, *args, **kwargs):
        """
        nuke.ViewerProcess.node(name, viewer) -> Node.
        Returns a ViewerProcess node. Default is to return the current selected one. This is a class method.
        @param name: Optional ViewerProcess name.
        @param viewer: Optional viewer name.
        @return: Node.
        """
        ...

    def register(self, *args, **kwargs):
        """
        nuke.ViewerProcess.register(name, call, args, kwargs) -> None.
        Register a ViewerProcess. This is a class method.
        @param name: Menu name.
        @param call: Python callable. Must return a Node.
        @param args: Arguments to call.
        @param kwargs: Optional named arguments.
        @return: None.
        """
        ...

    def registeredNames(self, *args, **kwargs):
        """
        nuke.ViewerProcess.registeredNames() -> List.
        Returns a list containing the names of all currently registered ViewerProcesses.
        @return: List.
        """
        ...

    def unregister(self, *args, **kwargs):
        """
        nuke.ViewerProcess.unregister(name) -> None.
        Unregister a ViewerProcess. This is a class method.
        @param name: Menu name.
        @return: None.
        """
        ...
    ...

class ViewerWindow:
    """
    ViewerWindow
    """

    def activateInput(self, input: int, secondary: bool = False) -> None:
        """
        Set the given viewer input to be active - i. e. show its image in the output window.

        @param input: The viewer input number, starting with 0 for the first.  If the input is not

        connected, a ValueError exception is raised.

        @param secondary: True if the input should be connected as the secondary (wipe) input, or

        False to connect it as the primary input (the default).

        @return: None
        """
        ...

    def activeInput(self, secondary=False) -> Optional[int]:
        """
        Returns the currently active input of the viewer - i. e. the one with its image in the output window.

        @param secondary: True to return the index of the active secondary (wipe) input, or False (the default)

        to return the primary input.

        @return: int: The currently active input of the viewer, starting with 0 for the first, or None if no input is active.
        """
        ...

    def frameControl(self, i) -> bool:
        """
        i is an integer indicating viewer frame control 'button' to execute:



           -6 go to start

           -5 play reverse

           -4 go to previous keyframe

           -3 step back by increment

           -2 go back previous keyframe or increment, whichever is closer

           -1 step back one frame



            0 stop



           +1 step forward one frame

           +2 go to next keyframe or increment, whichever is closer

           +3 step forward by increment

           +4 go to next keyframe

           +5 play forward

           +6 go to end
        """
        ...

    def getGLCameraMatrix(self) -> _nukemath.Matrix4:
        """
        Return the world transformations of the current GL viewer camera.

        @return: Matrix4: GL camera world transformation.
        """
        ...

    def getGeometryNodes(self, *args, **kwargs):
        """
        self.getGeometry() -> None

        Returns the a list of geometry nodes attached with this viewer

        @return: Nodes: a list of the geometry nodes.
        """
        ...

    def nextView(self) -> ...:
        """
        switch to next view in settings Views list
        """
        ...

    def node(self) -> Node:
        """
        Returns the Viewer node currently associated with this window.

        @return: Node.
        """
        ...

    def play(self, *args, **kwargs):
        """
        Play forward (1) or reverse (0).
        """
        ...

    def previousView(self) -> ...:
        """
        switch to previous view in settings Views list
        """
        ...

    def setView(self, s) -> ...:
        """
        set 'current' multi-view view to 's'
        """
        ...

    def stop(self, *args, **kwargs):
        """
        Stop playing.
        """
        ...

    def view(self) -> Str:
        """
        String name of 'current' multi-view view
        """
        ...
    ...

class WH_Knob(Array_Knob):
    """
    A knob which holds width and height values.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def names(self, *args, **kwargs):
        """
        Return name for dimension 'i'.
        """
        ...

    def x(self, *args, **kwargs):
        """
        Return value for X position.
        """
        ...

    def x_at(self, *args, **kwargs):
        """
        Return value for X position at time 't'.
        """
        ...

    def y(self, *args, **kwargs):
        """
        Return value for Y position.
        """
        ...

    def y_at(self, *args, **kwargs):
        """
        Return value for Y position at time 't'.
        """
        ...
    ...

class XYZ_Knob(Array_Knob):
    """
    A knob which holds a 3D coordinate.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def names(self, n) -> Str:
        """
        Return name for dimension n. The argument n is an integer.
        """
        ...

    def parent(self) -> XYZ_Knob:
        """
        Return parent.
        """
        ...

    def value(self, n, oc) -> float:
        """
        Return value for dimension n. The optional argument oc is an OutputContext.
        """
        ...

    def x(self, oc) -> float:
        """
        Return value for x. The optional oc argument is an OutputContext
        """
        ...

    def y(self, oc) -> float:
        """
        Return value for y. The optional oc argument is an OutputContext
        """
        ...

    def z(self, oc) -> float:
        """
        Return value for z. The optional oc argument is an OutputContext
        """
        ...
    ...

class XY_Knob(Array_Knob):
    """
    A knob which describes a 2D position.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(
        self,
        name: Str,
        label: Optional[Str] = None,
        /,
    ):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def names(self, n) -> Str:
        """
        Return name for dimension n. The argument n is an integer.
        """
        ...

    def value(self, n, oc) -> float:
        """
        Return value for dimension n. The optional argument oc is an OutputContext.
        """
        ...

    def x(self, oc) -> float:
        """
        Return value for x. The optional oc argument is an OutputContext
        """
        ...

    def y(self, oc) -> float:
        """
        Return value for y. The optional oc argument is an OutputContext
        """
        ...
    ...

def activeViewer() -> Optional[ViewerWindow]:
    """
    Return an object representing the active Viewer panel. This
    is not the same as the Viewer node, this is the viewer UI element.

    @return: Object representing the active ViewerWindow
    """
    ...

def addFavoriteDir(name, directory, type, icon, tooltip, key) -> None:
    """
    Add a path to the file choosers favorite directory list. The path name can contain environment variables which will be expanded when the user clicks the favourites button

    @param name: Favourite path entry ('Home', 'Desktop', etc.).
    @param directory: FileChooser will change to this directory path.
    @param type: Optional bitwise OR combination of nuke.IMAGE, nuke.SCRIPT, nuke.FONT or nuke.GEO.
    @param icon: Optional filename of an image to use as an icon.
    @param tooltip: Optional short text to explain the path and the meaning of the name.
    @param key: Optional shortcut key.
    @return: None.
    """
    ...

def addFormat(s: Str) -> Optional[Format]:
    """
    Create a new image format, which will show up on the pull-down menus for image formats. You must give a width and height and name. The xyrt rectangle describes the image area, if it is smaller than the width and height (for Academy aperture, for example). The pixel aspect is the ratio of the width of a pixel to the height.

    @param s: String in TCL format "w h ?x y r t? ?pa? name".
    @return: Format or None.
    """
    ...

def addNodePresetExcludePaths(paths) -> None:
    """
    @param paths Sequence of paths to exclude
    Adds a list of paths that will be excluded from Node preset search paths.
    @return: None.
    """
    ...

def addSequenceFileExtension(*args, **kwargs):
    """
    addSequenceFileExtension( fileExtension )
    Adds the input file extension to the list of extensions that will get displayed as sequences in the file browser.
    @param fileExtension the new file extension. Valid examples are: 'exr', '.jpg'; invalid examples are: 'somefile.ext'
    """
    ...

def addToolsetExcludePaths(paths) -> None:
    """
    @param paths Sequence of paths to exclude
    Adds a list of paths that will be excluded from Toolset search paths.
    @return: None.
    """
    ...

def addView(s) -> None:
    """
    Deprecated. Use the Root node.

    Adds a new view to the list of views.

    @param s: View name.
    @return: None
    """
    ...

def allNodes(filter: Str = ..., group: Group = ...) -> list[Node]:
    """
    List of all nodes in a group. If you need to get all the nodes in the script
    from a context which has no child nodes, for instance a control panel, use
    nuke.root().nodes().

    @param filter: Optional. Only return nodes of the specified class.
    @param group: Optional. If the group is omitted the current group (ie the group the user picked a menu item from the toolbar of) is used.
    @param recurseGroups: Optional. If True, will also return all child nodes within any group nodes. This is done recursively and defaults to False.
    @return: List
    """
    ...

def animation(*commands) -> None:
    """
    Does operations on an animation curve.

    The following commands are supported:
      - B{clear} deletes all the keys from the animation.
      - B{erase} C{index I{last_index}} removes all keyframes between index and last_index
      - B{expression} C{I{newvalue}} returns or sets the expression for
        the animation. The default is 'curve' or 'y' which returns the interpolation of the keys.
      - B{generate} C{start end increment field expression I{field expression} ...}
        generates an animation with start, end, and increment. Multiple field/expression pairs
        generate a keyframe. Possible field commands are:
          - B{x} sets the frame number for the next keyframe
          - B{y} sets the keyframe value
          - B{dy} sets the left slope
          - B{ldy} sets left and right slope to the same value
          - B{la} and B{ra} are the length of the slope handle in x direction. A value of 1
            generates a handle that is one third of the distance to the next keyframe.
      - B{index} C{x} returns the index of the last key with x <= t, return -1 for none.
      - B{is_key} return non-zero if there is a key with x == t. The actual return value is the index+1.
      - B{move} C{field expression I{field expression}} replaces all selected keys
        in an animation with new ones as explained above in B{generate}
      - B{name} returns a user-friendly name for this animation. This will eliminate
        any common prefix between this animation and all other selected ones,
        and also replaces mangled names returned by animations with nice ones.
      - B{size} returns the number of keys in the animation.
      - B{test} errors if no points in the animation are selected
      - B{y} index C{I{newvalue}} gets or sets the value of an animation.
      - B{x} index C{I{newvalue}} gets or sets the horizontal position of a key.
        If the animation contains an expression or keyframes, the new value will be overridden.

    See also: animations

    @param object: The animation curve.
    @param commands: a var-args-style list of commands, where each command is one of those defined above.
    @return: None
    """
    ...

def animationEnd() -> float:
    """
    Returns the last frame (or x value) for the currently selected animations.

    @return: The end frame.
    """
    ...

def animationIncrement() -> float:
    """
    Returns a recommended interval between samples of the currently selected animation.

    @return: The recommended interval.
    """
    ...

def animationStart() -> float:
    """
    Returns the starting frame (or x value) for the currently selected animations.

    @return: The start frame.
    """
    ...

def animations() -> tuple:
    """
    Returns a list of animatable things the user wants to work on.

    If this is a command being executed from a menu item in a curve editor, a list of the names of all selected curves is returned. If this list is empty a "No curves selected" error is produced.

    If this is a command being executed from the pop-up list in a knob then a list of all the fields in the knob is returned.

    If this is a command being executed from the right-mouse-button pop-up list in a field of a knob, the name of that field is returned.

    Otherwise this produces an error indicating that the command requires a knob context. You can get such a context by doing "in <knob> {command}"

    Also see the 'selected' argument to the animation command.

    See also: animation, animationStart, animationEnd, animationIncrement

    @return: A tuple of animatable things.
    """
    ...

def applyPreset(nodeName, presetName) -> None:
    """
    Applies a given preset to the current node.
    @param nodeName: Name of the node to apply the preset to.
    @param presetName: Name of the preset to use.
    @param node: (optional) a Node object to apply the preset to. If this is provided, the nodeName parameter is ignored.
    @return: bool.
    """
    ...

def applyUserPreset(nodeName, presetName) -> None:
    """
    Applies a given user preset to the current node.
    @param nodeName: Name of the node to apply the preset to.
    @param presetName: Name of the preset to use.
    @param node: (optional) a Node object to apply the preset to. If this is provided, the nodeName parameter is ignored.
    @return: bool.
    """
    ...

def ask(prompt: Str) -> bool:
    """
    Show a Yes/No dialog.

    @param prompt: Present the user with this message.
    @return: True if Yes, False otherwise.
    """
    ...

def askWithCancel(prompt) -> bool:
    """
    Show a Yes/No/Cancel dialog.

    @param prompt: Present the user with this question.
    @return: True if Yes, False if No, an exception is thrown if Cancel.
    """
    ...

def autoplace(n: Node) -> None:
    """
    Deprecated. Use Node.autoplace.

    Automatically place nodes, so they do not overlap.

    @param n: Node.
    @return: None
    """
    ...

def autoplaceSnap(n) -> None:
    """
    Move node to the closest grid position.

    @param n: Node.
    @return: None
    """
    ...

def cacheUsage() -> int:
    """
    Get the total amount of memory currently used by the cache.

    @return: Current memory usage in Str.
    """
    ...

def canCreateNode(name) -> bool:
    """
    This function can be used to determine whether it is possible to create a node with the specified node class.
    @param name: Node name.
    @return: True if the node can be created, or False if not.
    """
    ...

def cancel() -> None:
    """
    Cancel an in-progress operation. This has the same effect as hitting cancel on the progress panel.

    @return: None
    """
    ...

def center() -> list[int]:
    """
    Return the center values of a group's display, these values are suitable to be passed to nuke.zoom as the DAG center point.  Like so:
    center = nuke.center()
    zoom = nuke.zoom()
    print center[0]
    print center[1]
    ## move DAG back to center point without changing zoom.
    nuke.zoom( zoom, center )
    @return: Array of x, y.
    """
    ...

def channels(n: Optional[Node] = None) -> list[Str]:
    """
    Deprecated. Use Node.channels.

    List channels. The n argument is a Nuke node and if given only the channels output by this node are listed. If not given or None, all channels known about are listed.

    @param n: Optional node parameter.
    @return: A list of channel names.
    """
    ...

def choice(
    title: Str,
    prompt: Str,
    options: list[Str],
    default: int = 0,
) -> Optional[int]:
    """
    Shows a dialog box with the given title and prompt text, and a combo box containing the given options.

    @param title: Text to put in the dialog's title bar.
    @param prompt: Text to display at the top of the dialog.
    @param options: A list of Strings for the user to choose from.
    @param default: The index (starting from zero) of the option to select first.
    @return: An integer index (starting from zero) of the choice the user selected, or None if the dialog was cancelled.
    """
    ...

def clearDiskCache() -> None:
    """
    Clear the disk cache of all files.
    """
    ...

def clearRAMCache() -> None:
    """
    Clear the RAM cache of all files.
    """
    ...

def clone(n, args, inpanel) -> Node:
    """
    Create a clone node that behaves identical to the original. The node argument is the node to be cloned, args and inpanel are optional arguments similar to createNode.
    A cloned node shares the exact same properties with its original. Clones share the same set of knobs and the same control panel. However they can
    have different positions and connections in the render tree. Any clone, including the original, can be deleted at any time without harming any of its clones.

    @param n: Node.
    @param args: Optional number of inputs requested.
    @param inpanel: Optional boolean.
    @return: Node
    """
    ...

def cloneSelected(action) -> bool:
    """
    This makes a clone of all selected nodes, preserving connections between them, and makes only the clones be selected.

    @param action: Optional and if 'copy' it cuts the resulting clones to the clipboard.
    @return: True if succeeded, False otherwise.
    """
    ...

def collapseToGroup(show=True) -> Group:
    """
    Moves the currently selected nodes to a new group, maintaining their previous connections.

    @param show: If show is True, the node graph for the new group is shown in the background.
    @return: The new Group node.
    """
    ...

def connectNodes() -> None:
    """
    Deprecated. Use Group.connectSelectedNodes.

    @return: None
    """
    ...

def connectViewer(inputNum, node) -> None:
    """
    Connect a viewer input to a node. The argument i is the input number and n is either a Nuke node or None.
    Some viewer in the current group is found, if there are no viewers one is created. The viewer is then altered to have at least n+1 inputs and then input n is connected to the given node.This function is used by the numeric shortcuts in the DAG view menu.

    @param inputNum: Input number.
    @param node: The Node to connect to the input.
    @return: None
    """
    ...

def createNode(
    node: Str,
    args: Str = ...,
    /,
    inpanel: bool = True,
) -> Node:
    """
    Creates a node of the specified type and adds it to the DAG.

    @param node: Node class (e.g. Blur).
    @param args: Optional String containing a TCL list of name value pairs (like "size 50 quality 19")
    @param inpanel: Optional boolean to open the control bin (default is True; only applies when the GUI is running).
    @return: Node.
    """
    ...

def createScenefileBrowser(fileName, nodeName) -> None:
    """
    Pops up a scene browser dialog box.
    Receives the path to an Alembic (abc) file, and displays a hierarchical tree of the nodes within the file.
    The user can select which nodes they are interested in, and nodes of the appropriate type will automatically.
    be created.
    If a valid scene file nodeName is specified, this node will be populated with the selected tree.

    @param fileName: Path and filename for an alembic file.
    @param nodeName: name of a valid scene file node to populate. If the node is invalid, new nodes will be automatically created
    """
    ...

def createToolset(
    filename: Str = ..., overwrite: bool = ..., rootPath: Str = ...
) -> None:
    """
    Creates a tool preset based on the currently selected nodes.

    @param filename: Saves the preset as a script with the given file name.
     @param overwrite: If 1 (true) always overwrite; if 0 (false) never overwrite; @param rootPath: If specified, use this as the root path to save the Toolset to. If not specified, save to the user's .nuke/Toolsets folder.  otherwise, in GUI mode ask the user, in terminal do same as False. Default  is -1, meaning 'ask the user'.
    """
    ...

def critical(message: Str) -> None:
    """
    Puts the message into the error console, treating it like an error. Also pops up an alert dialog to the user, immediately.

    @param message: String parameter.
    @return: None.
    """
    ...

def debug(message: Str) -> None:
    """
    Puts the message into the error console, treating it like a debug message, which only shows up when the verbosity level is high enough.

    @param message: String parameter.
    @return: None.
    """
    ...

def defaultFontPathname() -> Str:
    """
    Get the path to Nukes default font.

    @return: Path to the font.
    """
    ...

def defaultNodeColor(s: Str) -> int:
    """
    Get the default node colour.

    @param s: Node class.
    @return: The color as a packed integer (0xRRGGBB00).
    """
    ...

def delete(n: Node) -> None:
    """
    The named node is deleted. It can be recovered with an undo.

    @param n: Node.
    @return: None
    """
    ...

def deletePreset(nodeClassName, presetName) -> None:
    """
    Deletes a pre-created node preset
    @param nodeClassName: Name of the node class to create a preset for.
    @param presetName: Name of the preset to create.
    @return: bool.
    """
    ...

def deleteUserPreset(nodeClassName, presetName) -> None:
    """
    Deletes a pre-created user node preset
    @param nodeClassName: Name of the node class to create a preset for.
    @param presetName: Name of the preset to create.
    @return: bool.
    """
    ...

def deleteView(s) -> None:
    """
    Deprecated. Use the Root node.

    Deletes a view from the list of views.

    @param s: View name.
    @return: None
    """
    ...

def display(
    s: Str,
    node: Node,
    title: Str = ...,
    width: Str = ...,
) -> None:
    """
    Creates a window showing the result of a python script. The script is
    executed in the context of the given node, so this and a knob
    name in expressions refer to that node.

    The window will have an 'update' button to run the script again.

    @param s: Python script.
    @param node: Node.
    @param title: Optional title of window.
    @param width: Optional width of window.
    @return: None.
    """
    ...

def endGroup() -> None:
    """
    Deprecated. Use Group.run, Group.begin/Group.end pairs or (preferably) the with statement.

    Changes the current group to the parent of the current group. Does nothing if the current group is a Root (the main window of a script).

    @return: None.
    """
    ...

def error(message) -> None:
    """
    Puts the message into the error console, treating it like an error.

    @param message: String parameter.
    @return: None.
    """
    ...

def execute(
    nameOrNode: Union[Str, Node],
    start: int = ...,
    end: int = ...,
    incr: int = ...,
    views: Optional[list[Str]] = None,
    continueOnError: bool = False,
) -> None:
    """
    execute(nameOrNode, frameRangeSet, views, continueOnError = False) -> None.


    Execute the named Write node over the specified frames.

    There are two variants of this function. The first allows you to specify the frames to write range by giving the start frame number, the end frame number and the frame increment. The second allows you to specify more complicated sets of frames by providing a sequence of FrameRange objects.

    If Nuke is run with the GUI up, this will pop up a progress meter. If the user hits the cancel button this command will return 'cancelled' error. If Nuke is run from the nuke command line (ie nuke was started with the -t switch) execute() prints a text percentage as it progresses. If the user types ^C it will aborting the execute() and return a 'cancelled' error.

    @param nameOrNode: A node name or a node object.
    @param start: Optional start frame. Default is root.first_frame.
    @param end: Optional end frame. Default is root.last_frame.
    @param incr: Optional increment. Default is 1.
    @param views: Optional list of views. Default is None, meaning "all views".
    @return: None
    """
    ...

def executeBackgroundNuke(
    exe_path,
    nodes,
    frameRange,
    views,
    limits,
    continueOnError=False,
    flipbookToRun=...,
    flipbookOptions={},
) -> None:
    """
    Run an instance of Nuke as a monitored sub process. Returns an integer that's used as unique id for the started task. If it failed to launch this will be -1.
    @param exe_path: Path to Nuke or a script that can take Nuke arguments. You probably want to supply nuke.EXE_PATH.
    @param nodes: A list of nodes to execute.
    @param frameRanges: List of frame ranges to execute.
    @param views: A list of view names to execute.
    @param limits: A dictionary with system limits, currently uses keys maxThreads and maxCache.
    @param flipbookToRun: The name of the flipbook application to run after the render, or an empty String if not desired.
    @param flipbookOptions: A dictionary with options to pass to the flipbook. These should include roi and pixelAspect.
    @return: Int.
    """
    ...

def executeMultiple(nodes, ranges, views, continueOnError=False) -> None:
    """
    Execute the current script for a specified frame range. The argument nodes is a sequence of Nuke nodes and ranges is a sequence of range lists. A Nuke range list is a sequence of 3 integers - first, last and incr ( e.g. nuke.execute((w,), ((1,100,1),)) ). The named nodes must all be Write or other executable operators. If no nodes are given then all executable nodes in the current group are executed.
    Note that DiskCache and Precomp nodes do not get executed with this call, unless explicitly specified.

    If Nuke is run with the GUI up, this will pop up a progress meter. If the user hits the cancel button this command will raise a 'cancelled' error. If Nuke is run in terminal mode (with the -t switch) this prints a text percentage as it progresses.

    If the user types ^C it will abort the execute() and raise a 'cancelled' error.

    @param nodes: Node list.
    @param ranges: Optional start frame. Default is root.first_frame.
    @param views: Optional list of views. Default is None. Execute for all.
    @return: None
    """
    ...

def executing() -> bool:
    """
    Returns whether an Executable Node is currently active or not.
    @param f: Optional frame number.
    @return: Current bool.
    """
    ...

def exists(s: Str) -> bool:
    """
    Check for the existence of a named item.
    Function for backwards-compatibility with TCL.

    @param s: Name of item.
    @return: True if exists, False otherwise.
    """
    ...

def expandSelectedGroup() -> None:
    """
    Moves all nodes from the currently selected group node into its parent group, maintaining node input and output connections, and deletes the group. Returns the nodes that were moved, which will also be selected.

    @return: None
    """
    ...

def expr(*args, **kwargs):
    """
    expression(s) -> float

    Parse a Nuke expression. Runs the same expression parser as is used by animations. This is not the same as the tcl expr parser. The main differences are:
    - Only floating point numbers are calculated. There are no Strings, boolean, or integer values.
    - You can name any knob that returns a floating point value, with a dot-separated name, see knob for details on these names. You may follow
    the knob name with a time in parenthesis (like a function call) and if it is animated it will be evaluated at that time. If it is animated and
    no time is given, 'frame' is used.
    - The words 'frame', 't', and 'x' evaluate to the frame number of the context node, or the frame number this animation is being evaluated at.
    - The word 'y' in an animation expression evaluates to the value the animation would have if the control points were used and there was no
    expression. Outside an animation expression y returns zero.

    @param s: The expression, as a String.
    @return: The result.
    """
    ...

def expression(s: Str) -> float:
    """
    Parse a Nuke expression. Runs the same expression parser as is used by animations. This is not the same as the tcl expr parser. The main differences are:
    - Only floating point numbers are calculated. There are no Strings, boolean, or integer values.
    - You can name any knob that returns a floating point value, with a dot-separated name, see knob for details on these names. You may follow
    the knob name with a time in parenthesis (like a function call) and if it is animated it will be evaluated at that time. If it is animated and
    no time is given, 'frame' is used.
    - The words 'frame', 't', and 'x' evaluate to the frame number of the context node, or the frame number this animation is being evaluated at.
    - The word 'y' in an animation expression evaluates to the value the animation would have if the control points were used and there was no
    expression. Outside an animation expression y returns zero.

    @param s: The expression, as a String.
    @return: The result.
    """
    ...

def extractSelected() -> None:
    """
    Disconnects the selected nodes in the group from the tree, and shifts them to the side.

    @return: None
    """
    ...

def filename(node: Node, i: int = ...) -> Optional[Str]:
    """
    Return the filename(s) this node or group is working with.

    For a Read or Write operator (or anything else with a filename
    knob) this will return the current filename, based on the
    root.proxy settings and which of the full-size/proxy filenames are
    filled in. All expansion of commands and variables is
    done. However by default it will still have %%04d sequences in it,
    use REPLACE to get the actual filename with the current frame number.

    If the node is a group, a search is done for executable (i.e. Write)
    operators and the value from each of them is returned. This will duplicate
    the result of calling execute() on the group.

    @param node: Optional node.
    @param i: Optional nuke.REPLACE. Will replace %%04d style sequences with the current frame number.
    @return: Filename, or None if no filenames are found.
    """
    ...

def forceClone() -> bool:
    """
    @return: True if succeeded, False otherwise.
    """
    ...

def forceLoad(n) -> None:
    """
    Force the plugin to be fully instantiated.

    @param n: Optional node argument. Default is the current node.
    @return: None
    """
    ...

def fork(*args, **kwargs):
    """
    Forks a new instance of Nuke optionally with the contents of the named file.
    """
    ...

def formats() -> list:
    """
    @return: List of all available formats.
    """
    ...

def frame(f: int = ...) -> int:
    """
    Return or set the current frame number. Deprecated. Use Root.frame.

    Returns the current frame. Normally this is the frame number set in the root
    node, typically by the user moving the frame slider in a viewer. If a number is
    given, it sets the current frame number to that number. If the current context
    is the root this changes the root frame.
    @param f: Optional frame number.
    @return: Current frame.
    """
    ...

def fromNode(n) -> Str:
    """
    Return the Node n as a String.
    This function is most useful when combining Python and TCL scripts for backwards compatibility reasons.

    @param n: A Node.
    @return: String.
    """
    ...

def getAllUserPresets() -> None:
    """
    gets a list of all current user presets
    @return: a list of tuples containing all nodename/preset-name pairs.
    """
    ...

@overload
def getClipname(
    prompt, pattern=None, default=None, multiple: Literal[False] = False
) -> Str: ...
@overload
def getClipname(
    prompt, pattern=None, default=None, multiple: Literal[True] = ...
) -> list[Str]:
    """
    Pops up a file chooser dialog box. You can use the pattern to reStrict the displayed choices to matching filenames,
    normal Unix glob rules are used here. getClipname compresses lists of filenames that only differ by an index number
    into a single entry called a 'clip'.

    @param prompt: Present the user with this message.
    @param pattern: Optional file selection pattern.
    @param default: Optional default filename and path.
    @param multiple: Optional boolean convertible object to allow for multiple  selection.
    @return: If multiple is True, the user input is returned as a list of  Strings, otherwise as a single String. If the dialog is cancelled, the  return value is None.
    """
    ...

def getColor(initial) -> int:
    """
    Show a color chooser dialog and return the selected color as an int.

    The format of the color values is packed 8bit rgb multiplied by 256 (ie in hex: 0xRRGGBB00).

    @param initial: Optional initial color. Integer with components packed as above.
    @return: The selected color.
    """
    ...

def getDeletedPresets() -> None:
    """
    gets a list of all currently deleted presets
    @return: a pyDict containing all nodename/preset-name pairs.
    """
    ...

def getFileNameList(
    dir: Str,
    splitSequences: bool = False,
    extraInformation: bool = False,
    returnDirs: bool = True,
    returnHidden: bool = False,
    /,
) -> list[Str]:
    """
    @param dir the directory to get sequences from
    @param splitSequences whether to split sequences or not
    @param extraInformation whether or not there should be extra sequence information on the sequence name
    @param returnDirs whether to return a list of directories as well as sequences
    @param returnHidden whether to return hidden files and directories.
    Retrieves the filename list .
    @return: Array of files.
    """
    ...

@overload
def getFilename(
    message,
    pattern=None,
    default=None,
    favorites=None,
    type=None,
    multiple: Literal[False] = False,
) -> Str: ...
@overload
def getFilename(
    message,
    pattern=None,
    default=None,
    favorites=None,
    type=None,
    multiple: Literal[True] = ...,
) -> list[Str]:
    """
    Pops up a file chooser dialog box. You can use the pattern to reStrict the displayed choices to matching filenames, normal Unix glob rules are used here.

    @param message: Present the user with this message.
    @param pattern: Optional file selection pattern.
    @param default: Optional default filename and path.
    @param favorites: Optional. ReStrict favorites to this set. Must be one of  'image', 'script', or 'font'.
    @param type: Optional the type of browser, to define task-specific behaviors;  currently only 'save' is recognised.
    @param multiple: Optional boolean convertible object to allow for multiple  selection. If this is True, the return value will be a list of Strings; if  not, it will be a single String. The default is
    @return: If multiple is True, the user input is returned as a list of  Strings, otherwise as a single String. If the dialog was cancelled, the  return value will be None.
    """
    ...

def getFonts() -> list[Str]:
    """
    Return a list of all available font families and styles

    @return: List of font families and style.
    """
    ...

def getFramesAndViews(label, default=None, maxviews=0) -> ...:
    """
    Pops up a dialog with fields for a frame range and view selection.

    @param label: User message.
    @param default: Optional value for the input field.
    @param maxviews: Optional max number of views.
    @return: List of ranges and views.
    """
    ...

def getInput(prompt: Str, default: Str = ...) -> Optional[Str]:
    """
    Pops up a dialog box with a text field for an arbitrary String.

    @param prompt: Present the user with this message.
    @param default: Default value for the input text field.
    @return: String from text field or None if dialog is cancelled.
    """
    ...

def getNodeClassName() -> None:
    """
    gets the class name for the currently selected node
    @return: a String containing the name.
    """
    ...

def getNodePresetExcludePaths() -> list[Str]:
    """
    Gets a list of all paths that are excluded from the search for node presets.

    @return: List of paths.
    """
    ...

def getNodePresetID() -> None:
    """
    gets the node preset identifier for the currently selected node
    @return: a String containing the ID.
    """
    ...

@type_check_only
class Widget:
    """
    Widget.
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def close(self, *args, **kwargs):
        """
        Called when the widget is asked to be closed.
        """
        ...

    def destroy(self) -> None:
        """
        Destroy the widget.
        """
        ...

    def height(self, *args, **kwargs):
        """
        Get the height.
        """
        ...

    def hide(self, *args, **kwargs):
        """
        Hide the widget.
        """
        ...

    def isEnabled(self, *args, **kwargs):
        """
        Return the enabled state.
        """
        ...

    def isValid(self, *args, **kwargs):
        """
        Returns true if the widget still exists. i.e. has not been closed by the user.
        """
        ...

    def setEnabled(self, *args, **kwargs):
        """
        Enable or disable the widget.
        """
        ...

    def setMaximumSize(self, *args, **kwargs):
        """
        Set the maximum size.
        """
        ...

    def setMinimumSize(self, *args, **kwargs):
        """
        Set the minimum size.
        """
        ...

    def setTooltip(self, *args, **kwargs):
        """
        Set the tooltip.
        """
        ...

    def setVisible(self, *args, **kwargs):
        """
        Show or hide the widget.
        """
        ...

    def show(self, *args, **kwargs):
        """
        Show the widget.
        """
        ...

    def tooltip(self, *args, **kwargs):
        """
        Get the tooltip.
        """
        ...

    def width(self, *args, **kwargs):
        """
        Get the width.
        """
        ...
    ...

@type_check_only
class Container(Widget):
    """
    Container
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def add(self, *args, **kwargs):
        """
        Add a child widget.
        """
        ...
    ...

@type_check_only
class Dock(Container):
    """
    Dock
    """

    __new__: ...
    """
    T.__new__(S, ...) -> a new object with type S, a subtype of T
    """
    def __init__(self, *args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
        ...

    def add(self, *args, **kwargs):
        """
        Add a widget to the dock. Set persistent = True to ensure that the widget is never deStroyed.
        """
        ...
    ...

def getPaneFor(panelName: Str) -> Dock:
    """
    Returns the first pane that contains the named panel or None if it can't be found.
    Note that the panelName must be exact as described in the layout.xml file or the panel ID.
    For example, 'Properties.1' or 'Viewer.1 or 'co.uk.thefoundry.WebBrowser'

    @return: The pane or None.
    """
    ...

def getPresetKnobValues() -> None:
    """
    gets a list of knob values for a given preset
    @param nodeClassName: Name of the node class to get values for.
    @param presetName: Name of the preset to get values for.
    @return: a pyDict containing all knob name/value pairs.
    """
    ...

def getPresets() -> None:
    """
    gets a list of all presets for the currently selected node's class
    @return: a pyList containing all nodename/preset-name pairs.
    """
    ...

def getPresetsMenu(Node) -> Optional[Menu]:
    """
    Gets the presets menu for the currently selected node.
    @return: The menu, or None if it doesn't exist.
    """
    ...

def getReadFileKnob(node) -> Knob:
    """
    Gets the read knob for a node (if it exists).

    @param node: The node to get the knob for.

    @return: A PyObject containing the read knob if it exists, NULL otherwise
    """
    ...

def getRenderProgress() -> int:
    """
    @return: The progress of the render.  Can be 0 if there is no progress to report.
    """
    ...

def getToolsetExcludePaths() -> list[Str]:
    """
    Gets a list of all paths that are excluded from the search for node presets.

    @return: List of paths.
    """
    ...

def getUserPresetKnobValues() -> None:
    """
    gets a list of knob values for a given preset
    @param nodeClassName: Name of the node class to get values for.
    @param presetName: Name of the preset to get values for.
    @return: a pyDict containing all knob name/value pairs.
    """
    ...

def getUserPresets(Node) -> None:
    """
    gets a list of all user presets for the currently selected node's class
    @return: a pyList containing all nodename/preset-name pairs.
    """
    ...

def hotkeys() -> Str:
    """
    Returns the Nuke key assignments as a String formatted for use in nuke.display().

    @return: A formatted String.
    """
    ...

def inputs(n, i) -> int:
    """
    Deprecated. Use Node.inputs.

    Get how many inputs the node has. Normally this is a constant but some nodes have a variable number, the user can keep connecting them and the count will increase.
    Attempting to set the number will just disconnect all inputs greater or equal to number. For a variable input node this may decrease
    inputs to the new value. For most nodes this will have no effect on the value of inputs.

    @param n: Node.
    @param i: Optional number of inputs requested.
    @return: Number of inputs.
    """
    ...

def invertSelection() -> None:
    """
    Selects all unselected nodes, and deselects all selected ones.

    @return: None.
    """
    ...

def knob(
    name: Str,
    value: Str = ...,
    type: bool = ...,
    **kwargs: dict[Literal["class"], Optional[bool]],
) -> None:
    """
    Returns or sets the entire state of a knob.

    Each individual control on a control panel is called a 'knob'. A
    knob's name is a dot-separated list. An example of a fully-expanded
    name of a knob is 'root.Group1.Blur1.size.w'. 'root' is the node
    name of the outermost group, 'Group1' is a group inside that
    containing the blur operator, 'Blur1' is the name of a blur
    operator, 'size' is the name of the actual knob, and 'w' is the
    name of the 'field' (there are two fields in a blur size, 'w' and
    'h').

    You can omit a lot of this because all knob names are figured out
    relative to a 'current knob' and 'current node'. These are set
    depending on the context of where the scripting is invoked. For
    menu items the current node is the group that contained the menu,
    and there is no current knob. For expressions typed into knob
    fields the current knob is that knob and the current node is the
    node the knob belongs to.

    If a name does not start with 'root' then a search upwards is done
    for the first word in the name, first against the fields in the
    current knob, then against the knobs in the current node, then
    against the nodes in the group containing the current node (or in
    it if it is a group), on up to the root.

    The word 'this' means the current knob or the current node.

    The word 'input' means the first (0 or B) input of a node. Ie
    'Blur1.input' returns the node connected to the input of Blur1,
    while 'Blur1.input.input' returns the input of that node.

    If you are getting the value for reporting to the user, you probably
    want to use the value or expression commands.

    If the getType argument is specified and is True, it will print out the type of the
    knob rather than getting or setting the value. The type is an integer,
    using the same list as addUserKnob.

    If the getClass argument is specified and is True, it will print out the type of the knob as a String, e.g. 'Int_Knob',
    'Enumeration_Knob', 'XY_Knob'.

    If both the getType and getClass arguments are present and are True, getType takes precedence.
    @param name: The name of the knob.
    @param value: Optional argument. If this is present, the value will be stored into the knob.
    @param type: Optional boolean argument. If True, return the class ID for the knob instead of the knob itself. The class ID is an int.
    @param class: Optional boolean argument. If True, return the class name for the knob instead of the knob itself. The class name is a String.
        `class` is a python keyword, use **{'class': True} to pass it
    """
    ...

def knobDefault(classknob: Str, value: Str) -> Optional[Str]:
    """
    Set a default value for knobs in nodes that belong to the
    same class. All knobs with matching names, that are created after this
    command was issued, will default to the new value. If class. is missing
    or is "*." then this default applies to all nodes with such a knob.
    If several values are supplied, the first value which is valid will be
    used as the default.
    knobDefault can be used to specify file format specific knobs.
    These are knobs that are added to Read, Write and other file format
    dependent nodes when the file name changes. To specify defaults, use
    the class name, followed by the file format extension, followed by the knob name,
    all separated by periods. An example is shown below.

    Example:
    nuke.knobDefault("Blur.size", "20")

    Example:
    nuke.knobDefault("Read.exr.compression", "2")

    @param classknob: String in the form "class.knob" where "class" is the class of Node, i.e. Blur, and "knob" is the name of the knob. This can also include a file extension, as in "class.extension.knob"
    @param value: Optional String to convert to the default value.
    @return: None or String with the default value.
    """
    ...

def knobTooltip(classknob, value) -> None:
    """
    Set an override for a tooltip on a knob.

    Example:

       nuke.knobTooltip('Blur.size', '[some text]')

    @param classknob: String in the form "class.knob" where "class" is the class of Node, i.e. Blur, and "knob" is the name of the knob.
    @param value: String to use as the tooltip
    @return: None
    """
    ...

def layers(node: Optional[Node] = None) -> list[Str]:
    """
    Lists the layers in a node. If no node is provided this will list all known layer names in this script.

    @param node: Optional node parameter.
    @return: A list of layer names.
    """
    ...

def licenseInfo() -> None:
    """
    Shows information about licenses used by nuke
    """
    ...

def load(s) -> None:
    """
    Load a plugin. You can force a certain plugin to load with this function. If the plugin has already been loaded nothing happens.
    If there is no slash in the name then the pluginPath() is searched for it. If there is a slash then the name is used directly as a
    filename, if it does not start with a slash the name is relative to the directory containing any plugin being currently loaded.
    If no filename extension is provided, it will try appending '.so' (or whatever your OS dynamic library extension is) and finding
    nothing will also try to append '.tcl' and '.py'.

    @param s: Plugin name or filename.
    @return: None
    @raise RuntimeError: if the plugin couldn't be loaded for any reason.
    """
    ...

def loadToolset(filename=None, overwrite=-1) -> None:
    """
    Loads the tool preset with the given file name.

    @param filename: name of preset script file to load
    """
    ...

def localisationEnabled(knob) -> bool:
    """
    Checks if localisation is enabled on a given Read_File_Knob.

    @param knob: The Read_File_Knob to check.

    @return: true if enabled, false otherwise
    """
    ...

def localiseFiles(readKnobs) -> None:
    """
    This functionality has been removed, please check the documentation
    @return: None.
    """
    ...

def makeGroup(show=True) -> Group:
    """
    Creates a new group containing copies of all the currently selected nodes. Note that this creates duplicates of the selected nodes, rather than moving them.

    @param show: If show is True, the node graph for the new group is shown.
    @return: The new Group node.
    """
    ...

def maxPerformanceInfo(*args, **kwargs):
    """
    maxPerformanceInfo -> Get the max performance info for this session.

    Returns a Struct containing the max performance info if performance timers are in use, otherwise returns None.
    """
    ...

def memory(cmd: Str, value=...) -> Union[Str, int]:
    """
    Get or set information about memory usage.

    The value parameter is optional and is only used by some of the commands (see below).

    The cmd parameter specifies what memory information to retrieve. It can be one of the following values:
    - info [node-name]                           Return a String describing current memory usage. Can optionally provide it for a specific node.
    - infoxml [format_Str] [node-name]         Return current memory usage as above, but in XML format. Can optionally provide if Str should be formatted to be human readable, and also a specific node
    - allocator_info [format_Str]              Return current allocator usage in XML format. Can optionally provide if Str should be formatted to be human readable
    - free [size]                                Free as much memory as possible. If a size is specified, if will stop trying to free memory when usage drops below the size.
    - usage                                      Return the amount of memory currently in use.
    - max_usage [size]                           If no size is specified, returns the current size of the memory limit.  If a size is given, then set this size as the memory limit.
    - total_ram                                  Return the total amount of RAM.
    - total_vm                                   Return the total virtual memory.
    - free_count [num]                           Get or set the free count.
    - new_handler_count [num]                    Get or set the new handler count.
    """
    ...

def menu(name: Str) -> Menu:
    """
    Find and return the Menu object with the given name. Current valid menus are:

    'Nuke'          the application menu
    'Pane'          the UI Panes & Panels menu
    'Nodes'         the Nodes toolbar (and Nodegraph right mouse menu)
    'Properties'    the Properties panel right mouse menu
    'Animation'     the knob Animation menu and Curve Editor right mouse menu
    'Viewer'        the Viewer right mouse menu
    'Node Graph'    the Node Graph right mouse menu
    'Axis'          functions which appear in menus on all Axis_Knobs.

    @param name: The name of the menu to get. Must be one of the values above.
    @return: The menu.
    @raise RuntimeError: if Nuke isn't in GUI mode.
    """
    ...

def message(prompt: Str) -> None:
    """
    Show an info dialog box. Pops up an info box (with a 'i' and the text message) and waits for the user to hit the OK button.

    @param prompt: Present user with this message.
    @return: None
    """
    ...

def modified(status: bool = ...) -> bool:
    """
    Deprecated. Use Root.modified and Root.setModified.

    Get or set the 'modified' flag in a script. Setting the value will turn the indicator in the title bar on/off and will start or stop the autosave timeout.

    @param status: Optional boolean value. If this is present the status will be set to this value; otherwise it will be retrieved instead.
    @return: True if modified, False otherwise.
    """
    ...

def nodeCopy(s: Str) -> bool:
    """
    Copy all selected nodes into a file or the clipboard.

    @param s: The name of a clipboard to copy into. If s is the String '%clipboard%' this will copy into the operating systems clipboard.
    @return: True if any nodes were selected, False otherwise.
    """
    ...

def nodeDelete(s) -> bool:
    """
    Removes all selected nodes from the DAG.

    @return: True if any nodes were deleted, False otherwise.
    """
    ...

def nodePaste(s: Str) -> Node:
    """
    Paste nodes from a script file or the clipboard.
    This function executes the script stored in a file. It is assumed the script is the result of
    a nodeCopy command. The 's' argument can be '%clipboard%' to paste the operating system's clipboard contents.

    @param s: The 's' argument can be '%clipboard%' to paste the operating system's clipboard contents.
    @return: Node
    """
    ...

def nodesSelected() -> None:
    """
    returns true if any nodes are currently selected
    """
    ...

def numvalue(knob: Str, default: float = ...) -> float:
    """
    The numvalue function returns the current value of a knob.

    This is the same as the value() command except it will always return a number. For enumerations this returns the index into the menu, starting at zero. For checkmarks this returns 0 for false and 1 for true.
    @param knob: A knob.
    @param default: Optional default value to return if the knob's value cannot  be converted to a number.
    @return: A numeric value for the knob, or the default value (if any).
    """
    ...

def oculaPresent() -> bool:
    """
    Check whether Ocula is present.

    @return: True if Ocula is present, False if not.
    """
    ...

def ofxAddPluginAliasExclusion(fullOfxEffectName) -> None:
    """
    Adds the ofx effect name to a list of exclusions that will not get tcl aliases automatically created for them.
    For example, if there is an ofx plugin with a fully qualified name of: 'OFXuk.co.thefoundry.noisetools.denoise_v100'.
    Nuke by default would automatically alias that so that nuke.createNode('Denoise') will create that node type.
    By calling nuke.ofxAddPluginAliasExclusion('OFXuk.co.thefoundry.noisetools.denoise_v100'), you'd be changing
    that such that the only way to create a node of that type would be to call nuke.createNode('OFXuk.co.thefoundry.noisetools.denoise_v100')
    This does not change saving or loading of Nuke scripts with that plugin used in any way.
    @param fullOfxEffectName: The fully qualified name of the ofx plugin to add to the exclusion list.
    @return: None.
    """
    ...

def ofxMenu() -> bool:
    """
    Find all the OFX plugins (by searching all the directories below $OFX_PLUGIN_PATH,
    or by reading a cache file stored in $NUKE_TEMP_DIR), then add a menu item for each
    of them to the main menu.

    @return: True if succeeded, False otherwise.
    """
    ...

def ofxPluginPath(*args, **kwargs):
    """
    nuke.ofxPluginPath() -> String list

    List of all the directories Nuke searched for OFX plugins in.

    @return: String list
    """
    ...

def ofxRemovePluginAliasExclusion(fullOfxEffectName) -> None:
    """
    Remove an ofx plugin alias exclusion that was previously added with .
    Example: nuke.ofxRemovePluginAliasExclusion('OFXuk.co.thefoundry.noisetools.denoise_v100')
    @param fullOfxEffectName: The fully qualified name of the ofx plugin to remove from the exclusion list.
    @return: None.
    """
    ...

def openPanels(*args, **kwargs):
    """
    nodesSelected() -> List

    returns a list of Nodes which have panels open.The last item in the list is the currently active Node panel.
    """
    ...

def pan() -> list[int]:
    """
    Return the pan values of a group's display.
    This function is deprecated and will be removed in a future version.  You probably want to use nuke.center().

    n = nuke.pan()
    print n[0]
    print n[1]

    @return: Array of x, y.
    """
    ...

def performanceProfileFilename() -> Str:
    """
    Returns the profile filename if performance timers are in use, otherwise returns None.
    """
    ...

def pluginAddPath(*args, **kwargs):
    """
    nuke.pluginAddPath(s) -> None

    Adds all the paths to the beginning of the Nuke plugin path.

    If the path already exists in the list of plugin paths, it is moved to the start. If this command is executed inside an init.py then the init.py in the path will be executed.

    @param s: Sequence of paths.
    @return: None
    """
    ...

def pluginAppendPath(s) -> None:
    """
    Add a filepath to the end of the Nuke plugin path.  If the path
    already exists in the list of plugin paths, it will remain at its
    current position.
    @param s: Sequence of paths.
    @return: None.
    """
    ...

def pluginExists(name) -> bool:
    """
    This function is the same as load(), but only checks for the existence of a plugin rather than loading it.
    If there is no slash in the name then the pluginPath() is searched for it. If there is a slash then the name is used directly as a
    filename, if it does not start with a slash the name is relative to the directory containing any plugin being currently loaded.
    If no filename extension is provided, it will try appending '.so' (or whatever your OS dynamic library extension is) and finding
    nothing will also try to append '.tcl' and '.py'.

    @param name: Plugin name or filename.
    @return: True if found, or False if not.
    """
    ...

def pluginInstallLocation() -> list[Str]:
    """
    The system-specific locations that Nuke will look in for third-party plugins.

    @return: List of paths.
    """
    ...

def pluginPath() -> list[Str]:
    """
    List all the directories Nuke will search in for plugins.

    The built-in default is ~/.nuke and the 'plugins' directory from the same location the NUKE executable file is in. Setting the environment variable $NUKE_PATH to a colon-separated list of directories will replace the ~/.nuke with your own set of directories, but the plugins directory is always on the end.

    @return: List of paths.
    """
    ...

def plugins(switches=0, *pattern) -> list[Str]:
    """
    Returns a list of every loaded plugin or every plugin available. By default each plugin is returned as the full pathname of the plugin file.

    You can give a glob-style matching pattern and only the plugins whose filenames (not path) match the pattern will be returned. You can give more than one glob pattern if desired.

    You can also put options before the glob patterns. Currently supported:

      ALL    Return all plugins in each of the plugin_path() directories,
             rather than only the currently loaded plugins.

      NODIR  Just put the filenames in the list, not the full path. There
             may be duplicates.

    If you don't specify any switches, the default behaviour is to return a list
    with the full paths of all loaded plugins.

    @param switches: Optional parameter. Bitwise OR of nuke.ALL, nuke.NODIR.
    @param pattern: Zero or more glob patterns.
    @return: List of plugins.
    """
    ...

def recentFile(index) -> Str:
    """
    Returns a filename from the recent-files list.

    @param index: A position in the recent files list. This must be a non-negative number.
    @return: A file path.
    @raise ValueError: if the index is negative.
    @raise RuntimeError: if there is no entry in the recent files list for the specified index.
    """
    ...

def redo() -> None:
    """
    Perform the most recent redo.

    @return: None
    """
    ...

def removeFavoriteDir(name, type) -> None:
    """
    Remove a directory path from the favorites list.

    @param name: Favourite path entry ('Home', 'Desktop', etc.).
    @param type: Optional bitwise OR combination of nuke.IMAGE, nuke.SCRIPT, nuke.FONT or nuke.GEO.
    @return: None
    """
    ...

def render(
    nameOrNode: Union[Str, Node],
    /,
    start: int = ...,
    end: int = ...,
    incr: int = ...,
    views: Optional[list[Str]] = ...,
) -> None:
    """
    execute(nameOrNode, start, end, incr, views, continueOnError = False) -> None.
    execute(nameOrNode, frameRangeSet, views, continueOnError = False) -> None.


    Execute the named Write node over the specified frames.

    There are two variants of this function. The first allows you to specify the frames to write range by giving the start frame number, the end frame number and the frame increment. The second allows you to specify more complicated sets of frames by providing a sequence of FrameRange objects.

    If Nuke is run with the GUI up, this will pop up a progress meter. If the user hits the cancel button this command will return 'cancelled' error. If Nuke is run from the nuke command line (ie nuke was started with the -t switch) execute() prints a text percentage as it progresses. If the user types ^C it will aborting the execute() and return a 'cancelled' error.

    @param nameOrNode: A node name or a node object.
    @param start: Optional start frame. Default is root.first_frame.
    @param end: Optional end frame. Default is root.last_frame.
    @param incr: Optional increment. Default is 1.
    @param views: Optional list of views. Default is None, meaning "all views".
    @return: None
    """
    ...

def rescanFontFolders() -> None:
    """
    Rebuild the font cache scanning all available font directories.

    @return: None.
    """
    ...

def resetPerformanceTimers() -> None:
    """
    Clears the accumulated time on the performance timers.
    """
    ...

def restoreWindowLayout(i) -> None:
    """
    Restores a saved window layout.
    @param i: Layout number
    @return: None
    """
    ...

def resumePathProcessing() -> None:
    """
    Resume path processing.
    Use prior to performing multiple node graph modifications, to avoid repeated path processing.
    @return: None.
    """
    ...

def root() -> Root:
    """
    Get the DAG's root node. Always succeeds.

    @return: The root node. This will never be None.
    """
    ...

def runIn(cmd) -> bool:
    """
    Execute commands with a given node/knob/field as the 'context'.
    This means that all names are evaluated relative to this object, and commands that modify 'this' node will modify the given one.

    @param object: Name of object.
    @param cmd: Command to run.
    @return: True if succeeded, False otherwise.
    """
    ...

def sample(n, c, x, y, dx, dy) -> float:
    """
    Get pixel values from an image. Deprecated, use Node.sample instead.

    This requires the image to be calculated, so performance may be very bad if this is placed into an expression in a control panel. Produces a cubic filtered result. Any sizes less than 1, including 0, produce the same filtered result, this is correct based on sampling theory. Note that integers are at the corners of pixels, to center on a pixel add .5 to both coordinates. If the optional dx,dy are not given then the exact value of the square pixel that x,y lands in is returned. This is also called 'impulse filtering'.

    @param n: Node.
    @param c: Channel name.
    @param x: Centre of the area to sample (X coordinate).
    @param y: Centre of the area to sample (Y coordinate).
    @param dx: Optional size of the area to sample (X coordinate).
    @param dy: Optional size of the area to sample (Y coordinate).
    @return: Floating point value.
    """
    ...

def saveEventGraphTimers() -> None:
    """
    Save events in the event graph.
    """
    ...

def saveToScript(filename, fileContent) -> None:
    """
    Saves the fileContent with the given filename.
    """
    ...

def saveUserPreset(node, presetName) -> None:
    """
    Saves a node's current knob values as a user preset.
    @param presetName: Name of the preset to create.
    @return: bool.
    """
    ...

def saveWindowLayout(i=-1) -> None:
    """
    Saves the current window layout.

    @param i: Optional layout index. If this is omitted or set to a negative value, save as the default layout.
    @return: None.
    """
    ...

def scriptClear(resetToCompiledDefaults: bool = ...) -> None:
    """
    Clears a Nuke script and resets all the root knobs to user defined knob defaults.
    To reset to compiled in defaults only pass in resetToCompiledDefaults=True.
    """
    ...

def scriptClose(*args, **kwargs):
    """
    Close the current script or group. Returns True if successful.
    """
    ...

def scriptExit(*args, **kwargs):
    """
    Exit Nuke.
    """
    ...

def scriptName() -> Str:
    """
    Return the current script's file name
    """
    ...

def scriptNew(*args, **kwargs):
    """
    Start a new script. Returns True if successful.
    """
    ...

def scriptOpen(filePath: Str) -> None:
    """
    Opens a new script containing the contents of the named file.
    """
    ...

def scriptReadFile(
    path: Str,
    /,
) -> None:
    """
    Read nodes from a file.
    """
    ...

def scriptReadText(*args, **kwargs):
    """
    Read nodes from a String.
    """
    ...

def scriptSave(filename: Optional[Str] = None) -> Literal[True]:
    """
    Saves the current script to the current file name. If there is no current file name and Nuke is running in GUI mode, the user is asked for a name using the file chooser.

    @param filename: Save to this file name without changing the script name in the project (use scriptSaveAs() if you want it to change).
    @return: True if the file was saved, otherwise an exception is thrown.
    """
    ...

def scriptSaveAs(filename: Optional[Str] = None, overwrite: int = -1) -> None:
    """
    Saves the current script with the given file name if supplied, or (in GUI mode) asks the user for one using the file chooser. If Nuke is not running in GUI mode, you must supply a filename.

    @param filename: Saves the current script with the given file name if  supplied, or (in GUI mode) asks the user for one using the file chooser.
    @param overwrite: If 1 (true) always overwrite; if 0 (false) never overwrite;  otherwise, in GUI mode ask the user, in terminal do same as False. Default  is -1, meaning 'ask the user'.
    """
    ...

def scriptSource(*args, **kwargs):
    """
    Same as scriptReadFile().
    """
    ...

def selectAll() -> None:
    """
    Select all nodes in the DAG.

    @return: None
    """
    ...

def selectPattern() -> None:
    """
    Selects nodes according to a regular expression matching pattern, entered through an input dialog. The pattern can include wildcards ('?' and '*') as well as regular expressions. The expressions are checked against the node name, label, class, and associated file names.

    @return: None
    """
    ...

def selectSimilar(matchType) -> None:
    """
    Selects nodes that match a node in the current selection based on matchType criteria.

    @param matchType: One of nuke.MATCH_CLASS, nuke.MATCH_LABEL, nuke.MATCH_COLOR.
    @return: None.
    """
    ...

def selectedNode() -> Node:
    """
    Returns the 'node the user is thinking about'.
    If several nodes are selected, this returns one of them. The one returned will be an 'output' node in that no other selected nodes
    use that node as an input. If no nodes are selected, then if the last thing typed was a hotkey this returns the node the cursor is pointing at.
    If none, or the last event was not a hotkey, this produces a 'No node selected' error.

    @return: Node.
    """
    ...

def selectedNodes(filter: Str = ...) -> list[Node]:
    """
    Returns a list of all selected nodes in the current group. An attempt is made to return them in 'useful' order where inputs are done before the final node, so commands applied to this list go from top-down.

    @param filter: Optional class of Node. InStructs the algorithm to apply only to a specific class of nodes.
    @return: The list of selected nodes.
    """
    ...

def setPreset(nodeClassName, presetName, knobValues) -> None:
    """
    Create a node preset for the given node using the supplied knob values
    @param nodeClassName: Name of the node class to create a preset for.
    @param presetName: Name of the preset to create.
    @param knobValues: A dictionary containing a set of knob names and preset values.
    @return: bool.
    """
    ...

def setReadOnlyPresets(readOnly) -> None:
    """
    Sets whether newly created presets should be added in read-only mode.
    Read-only presets can be applied to a node, but can't be overwritten or deleted.
    """
    ...

def setUserPreset(nodeClassName, presetName, knobValues) -> None:
    """
    Create a node preset for the given node using the supplied knob values
    @param nodeClassName: Name of the node class to create a preset for.
    @param presetName: Name of the preset to create.
    @param knobValues: A dictionary containing a set of knob names and preset values.
    @return: bool.
    """
    ...

def show(n, forceFloat) -> None:
    """
    Opens a window for each named node, as though the user double-clicked on them.  For normal operators this opens the
    control panel, for viewers it opens the viewer, for groups it opens the control panel.

    @param n: Optional node argument. Default is the current node.
    @param forceFloat: Optional python object. If it evaluates to True it will open the window as a floating panel. Default is False.
    @return: None
    """
    ...

def showBookmarkChooser(n) -> None:
    """
    Show bookmark chooser search box.

    @return: None
    """
    ...

def showCreateViewsDialog(views) -> None:
    """
    Show a dialog to prompt the user to add or create missing views.

    @param views: List of views to be created.
    @return: An integer value representing the choice the user selected: nuke.ADD_VIEWS, nuke.REPLACE_VIEWS or nuke.DONT_CREATE_VIEWS
    """
    ...

def showDag(n) -> None:
    """
    Show the tree view of a group node or opens a node control panel.

    @param n: Optional Group.
    @return: None
    """
    ...

def showInfo(n) -> Str:
    """
    Returns a long String of debugging information about each node and
    the operators it is currently managing. You should not rely on its
    contents or format being the same in different versions of Nuke.

    @param n: Optional node argument.
    @return: String.
    """
    ...

def showSettings() -> None:
    """
    Show the settings of the current group.

    @return: None
    """
    ...

def splayNodes() -> None:
    """
    Deprecated. Use Group.splaySelectedNodes.

    @return: None
    """
    ...

def startEventGraphTimers() -> None:
    """
    Start keeping track of events in the event graph.
    """
    ...

def startPerformanceTimers() -> None:
    """
    Start keeping track of accumulated time on the performance timers, and display the accumulated time in the DAG.
    """
    ...

def stopEventGraphTimers() -> None:
    """
    Stop keeping track of events in the event graph.
    """
    ...

def stopPerformanceTimers() -> None:
    """
    Stop keeping track of accumulated time on the performance timers, and cease displaying the accumulated time in the DAG.
    """
    ...

def StripFrameRange(clipname) -> Str:
    """
    Strip out the frame range from a clipname, leaving a file path (still possibly with variables).

    @param clipname: The clipname.
    @return: The name without the frame range.
    """
    ...

def suspendPathProcessing() -> None:
    """
    Suspend path processing.
    Use prior to performing multiple node graph modifications, to avoid repeated path processing.
    @return: None.
    """
    ...

def tabClose(*args, **kwargs):
    """
    Close the active dock tab. Returns True if successful.
    """
    ...

def tabNext(*args, **kwargs):
    """
    Make the next tab in this dock active. Returns True if successful.
    """
    ...

def tcl(s: Str, *args: Str) -> Str:
    """
    Run a tcl command. The arguments must be Strings and passed to the command. If no arguments are given and the command has whitespace in it then it is instead interpreted as a tcl program (this is deprecated).

    @param s: TCL code.
    @param args: The arguments to pass in to the TCL code.
    @return: Result of TCL command as String.
    """
    ...

def thisClass() -> None:
    """
    Get the class name of the current node. This equivalent to calling nuke.thisNode().Class(), only faster.

    @return: The class name for the current node.
    """
    ...

def thisGroup() -> Group:
    """
    Returns the current context Group node.

    @return: The group node.
    """
    ...

def thisKnob() -> Knob:
    """
    Returns the current context knob if any.

    @return: Knob or None
    """
    ...

def thisNode() -> Node:
    """
    Return the current context node.

    @return: The node.
    """
    ...

def thisPane() -> Dock:
    """
    Returns the active pane. This is only valid during a pane menu callback or window layout restoration.

    @return: The active pane.
    """
    ...

def thisParent() -> Node:
    """
    Returns the current context Node parent.

    @return: A node.
    """
    ...

def thisView() -> Str:
    """
    Get the name of the current view.
    @return: The current view name as a String.
    """
    ...

def toNode(s: Str) -> Optional[Node]:
    """
    Search for a node in the DAG by name and return it as a Python object.

    @param s: Node name.
    @return: Node or None if it does not exist.
    """
    ...

def toggleFullscreen() -> None:
    """
    Toggles between windowed and fullscreen mode.

    @return: None
    """
    ...

def toggleViewers() -> None:
    """
    Toggles all the viewers on and off.

    @return: None
    """
    ...

def toolbar(name: Str, create: bool = True) -> ToolBar:
    """
    Find and return the ToolBar object with the given name. The name of the built-in nodes toolbar is 'Nodes'.

    A RuntimeException is thrown if not in GUI mode.

    @param name: The name of the toolbar to find or create.
    @param create: Optional parameter. True (the default value) will mean that a new  toolbar gets created if one with the given name couldn't be found; False will  mean that no new toolbar will be created.@return: The toolbar, or None if no toolbar was found and 'create' was False.
    """
    ...

def tprint(
    *value: object,
    sep: Str = Str(" "),
    end: Str = Str("\n"),
    file: IO = ...,
) -> None:
    """
    Prints the values to a Stream, or to stdout by default.

    @param value: A python object
    @param file: a file-like object (Stream); defaults to stdout.
    @param sep: String inserted between values, default a space.
    @param end: String appended after the last value, default a newline.
    @return: None
    """
    ...

def undo() -> None:
    """
    Perform the most recent undo.

    @return: None
    """
    ...

def usingPerformanceTimers() -> bool:
    """
    Return true if performance timers are in use.
    """
    ...

def value(knob: Str, default: Optional[Str] = None) -> Str:
    """
    The value function returns the current value of a knob.

    The knob argument is a String referring to a knob
    and default is an optional default value to be returned in case of an error.

    Unlike knob(), this will evaluate animation at the current frame,
    and expand brackets and dollar signs in String knobs.
    """
    ...

def views() -> list:
    """
    List of all the globally existing views.
    """
    ...

def waitForThreadsToFinish() -> Str:
    """
    Returns true if Nuke should wait for any Python threads to finish before exiting.
    @return: True or False.
    """
    ...

def warning(message) -> None:
    """
    Puts the message into the error console, treating it like a warning.

    @param message: String parameter.
    @return: None.
    """
    ...

def zoom(
    scale: float = ..., center: tuple[int, int] = ..., group: Group = ..., /
) -> Optional[float]:
    """
    Change the zoom and pan of a group's display. The scale argument is the new zoom factor.
    If the scale is given, but not the center, the zoom is set to that factor and the view is
    positioned so the cursor is pointing at the same place it was before zooming. A zero or negative
    scale value will cause a zoom-to-fit.

    If both scale and center arguments are given, the view is zoomed and then centered on the
    specified point.

    The new scale factor will be returned, or None if the function is run in a non-GUI context.

    @param scale: New zoom factor.
    @param center: Optional 2-item tuple specifying the center coordinates.
    @param group: Optional Group. This is ignored at present.
    @return: Current zoom factor or None if not in a GUI context.
    """
    ...

def zoomToFitSelected() -> None:
    """
    Does a zoom to fit on the selected nodes in the DAG
    @return: None.
    """
    ...

ADD_VIEWS: int = 0

AFTER_CONST: int = 21

AFTER_LINEAR: int = 22

ALL: int = 1

ALWAYS_SAVE: int = 1048576

BEFORE_CONST: int = 19

BEFORE_LINEAR: int = 20

BREAK: int = 18

CATMULL_ROM: int = 3

CONSTANT: int = 1

CUBIC: int = 4

DISABLED: int = 128

DONT_CREATE_VIEWS: int = 2

DONT_SAVE_TO_NODEPRESET: int = 0

DO_NOT_WRITE: int = 512

ENDLINE: int = 8192

EXE_PATH: Str
"""
'C:/Program Files/Nuke10.5v7/python.exe'
"""

EXPAND_TO_WIDTH: int = 0

EXPRESSIONS: int = 1

FLOAT: int = 5

FONT: int = 4

GEO: int = 16

GUI: bool
"""
False
"""

HIDDEN_INPUTS: int = 4

HORIZONTAL: int = 17

IMAGE: int = 1

INPUTS: int = 2

INT16: int = 3

INT8: int = 2

INTERACTIVE: bool
"""
False
"""

INVALIDHINT: int = -1

INVISIBLE: int = 1024

KNOB_CHANGED_RECURSIVE: int = 134217728

LINEAR: int = 2

LOG: int = 4

MATCH_CLASS: int = 0

MATCH_COLOR: int = 2

MATCH_LABEL: int = 1

MONITOR: int = 0

NODIR: int = 2

NO_ANIMATION: int = 256

NO_CHECKMARKS: int = 1

NO_MULTIVIEW: int = 1073741824

NO_POSTAGESTAMPS: bool
"""
False
"""

NO_UNDO: int = 524288

NUKE_VERSION_DATE: Str
"""
'Nov 14 2017'
"""

NUKE_VERSION_MAJOR: int = 10

NUKE_VERSION_MINOR: int = 5

NUKE_VERSION_PHASE: Str
"""
''
"""

NUKE_VERSION_PHASENUMBER: int = 0

NUKE_VERSION_RELEASE: int = 7

NUKE_VERSION_STRING: Str
"""
'10.5v7'
"""

NUM_CPUS: int = 8

NUM_INTERPOLATIONS: int = 5

PLUGIN_EXT: Str
"""
'dll'
"""

PREPEND: int = 8

PROFILE_ENGINE: int = 3

PROFILE_REQUEST: int = 2

PROFILE_STORE: int = 0

PROFILE_VALIDATE: int = 1

PYTHON: int = 32

READ_ONLY: int = 268435456

REPLACE: int = 1

REPLACE_VIEWS: int = 1

SAVE_MENU: int = 33554432

SCRIPT: int = 2

SMOOTH: int = 0

STARTLINE: int = 4096

STRIP_CASCADE_PREFIX: int = 4

TABBEGINCLOSEDGROUP: int = 2

TABBEGINGROUP: int = 1

TABENDGROUP: int = -1

TABKNOB: int = 0

THREADS: int = 8

TO_SCRIPT: int = 1

TO_VALUE: int = 2

USER_SET_SLOPE: int = 16

VIEWER: int = 1

VIEW_NAMES: Str
"""
'input/view_names'
"""

WRITE_ALL: int = 8

WRITE_NON_DEFAULT_ONLY: int = 16

WRITE_USER_KNOB_DEFS: int = 4

__all__: list[Str]
"""
['AColor_Knob', 'ADD_VIEWS', 'AFTER_CONST', 'AFTER_LINEAR', ...
"""

env: GlobalsEnvironment
"""
{'64bit': True, 'ExecutablePath': 'C:/Program Fi...: 8, 'ple': F...
"""

nodes: Nodes
"""
<Nodes object>

**NOTICE**: prefer `createNode`, it will apply default layout and more type-safe.
"""

rawArgs: list[Str]
"""
[r'C:\\Program Files\\Nuke10.5v7\\python.exe']
"""

untitled: Str
"""
'Untitled'
"""
